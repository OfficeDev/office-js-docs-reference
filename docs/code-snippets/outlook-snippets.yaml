Office.AppointmentCompose#addHandlerAsync:member(1):
  - |-
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.AppointmentCompose#addItemAttachmentAsync:member(1):
  - |-
    // The following example adds an existing Outlook item as an attachment
    // with the name "My Attachment".
    function addAttachment() {
        // EWS ID of item to attach (shortened for readability).
        const itemId = "AAMkADI1...AAA=";

        // The values in asyncContext can be accessed in the callback.
        const options = { asyncContext: { var1: 1, var2: 2 } };

        Office.context.mailbox.item.addItemAttachmentAsync(itemId, "My Attachment", options, (result) => {
            if (result.status === Office.AsyncResultStatus.Failed) {
                console.error("Failed to add attachment: " + result.error.message);
                return;
            }

            console.log("Attachment added successfully.");
            console.log("var1: " + result.asyncContext.var1);
            console.log("var2: " + result.asyncContext.var2);
        });
    }
Office.AppointmentCompose#body:member:
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext: "This is passed to the callback" },
        function callback(result) {
            // Do something with the result.
        });

    // The following is an example of an object that is passed as the result parameter to the callback function.
    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.AppointmentCompose#end:member:
  - |-
    // The following example sets the end time of an appointment in compose mode by
    // using the `setAsync` method of the `Time` object.
    const endTime = new Date("3/14/2015");
    const options = {
        // Pass information that can be used in the callback.
        asyncContext: {verb: "Set"}
    };
    Office.context.mailbox.item.end.setAsync(endTime, options, function(result) {
        if (result.error) {
            console.debug(result.error);
        } else {
            // Access the asyncContext that was passed to the setAsync method.
            console.debug("End Time " + result.asyncContext.verb);
        }
    });
Office.AppointmentCompose#getInitializationContextAsync:member(1):
  - |-
    // Get the initialization context (if present).
    Office.context.mailbox.item.getInitializationContextAsync((asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            if (asyncResult.value.length > 0) {
                // The value is a string, parse to an object.
                const context = JSON.parse(asyncResult.value);
                // Do something with context.
            } else {
                // Empty context, treat as no context.
            }
        } else {
            // Handle the error.
        }
    });
Office.AppointmentCompose#getSelectedDataAsync:member(1):
  - |-
    // Get selected data.
    Office.context.mailbox.item.getSelectedDataAsync(Office.CoercionType.Text, { option1: "option1"}, getCallback);

    function getCallback(asyncResult) {
        const text = asyncResult.value.data;
        const prop = asyncResult.value.sourceProperty;

        console.log(`Selected text in ${prop}: ${text}`);
    }
Office.AppointmentCompose#location:member:
  - |-
    const userContext = { value : 1 };
    Office.context.mailbox.item.location.getAsync( { context: userContext}, callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const location = asyncResult.value;
    }
Office.AppointmentCompose#optionalAttendees:member:
  - |-
    Office.context.mailbox.item.optionalAttendees.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.optionalAttendees.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.optionalAttendees.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfOptionalAttendeesRecipients = asyncResult.value;
    }
Office.AppointmentCompose#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.item.removeHandlerAsync(Office.EventType.InfobarClicked, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.AppointmentCompose#requiredAttendees:member:
  - |-
    Office.context.mailbox.item.requiredAttendees.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.requiredAttendees.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.requiredAttendees.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfRequiredAttendeesRecipients = asyncResult.value;
        console.log(JSON.stringify(arrayOfRequiredAttendeesRecipients));
    }
Office.AppointmentCompose#saveAsync:member(2):
  - |-
    Office.context.mailbox.item.saveAsync(
        function callback(result) {
            // Process the result.
        });

    // The following is an example of the
    // `result` parameter passed to the
    // callback function. The `value`
    // property contains the item ID of
    // the item.
    {
        "value": "AAMkADI5...AAA=",
        "status": "succeeded"
    }
Office.AppointmentCompose#setSelectedDataAsync:member(1):
  - |-
    Office.context.mailbox.item.setSelectedDataAsync("<b>Hello World!</b>", { coercionType : "html" });
  - |-
    Office.context.mailbox.item.setSelectedDataAsync("Hello World!");
Office.AppointmentRead#addHandlerAsync:member(1):
  - |-
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.AppointmentRead#attachments:member:
  - |-
    // The following code builds an HTML string with details of all attachments on the current item.
    const item = Office.context.mailbox.item;
    let outputString = "";

    if (item.attachments.length > 0) {
        for (let i = 0 ; i < item.attachments.length ; i++) {
            const attachment = item.attachments[i];
            outputString += "<BR>" + i + ". Name: ";
            outputString += attachment.name;
            outputString += "<BR>ID: " + attachment.id;
            outputString += "<BR>contentType: " + attachment.contentType;
            outputString += "<BR>size: " + attachment.size;
            outputString += "<BR>attachmentType: " + attachment.attachmentType;
            outputString += "<BR>isInline: " + attachment.isInline;
        }
    }

    console.log(outputString);
Office.AppointmentRead#body:member:
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        Office.CoercionType.Text,
        { asyncContext: "This is passed to the callback" },
        (result) => {
            // Do something with the result.
        }
    );

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": "TEXT of whole body (including message threads that appear below the current body)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.AppointmentRead#displayReplyAllForm:member(1):
  - |-
    // The following code passes a string to the `displayReplyAllForm` method.
    Office.context.mailbox.item.displayReplyAllForm('hello there');
    Office.context.mailbox.item.displayReplyAllForm('<b>hello there</b>');

    // Reply with an empty body.
    Office.context.mailbox.item.displayReplyAllForm({});

    // Reply with just a body.
    Office.context.mailbox.item.displayReplyAllForm(
    {
    'htmlBody' : 'hi'
    });

    // Reply with a body and a file attachment.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
            'type' : Office.MailboxEnums.AttachmentType.File,
            'name' : 'squirrel.png',
            'url' : 'http://i.imgur.com/sRgTlGR.jpg'
            }
        ]
    });

    // Reply with a body and an item attachment.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
            'type' : 'item',
            'name' : 'rand',
            'itemId' : Office.context.mailbox.item.itemId
            }
        ]
    });

    // Reply with a body, file attachment, item attachment, and a callback.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
                'type' : Office.MailboxEnums.AttachmentType.File,
                'name' : 'squirrel.png',
                'url' : 'http://i.imgur.com/sRgTlGR.jpg'
            },
            {
                'type' : 'item',
                'name' : 'rand',
                'itemId' : Office.context.mailbox.item.itemId
            }
        ],
        'callback' : function(asyncResult)
        {
            console.log(asyncResult.value);
        }
    });
Office.AppointmentRead#getInitializationContextAsync:member(1):
  - |-
    // Get the initialization context (if present).
    Office.context.mailbox.item.getInitializationContextAsync((asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            if (asyncResult.value.length > 0) {
                // The value is a string, parse to an object.
                const context = JSON.parse(asyncResult.value);
                // Do something with context.
            } else {
                // Empty context, treat as no context.
            }
        } else {
            // Handle the error.
        }
    });
Office.AppointmentRead#getRegExMatches:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    // The following example shows how to access the array of
    // matches for the regular expression rule elements `fruits`
    // and `veggies`, which are specified in the manifest.
    const allMatches = Office.context.mailbox.item.getRegExMatches();
    const fruits = allMatches.fruits;
    const veggies = allMatches.veggies;
Office.AppointmentRead#getRegExMatchesByName:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    const fruits = Office.context.mailbox.item.getRegExMatchesByName("fruits");
    const veggies = Office.context.mailbox.item.getRegExMatchesByName("veggies");
Office.AppointmentRead#getSelectedRegExMatches:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    // The following example shows how to access the array of matches for the
    // regular expression rule elements `fruits` and `veggies`, which are
    // specified in the manifest.
    const selectedMatches = Office.context.mailbox.item.getSelectedRegExMatches();
    const fruits = selectedMatches.fruits;
    const veggies = selectedMatches.veggies;
Office.AppointmentRead#isAllDayEvent:member:
  - |-
    const isAllDayEvent = Office.context.mailbox.item.isAllDayEvent;
    console.log("Is this an all-day event? " + isAllDayEvent);
Office.AppointmentRead#itemId:member:
  - |-
    // The following code checks for the presence of an item
    // identifier. If the `itemId` property returns `null` or
    // `undefined`, it saves the item to the store and gets the
    // item identifier from the asynchronous result.
    // **Important**: `saveAsync` was introduced with requirement set 1.3
    // so you can't get the `itemId` in Compose mode in earlier sets.
    let itemId = Office.context.mailbox.item.itemId;
    if (itemId === null || itemId == undefined) {
        Office.context.mailbox.item.saveAsync(function(result) {
            itemId = result.value;
        });
    }
Office.AppointmentRead#location:member:
  - |-
    const location = Office.context.mailbox.item.location;
    console.log("location: " + location);
Office.AppointmentRead#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.item.removeHandlerAsync(Office.EventType.InfobarClicked, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.AppointmentRead#sensitivity:member:
  - |-
    const sensitivity = Office.context.mailbox.item.sensitivity;
    console.log("Sensitivity: " + sensitivity);
Office.AppointmentTimeChangedEventArgs:interface:
  - |-
    // Adds an event handler for the AppointmentTimeChanged event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.AppointmentTimeChanged, appointmentTimeChangedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the AppointmentTimeChanged event.
    function appointmentTimeChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        console.log(`Start time: ${event.start}`);
        console.log(`End time: ${event.end}`);
    }
Office.AttachmentsChangedEventArgs:interface:
  - |-
    // Handles the OnMessageAttachmentsChanged event.
    function onMessageAttachmentsChangedHandler(event) {
        console.log(`Event: ${event.type}`);

        if (event.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = event.attachmentDetails;
            // Perform operations on the attachment that was added.
        }
    }
Office.AttachmentContent#format:member:
  - |-
    const item = Office.context.mailbox.item;
    const options = {asyncContext: {currentItem: item}};
    item.getAttachmentsAsync(options, callback);

    function callback(result) {
        if (result.value.length > 0) {
            for (let i = 0 ; i < result.value.length ; i++) {
                result.asyncContext.currentItem.getAttachmentContentAsync(result.value[i].id, handleAttachmentsCallback);
            }
        }
    }

    function handleAttachmentsCallback(result) {
        // Parse string to be a url, an .eml file, a base64-encoded string, or an .icalendar file.
        switch (result.value.format) {
            case Office.MailboxEnums.AttachmentContentFormat.Base64:
                // Handle file attachment.
                break;
            case Office.MailboxEnums.AttachmentContentFormat.Eml:
                // Handle email item attachment.
                break;
            case Office.MailboxEnums.AttachmentContentFormat.ICalendar:
                // Handle .icalender attachment.
                break;
            case Office.MailboxEnums.AttachmentContentFormat.Url:
                // Handle cloud attachment.
                break;
            default:
                // Handle attachment formats that are not supported.
        }
    }
Office.AttachmentDetails:interface:
  - |-
    // The following code builds an HTML string with details
    // of all attachments on the current item.
    const item = Office.context.mailbox.item;
    let outputString = "";

    if (item.attachments.length > 0) {
        for (let i = 0 ; i < item.attachments.length ; i++) {
            const attachment = item.attachments[i];
            outputString += "<BR>" + i + ". Name: ";
            outputString += attachment.name;
            outputString += "<BR>ID: " + attachment.id;
            outputString += "<BR>contentType: " + attachment.contentType;
            outputString += "<BR>size: " + attachment.size;
            outputString += "<BR>attachmentType: " + attachment.attachmentType;
            outputString += "<BR>isInline: " + attachment.isInline;
        }
    }

    console.log(outputString);
Office.Body#getAsync:member(1):
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext: "This is passed to the callback" },
        function callback(result) {
            // Do something with the result.
        });

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.Body#setAsync:member(1):
  - |-
    // When including links in HTML markup, you can disable online link preview
    // by setting the id attribute on the anchor (<a>) to "LPNoLP".
    Office.context.mailbox.item.body.setAsync(
        '<a id="LPNoLP" href="http://www.contoso.com">Click here!</a>',
        { 
            coercionType: Office.CoercionType.Html,
            asyncContext: "This is passed to the callback"
        },
        (result) => {
            // Process the result.
        }
    );

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": null,
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.CategoryDetails:interface:
  - |-
    const categories = [
        {
            "displayName": "Urgent!",
            "color": Office.MailboxEnums.CategoryColor.Preset0
        }
    ];
Office.Contact:interface:
  - |-
    const item = Office.context.mailbox.item;
    // Get an array of strings that represent contacts in the current item's body.
    const contacts = item.getEntitiesByType(Office.MailboxEnums.EntityType.Contact);
    console.log("There are " + contacts.length + " contacts.")
    contacts.forEach(function (contact) {
        console.log("Person name: " + JSON.stringify(contact.personName));
        console.log("Business name: " + JSON.stringify(contact.businessName));
        console.log("Addresses: " + JSON.stringify(contact.addresses));
        console.log("Phone numbers: " + JSON.stringify(contact.phoneNumbers));
        console.log("Email addresses: " + JSON.stringify(contact.emailAddresses));
        console.log("Urls: " + JSON.stringify(contact.urls));
    });

    /* Example email that includes contact details of sender, John Smith:
    Hi there,
    I have received the package.

    Thanks.
    John Smith
    Account Manager
    Contoso Corporation
    1 Contoso Way, Redmond, WA 98052
    john.smith@contoso.com
    111-111-1111
    https://contoso.com/john.smith
    */
Office.EmailAddressDetails#appointmentResponse:member:
  - |-
    // The following sample provides the responses from required attendees.
    // Note that this sample needs the add-in to be in Appointment Read (Attendee) mode.
    const requiredAttendees = Office.context.mailbox.item.requiredAttendees;
    console.log("There are " + requiredAttendees.length + " required attendees.")
    requiredAttendees.forEach(function (requiredAttendee) {
        console.log("Attendee " + requiredAttendee.displayName + ": " + requiredAttendee.appointmentResponse);
    });
Office.EmailAddressDetails#displayName:member:
  - |-
    const organizerName = Office.context.mailbox.item.organizer.displayName;
    console.log("Organizer: " + organizerName);
Office.EmailAddressDetails#emailAddress:member:
  - |-
    const organizerAddress = Office.context.mailbox.item.organizer.emailAddress;
    console.log("Organizer's email address: " + organizerAddress);
Office.EmailAddressDetails#recipientType:member:
  - |-
    const requiredAttendees = Office.context.mailbox.item.requiredAttendees;
    console.log("There are " + requiredAttendees.length + " required attendees.")
    requiredAttendees.forEach(function (requiredAttendee) {
        console.log("Attendee " + requiredAttendee.displayName + ": " + requiredAttendee.recipientType);
    });
Office.EmailUser:interface:
  - |-
    // Add recipients to the To field of an email.
    const recipients: Office.EmailUser[] = [
        {
            "displayName": "Allie Bellew",
            "emailAddress": "allieb@contoso.com"
        },
        {
            "displayName": "Alex Darrow",
            "emailAddress": "alexd@contoso.com"
        }
    ];

    Office.context.mailbox.item.to.addAsync(recipients, (result) => {
        if (result.status === Office.AsyncResultStatus.Failed) {
            console.log(result.error.message);
            return;
        }

        console.log("Recipients added to the To field.");
    });
Office.EnhancedLocationsChangedEventArgs:interface:
  - |-
    // Adds an event handler for the EnhancedLocationsChanged event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.EnhancedLocationsChanged, enhancedLocationsChangedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the EnhancedLocationsChanged event.
    function enhancedLocationsChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const enhancedLocations = event.enhancedLocations;
        enhancedLocations.forEach((location) => {
            console.log(`Display name: ${location.displayName}`);
            const locationType = location.locationIdentifier.type;
            console.log(`Type: ${locationType}`);
            if (locationType === Office.MailboxEnums.LocationType.Room) {
                console.log(`Email address: ${location.emailAddress}`);
            }
        });
    }
Office.Entities#addresses:member:
  - |-
    const item = Office.context.mailbox.item;
    const addresses = item.getEntitiesByType(Office.MailboxEnums.EntityType.Address);
Office.Entities#contacts:member:
  - |-
    const item = Office.context.mailbox.item;
    const contacts = item.getEntitiesByType(Office.MailboxEnums.EntityType.Contact);
Office.Entities#emailAddresses:member:
  - |-
    const item = Office.context.mailbox.item;
    const emailAddresses = item.getEntitiesByType(Office.MailboxEnums.EntityType.EmailAddress);
Office.Entities#meetingSuggestions:member:
  - |-
    const item = Office.context.mailbox.item;
    const meetingSuggestions = item.getEntitiesByType(Office.MailboxEnums.EntityType.MeetingSuggestion);
Office.Entities#phoneNumbers:member:
  - |-
    const item = Office.context.mailbox.item;
    const phoneNumbers = item.getEntitiesByType(Office.MailboxEnums.EntityType.PhoneNumber);
Office.Entities#taskSuggestions:member:
  - |-
    const item = Office.context.mailbox.item;
    const taskSuggestions = item.getEntitiesByType(Office.MailboxEnums.EntityType.TaskSuggestion);
Office.Entities#urls:member:
  - |-
    const item = Office.context.mailbox.item;
    const urls = item.getEntitiesByType(Office.MailboxEnums.EntityType.Url);
Office.InfobarClickedEventArgs:interface:
  - |-
    // Adds an event handler for the InfobarClicked event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.InfobarClicked, infobarClickedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the InfobarClicked event.
    function infobarClickedHandler(event) {
        console.log(`Event: ${event.type}`);
        const infobarDetails = event.infobarDetails;
        console.log(`Notification type: ${infobarDetails.infobarType}`);
        console.log(`Action type: ${infobarDetails.actionType}`);
    }
Office.LoadedMessageCompose:interface:
  - |-
    // Gets the sender's email address of each selected message.
    async function getSenderEmailAddress(item) {
        const itemId = item.itemId;
        await new Promise((resolve) => {
            Office.context.mailbox.loadItemByIdAsync(itemId, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.log(result.error.message);
                    return;
                }

                const loadedItem = result.value;
                const sender = loadedItem.from.emailAddress;
                console.log(sender);

                // Unload the current message before processing another selected message.
                loadedItem.unloadAsync((asyncResult) => {
                    if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                        console.log(asyncResult.error.message);
                        return;
                    }

                    resolve();
                });
            });
        });
    }
Office.LoadedMessageRead:interface:
  - |-
    // Gets the sender's email address of each selected message.
    async function getSenderEmailAddress(item) {
        const itemId = item.itemId;
        await new Promise((resolve) => {
            Office.context.mailbox.loadItemByIdAsync(itemId, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.log(result.error.message);
                    return;
                }

                const loadedItem = result.value;
                const sender = loadedItem.from.emailAddress;
                console.log(sender);

                // Unload the current message before processing another selected message.
                loadedItem.unloadAsync((asyncResult) => {
                    if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                        console.log(asyncResult.error.message);
                        return;
                    }

                    resolve();
                });
            });
        });
    }
Office.Location#getAsync:member(1):
  - |-
    const userContext = { value : 1 };
    Office.context.mailbox.item.location.getAsync( { context: userContext}, callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const location = asyncResult.value;
    }
Office.LocationDetails:interface:
  - |-
    Office.context.mailbox.item.enhancedLocation.getAsync(callbackFunction);

    function callbackFunction(asyncResult) {
        asyncResult.value.forEach(function (place) {
            console.log("Display name: " + place.displayName);
            console.log("Type: " + place.locationIdentifier.type);
            if (place.locationIdentifier.type === Office.MailboxEnums.LocationType.Room) {
                console.log("Email address: " + place.emailAddress);
            }
        });
    }
Office.LocationIdentifier:interface:
  - |-
    const locations = [
        {
            "id": "Contoso",
            "type": Office.MailboxEnums.LocationType.Custom
        }
    ];
Office.Mailbox:interface:
  - |-
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.ItemChanged, loadNewItem, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    // Handle error.
                }
            });
        });
    });

    function loadNewItem(eventArgs) {
        const item = Office.context.mailbox.item;

        // Check that item isn't null.
        if (item !== null) {
            // Work with item. For example, define and call a function that
            // loads the properties of the newly selected item.
            loadProps(item);
        }
    }
Office.Mailbox#addHandlerAsync:member(1):
  - |-
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.ItemChanged, loadNewItem, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    // Handle error.
                }
            });
        });
    });

    function loadNewItem(eventArgs) {
        const item = Office.context.mailbox.item;

        // Check that item isn't null.
        if (item !== null) {
            // Work with item. For example, define and call a function that
            // loads the properties of the newly selected item.
            loadProps(item);
        }
    }
Office.Mailbox#convertToUtcClientTime:member(1):
  - |-
    // Represents 3:37 PM PDT on Monday, August 26, 2019.
    const input = {
        date: 26,
        hours: 15,
        milliseconds: 2,
        minutes: 37,
        month: 7,
        seconds: 2,
        timezoneOffset: -420,
        year: 2019
    };

    // result should be a Date object.
    const result = Office.context.mailbox.convertToUtcClientTime(input);
    
    // Output should be "2019-08-26T22:37:02.002Z".
    console.log(result.toISOString());
Office.Mailbox#getIsIdentityManaged:member(1):
  - |-
    // Checks if the mailbox is managed by Microsoft Intune.
    const isIdentityManaged = Office.context.mailbox.getIsIdentityManaged();
    console.log(`Intune-managed mailbox: ${isIdentityManaged}`);
Office.Mailbox#getIsOpenFromLocationAllowed:member(1):
  - |-
    // Checks if the add-in can access data from the device's photo library.
    const isOpenFromPhotoLibraryAllowed = Office.context.mailbox.getIsOpenFromLocationAllowed(Office.MailboxEnums.OpenLocation.PhotoLibrary);
    if (isOpenFromPhotoLibraryAllowed) {
        console.log("Access to the photo library is allowed.");
        // Do something.
    } else {
        console.log("Access to the photo library isn't allowed.");
    }
Office.Mailbox#getIsSaveToLocationAllowed:member(1):
  - |-
    // Checks if the add-in can save data to SharePoint.
    const isSaveToSharePointAllowed = Office.context.mailbox.getIsSaveToLocationAllowed(Office.MailboxEnums.SaveLocation.SharePoint);
    if (isSaveToSharePointAllowed) {
        console.log("Saving to SharePoint is allowed.");
        // Do something.
    } else {
        console.log("Saving to SharePoint isn't allowed.");
    }
Office.Mailbox#makeEwsRequestAsync:member(1):
  - |-
    function getSubjectRequest(id) {
        // Return a GetItem operation request for the subject of the specified item.
        const request =
            '<?xml version="1.0" encoding="utf-8"?>' +
            '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' +
            '               xmlns:xsd="http://www.w3.org/2001/XMLSchema"' +
            '               xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"' +
            '               xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types">' +
            '  <soap:Header>' +
            '    <RequestServerVersion Version="Exchange2016" xmlns="http://schemas.microsoft.com/exchange/services/2006/types" soap:mustUnderstand="0" />' +
            '  </soap:Header>' +
            '  <soap:Body>' +
            '    <GetItem xmlns="http://schemas.microsoft.com/exchange/services/2006/messages">' +
            '      <ItemShape>' +
            '        <t:BaseShape>IdOnly</t:BaseShape>' +
            '        <t:AdditionalProperties>' +
            '            <t:FieldURI FieldURI="item:Subject"/>' +
            '        </t:AdditionalProperties>' +
            '      </ItemShape>' +
            '      <ItemIds><t:ItemId Id="' + id + '"/></ItemIds>' +
            '    </GetItem>' +
            '  </soap:Body>' +
            '</soap:Envelope>';

        return request;
    }

    function sendRequest() {
        // Create a local variable that contains the mailbox.
        Office.context.mailbox.makeEwsRequestAsync(
            getSubjectRequest(mailbox.item.itemId), callback);
    }

    function callback(asyncResult)  {
        const result = asyncResult.value;
        const context = asyncResult.asyncContext;

        // Process the returned response here.
    }
Office.Mailbox#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.removeHandlerAsync(Office.EventType.OfficeThemeChanged, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.Mailbox#restUrl:member:
  - |-
    // Get the URL of the REST endpoint.
    const restUrl = Office.context.mailbox.restUrl;
    console.log(`REST API URL: ${restUrl}`);
Office.MailboxEnums.AttachmentStatus:enum:
  - |-
    // Get the attachment that was just added to a message or appointment.
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.MailboxEnums.DelegatePermissions:enum:
  - |-
    Office.context.mailbox.item.getSharedPropertiesAsync((result) => {
        if (result.status === Office.AsyncResultStatus.Failed) {
            console.error("The current folder or mailbox isn't shared.");
            return;
        }

        const delegatePermissions = result.value.delegatePermissions;

        // Check if the user has write permissions to the shared resource.
        if ((delegatePermissions & Office.MailboxEnums.DelegatePermissions.Write) != 0) {
            console.log("User has write permissions to the shared resource.");
            // Perform the necessary operations.
        }
    });
Office.MailboxEnums.InfobarActionType:enum:
  - |-
    /*
    * This snippet activates when a notification message is dismissed from an Outlook message or appointment.
    * The event handler logs the custom action and notification type to the console.
    */
    Office.context.mailbox.item.addHandlerAsync(Office.EventType.InfobarClicked, eventHandler, callback);

    function eventHandler(event) {
        const infobarDetails = event.infobarDetails;

        // Log the custom action type.
        console.log(`Custom action type: ${infobarDetails.actionType}`);

        // Log the notification type.
        switch (infobarDetails.infobarType) {
            case Office.MailboxEnums.InfobarType.Error:
                console.log("Notification type: Error message");
                break;
            case Office.MailboxEnums.InfobarType.Informational:
                console.log("Notification type: Informational message");
                break;
            case Office.MailboxEnums.InfobarType.Insight:
                console.log("Notification type: Informational message with available actions from the task pane");
                break;
            case Office.MailboxEnums.InfobarType.ProgressIndicator:
                console.log("Notification type: Progress indicator");
                break;
        }
    }
Office.InfobarDetails:interface:
  - |-
    /*
    * This snippet activates when a notification message is dismissed from an Outlook message or appointment.
    * The event handler logs the custom action and notification type to the console.
    */
    Office.context.mailbox.item.addHandlerAsync(Office.EventType.InfobarClicked, eventHandler, callback);

    function eventHandler(event) {
        const infobarDetails = event.infobarDetails;

        // Log the custom action type.
        console.log(`Custom action type: ${infobarDetails.actionType}`);

        // Log the notification type.
        switch (infobarDetails.infobarType) {
            case Office.MailboxEnums.InfobarType.Error:
                console.log("Notification type: Error message");
                break;
            case Office.MailboxEnums.InfobarType.Informational:
                console.log("Notification type: Informational message");
                break;
            case Office.MailboxEnums.InfobarType.Insight:
                console.log("Notification type: Informational message with available actions from the task pane");
                break;
            case Office.MailboxEnums.InfobarType.ProgressIndicator:
                console.log("Notification type: Progress indicator");
                break;
        }
    }
Office.MailboxEnums.InfobarType:enum:
  - |-
    /*
    * This snippet activates when a notification message is dismissed from an Outlook message or appointment.
    * The event handler logs the custom action and notification type to the console.
    */
    Office.context.mailbox.item.addHandlerAsync(Office.EventType.InfobarClicked, eventHandler, callback);

    function eventHandler(event) {
        const infobarDetails = event.infobarDetails;

        // Log the custom action type.
        console.log(`Custom action type: ${infobarDetails.actionType}`);

        // Log the notification type.
        switch (infobarDetails.infobarType) {
            case Office.MailboxEnums.InfobarType.Error:
                console.log("Notification type: Error message");
                break;
            case Office.MailboxEnums.InfobarType.Informational:
                console.log("Notification type: Informational message");
                break;
            case Office.MailboxEnums.InfobarType.Insight:
                console.log("Notification type: Informational message with available actions from the task pane");
                break;
            case Office.MailboxEnums.InfobarType.ProgressIndicator:
                console.log("Notification type: Progress indicator");
                break;
        }
    }
Office.MailboxEnums.MoveSpamItemTo:enum:
  - |-
    // The following example handles a SpamReporting event to process a reported spam or phishing message.
    function onSpamReport(event) {
        // Get the Base64-encoded EML format of a reported message.
        Office.context.mailbox.item.getAsFileAsync({ asyncContext: event }, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(`Error encountered during message processing: ${asyncResult.error.message}`);
                return;
            }

            // Run additional processing operations here.

            /**
             * Signal that the spam-reporting event has completed processing.
             * It then moves the reported message to a custom mailbox folder named "Reported Messages"
             * and shows a post-processing dialog to the user.
             * If an error occurs while the message is being processed, the `onErrorDeleteItem`
             * property determines whether the message will be deleted.
             */
            const event = asyncResult.asyncContext;
            event.completed({
                moveItemTo: Office.MailboxEnums.MoveSpamItemTo.CustomFolder,
                folderName: "Reported Messages",
                onErrorDeleteItem: true,
                showPostProcessingDialog: {
                    title: "Contoso Spam Reporting",
                    description: "Thank you for reporting this message.",
                },
            });
        });
    }
Office.MailboxEnums.OpenLocation:enum:
  - |-
    // Checks if the add-in can access data from the device's photo library.
    const isOpenFromPhotoLibraryAllowed = Office.context.mailbox.getIsOpenFromLocationAllowed(Office.MailboxEnums.OpenLocation.PhotoLibrary);
    if (isOpenFromPhotoLibraryAllowed) {
        console.log("Access to the photo library is allowed.");
        // Do something.
    } else {
        console.log("Access to the photo library isn't allowed.");
    }
Office.MailboxEnums.SaveLocation:enum:
  - |-
    // Checks if the add-in can save data to SharePoint.
    const isSaveToSharePointAllowed = Office.context.mailbox.getIsSaveToLocationAllowed(Office.MailboxEnums.SaveLocation.SharePoint);
    if (isSaveToSharePointAllowed) {
        console.log("Saving to SharePoint is allowed.");
        // Do something.
    } else {
        console.log("Saving to SharePoint isn't allowed.");
    }
Office.MailboxEnums.SendModeOverride:enum:
  - |-
    // The following example checks whether a location is specified in an appointment before it's sent.
    function onAppointmentSendHandler(event) {
        Office.context.mailbox.item.location.getAsync({ asyncContext: event }, (asyncResult) => {
            const event = asyncResult.asyncContext;
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(asyncResult.error.message);
                // If the add-in is unable to retrieve the appointment's location, the appointment isn't sent.
                event.completed({ allowEvent: false, errorMessage: "Failed to get the appointment's location." });
                return;
            }

            if (asyncResult.value === "") {
                // If no location is specified, the appointment isn't sent and the user is alerted to include a location.
                event.completed(
                    {
                        allowEvent: false,
                        cancelLabel: "Add a location",
                        commandId: "msgComposeOpenPaneButton",
                        errorMessage: "Don't forget to add a meeting location.",
                        sendModeOverride: Office.MailboxEnums.SendModeOverride.PromptUser
                    }
                );
            } else {
                // If a location is specified, the appointment is sent.
                event.completed({ allowEvent: true });
            }
        });
    }
Office.MailboxEvent#completed:member(1):
  - |-
    // The following example sets the subject when a new message is composed.
    function onNewMessageComposeHandler(event) {
        const subject = "Set by an event-based add-in!";
        Office.context.mailbox.item.subject.setAsync(
            subject,
            {
                asyncContext: event,
            },
            (asyncResult) => {
                const event = asyncResult.asyncContext;
                if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                    console.error("Failed to set subject: " + asyncResult.error.message);
                    event.completed();
                    return;
                }

                // Signal to the Outlook client that the event has been processed.
                console.log("Successfully set the subject.");
                event.completed();
            }
        );
    }
Office.MeetingSuggestion:interface:
  - |-
    const item = Office.context.mailbox.item;
    // Get an array of strings that represent meeting suggestions in the current item's body.
    const meetingSuggestions = item.getEntitiesByType(Office.MailboxEnums.EntityType.MeetingSuggestion);
    console.log("There are " + meetingSuggestions.length + " meeting suggestions.")
    meetingSuggestions.forEach(function (meetingSuggestion) {
        console.log("Subject: " + JSON.stringify(meetingSuggestion.subject));
        console.log("Attendees: " + JSON.stringify(meetingSuggestion.attendees));
        console.log("Location: " + JSON.stringify(meetingSuggestion.location));
        console.log("Start: " + JSON.stringify(meetingSuggestion.start));
        console.log("End: " + JSON.stringify(meetingSuggestion.end));
        console.log("Meeting: " + JSON.stringify(meetingSuggestion.meetingString));
    });
Office.MessageCompose#addHandlerAsync:member(1):
  - |-
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.MessageCompose#addItemAttachmentAsync:member(1):
  - |-
    // The following example adds an existing Outlook item as an attachment
    // with the name "My Attachment".
    function addAttachment() {
        // EWS ID of item to attach (shortened for readability).
        const itemId = "AAMkADI1...AAA=";

        // The values in asyncContext can be accessed in the callback.
        const options = { asyncContext: { var1: 1, var2: 2 } };

        Office.context.mailbox.item.addItemAttachmentAsync(itemId, "My Attachment", options, (result) => {
            if (result.status === Office.AsyncResultStatus.Failed) {
                console.error("Failed to add attachment: " + result.error.message);
                return;
            }

            console.log("Attachment added successfully.");
            console.log("var1: " + result.asyncContext.var1);
            console.log("var2: " + result.asyncContext.var2);
        });
    }
Office.MessageCompose#bcc:member:
  - |-
    Office.context.mailbox.item.bcc.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.bcc.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.bcc.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfBccRecipients = asyncResult.value;
    }
Office.MessageCompose#body:member:
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext: "This is passed to the callback" },
        function callback(result) {
            // Do something with the result.
        });

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.MessageCompose#cc:member:
  - |-
    Office.context.mailbox.item.cc.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.cc.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.cc.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfCcRecipients = asyncResult.value;
    }
Office.MessageCompose#getInitializationContextAsync:member(1):
  - |-
    // Get the initialization context (if present).
    Office.context.mailbox.item.getInitializationContextAsync((asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            if (asyncResult.value.length > 0) {
                // The value is a string, parse to an object.
                const context = JSON.parse(asyncResult.value);
                // Do something with context.
            } else {
                // Empty context, treat as no context.
            }
        } else {
            // Handle the error.
        }
    });
Office.MessageCompose#getSelectedDataAsync:member(1):
  - |-
    // Get selected data.
    Office.context.mailbox.item.getSelectedDataAsync(Office.CoercionType.Text, { option1: "option1"}, getCallback);

    function getCallback(asyncResult) {
        const text = asyncResult.value.data;
        const prop = asyncResult.value.sourceProperty;

        console.log(`Selected text in ${prop}: ${text}`);
    }
Office.MessageCompose#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.item.removeHandlerAsync(Office.EventType.ItemChanged, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.MessageCompose#saveAsync:member(2):
  - |-
    Office.context.mailbox.item.saveAsync(
        function callback(result) {
            // Process the result.
        });

    // The following is an example of the
    // `result` parameter passed to the
    // callback function. The `value`
    // property contains the item ID of
    // the item.
    {
        "value": "AAMkADI5...AAA=",
        "status": "succeeded"
    }
Office.MessageCompose#setSelectedDataAsync:member(1):
  - |-
    Office.context.mailbox.item.setSelectedDataAsync("<b>Hello World!</b>", { coercionType : "html" });
  - |-
    Office.context.mailbox.item.setSelectedDataAsync("Hello World!");
Office.MessageCompose#to:member:
  - |-
    Office.context.mailbox.item.to.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.to.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.to.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfToRecipients = asyncResult.value;
    }
Office.MessageRead:interface:
 - |-
   // The following code builds an HTML string with details of all attachments on the current item.
    const item = Office.context.mailbox.item;
    let outputString = "";
    if (item.attachments.length > 0) {
        for (let i = 0 ; i < item.attachments.length ; i++) {
            const attachment = item.attachments[i];
            outputString += "<BR>" + i + ". Name: ";
            outputString += attachment.name;
            outputString += "<BR>ID: " + attachment.id;
            outputString += "<BR>contentType: " + attachment.contentType;
            outputString += "<BR>size: " + attachment.size;
            outputString += "<BR>attachmentType: " + attachment.attachmentType;
            outputString += "<BR>isInline: " + attachment.isInline;
        }
    }
    console.log(outputString);
Office.MessageRead#addHandlerAsync:member(1):
  - |-
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.MessageRead#attachments:member:
  - |-
    // The following code builds an HTML string with details of all attachments on the current item.
    const item = Office.context.mailbox.item;
    let outputString = "";

    if (item.attachments.length > 0) {
        for (let i = 0 ; i < item.attachments.length ; i++) {
            const attachment = item.attachments[i];
            outputString += "<BR>" + i + ". Name: ";
            outputString += attachment.name;
            outputString += "<BR>ID: " + attachment.id;
            outputString += "<BR>contentType: " + attachment.contentType;
            outputString += "<BR>size: " + attachment.size;
            outputString += "<BR>attachmentType: " + attachment.attachmentType;
            outputString += "<BR>isInline: " + attachment.isInline;
        }
    }

    console.log(outputString);
Office.MessageRead#body:member:
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext: "This is passed to the callback" },
        function callback(result) {
            // Do something with the result.
        });

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.MessageRead#displayReplyAllForm:member(1):
  - |-
    // The following code passes a string to the `displayReplyAllForm` method.
    Office.context.mailbox.item.displayReplyAllForm('hello there');
    Office.context.mailbox.item.displayReplyAllForm('<b>hello there</b>');

    // Reply with an empty body.
    Office.context.mailbox.item.displayReplyAllForm({});

    // Reply with just a body.
    Office.context.mailbox.item.displayReplyAllForm(
    {
    'htmlBody' : 'hi'
    });

    // Reply with a body and a file attachment.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
            'type' : Office.MailboxEnums.AttachmentType.File,
            'name' : 'squirrel.png',
            'url' : 'http://i.imgur.com/sRgTlGR.jpg'
            }
        ]
    });

    // Reply with a body and an item attachment.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
            'type' : 'item',
            'name' : 'rand',
            'itemId' : Office.context.mailbox.item.itemId
            }
        ]
    });

    // Reply with a body, file attachment, item attachment, and a callback.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
                'type' : Office.MailboxEnums.AttachmentType.File,
                'name' : 'squirrel.png',
                'url' : 'http://i.imgur.com/sRgTlGR.jpg'
            },
            {
                'type' : 'item',
                'name' : 'rand',
                'itemId' : Office.context.mailbox.item.itemId
            }
        ],
        'callback' : function(asyncResult)
        {
            console.log(asyncResult.value);
        }
    });
Office.MessageRead#getInitializationContextAsync:member(1):
  - |-
    // Get the initialization context (if present).
    Office.context.mailbox.item.getInitializationContextAsync((asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            if (asyncResult.value.length > 0) {
                // The value is a string, parse to an object.
                const context = JSON.parse(asyncResult.value);
                // Do something with context.
            } else {
                // Empty context, treat as no context.
            }
        } else {
            // Handle the error.
        }
    });
Office.MessageRead#getRegExMatches:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    // The following example shows how to access the array of
    // matches for the regular expression rule elements `fruits`
    // and `veggies`, which are specified in the manifest.
    const allMatches = Office.context.mailbox.item.getRegExMatches();
    const fruits = allMatches.fruits;
    const veggies = allMatches.veggies;
Office.MessageRead#getRegExMatchesByName:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    const fruits = Office.context.mailbox.item.getRegExMatchesByName("fruits");
    const veggies = Office.context.mailbox.item.getRegExMatchesByName("veggies");
Office.MessageRead#getSelectedRegExMatches:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    // The following example shows how to access the array of matches for the
    // regular expression rule elements `fruits` and `veggies`, which are
    // specified in the manifest.
    const selectedMatches = Office.context.mailbox.item.getSelectedRegExMatches();
    const fruits = selectedMatches.fruits;
    const veggies = selectedMatches.veggies;
Office.MessageRead#itemId:member:
  - |-
    // The following code checks for the presence of an item
    // identifier. If the `itemId` property returns `null` or
    // `undefined`, it saves the item to the store and gets the
    // item identifier from the asynchronous result.
    // **Important**: `saveAsync` was introduced with requirement set 1.3
    // so you can't get the `itemId` in Compose mode in earlier sets.
    let itemId = Office.context.mailbox.item.itemId;
    if (itemId === null || itemId == undefined) {
        Office.context.mailbox.item.saveAsync(function(result) {
            itemId = result.value;
        });
    }
Office.MessageRead#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.item.removeHandlerAsync(Office.EventType.ItemChanged, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.OfficeThemeChangedEventArgs:interface:
  - |-
    // Adds an event handler for the OfficeThemeChanged event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.OfficeThemeChanged, officeThemeChangedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the OfficeThemeChanged event.
    function officeThemeChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const currentTheme = event.officeTheme;
        // Perform operations based on the current theme.
    }
Office.PhoneNumber:interface:
  - |-
    const item = Office.context.mailbox.item;
    // Get an array of strings that represent phone numbers in the current item's body.
    const phoneNumbers = item.getEntitiesByType(Office.MailboxEnums.EntityType.PhoneNumber);
    console.log("There are " + phoneNumbers.length + " phone numbers.")
    phoneNumbers.forEach(function (phoneNumber) {
        console.log("Phone number: " + JSON.stringify(phoneNumber.phoneString));
        console.log("Type: " + JSON.stringify(phoneNumber.type));
        console.log("Source text: " + JSON.stringify(phoneNumber.originalPhoneString));
    });
Office.Recipients#addAsync:member(1):
  - |-
    // The following example creates an array of EmailUser objects
    // and adds them to the To recipients of the message.
    const newRecipients = [
        {
            "displayName": "Allie Bellew",
            "emailAddress": "allieb@contoso.com"
        },
        {
            "displayName": "Alex Darrow",
            "emailAddress": "alexd@contoso.com"
        }
    ];

    Office.context.mailbox.item.to.addAsync(newRecipients, function(result) {
        if (result.error) {
            console.log(result.error);
        } else {
            console.log("Recipients added");
        }
    });
Office.Recipients#setAsync:member(2):
  - |-
    // The following example creates an array of EmailUser objects and
    // replaces the CC recipients of the message with the array.
    const newRecipients = [
        {
            "displayName": "Allie Bellew",
            "emailAddress": "allieb@contoso.com"
        },
        {
            "displayName": "Alex Darrow",
            "emailAddress": "alexd@contoso.com"
        }
    ];

    Office.context.mailbox.item.cc.setAsync(newRecipients, function(result) {
        if (result.error) {
            console.log(result.error);
        } else {
            console.log("Recipients overwritten");
        }
    });
Office.RecipientsChangedEventArgs:interface:
  - |-
    // Handles the OnMessageRecipientsChanged event.
    function onMessageRecipientsChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const recipientFields = event.changedRecipientFields;
        console.log(getChangedRecipientFields(recipientFields));
    }

    // Gets the recipient fields that have changed.
    function getChangedRecipientFields(recipientFields) {
        return Object.keys(recipientFields).filter((key) => recipientFields[key] === true);
    }
Office.RecipientsChangedFields:interface:
  - |-
    // Handles the OnMessageRecipientsChanged event.
    function onMessageRecipientsChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const recipientFields = event.changedRecipientFields;
        const changedFields = getChangedRecipientFields(recipientFields);

        if (changedFields.includes("to")) {
            // Perform operations based on the updated recipients in the To field.
        }
    }

    // Gets the recipient fields that have changed.
    function getChangedRecipientFields(recipientFields) {
        return Object.keys(recipientFields).filter((key) => recipientFields[key] === true);
    }
Office.RecurrenceChangedEventArgs:interface:
  - |-
    // Adds an event handler for the RecurrenceChanged event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.RecurrenceChanged, recurrenceChangedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the RecurrenceChanged event.
    function recurrenceChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const recurrence = event.recurrence;

        // Perform operations based on the updated recurrence.
    }
Office.RecurrenceProperties:interface:
  - |-
    // This example gets the Recurrence object of an appointment item.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        if (!recurrence) {
            console.log("One-time appointment or meeting");
        } else {
            console.log(JSON.stringify(recurrence));
        }
    }

    // The following example shows the results of the getAsync call that retrieves the recurrence for a series.
    // NOTE: In this example, seriesTimeObject is a placeholder for the JSON representing the
    // recurrence.seriesTime property. You should use the SeriesTime object's methods to get the
    // recurrence date and time properties.
    Recurrence = {
        "recurrenceType": "weekly",
        "recurrenceProperties": {"interval": 2, "days": ["mon","thu","fri"], "firstDayOfWeek": "sun"},
        "seriesTime": {seriesTimeObject},
        "recurrenceTimeZone": {"name": "Pacific Standard Time", "offset": -480}
    }
Office.RecurrenceTimeZone:interface:
  - |-
    // This example gets the Recurrence object of an appointment item.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        if (!recurrence) {
        //if (recurrence == null) {
            console.log("One-time appointment or meeting");
        } else {
            console.log(JSON.stringify(recurrence));
        }
    }

    // The following example shows the results of the getAsync call that retrieves the recurrence for a series.
    // NOTE: In this example, seriesTimeObject is a placeholder for the JSON representing the
    // recurrence.seriesTime property. You should use the SeriesTime object's methods to get the
    // recurrence date and time properties.
    Recurrence = {
        "recurrenceType": "weekly",
        "recurrenceProperties": {"interval": 2, "days": ["mon","thu","fri"], "firstDayOfWeek": "sun"},
        "seriesTime": {seriesTimeObject},
        "recurrenceTimeZone": {"name": "Pacific Standard Time", "offset": -480}
    }
Office.SensitivityLabelChangedEventArgs:interface:
  - |-
    // Handles a change to an item's sensitivity label.
    function onSensitivityLabelChangedHandler(event) {
        console.log(`Event: ${event.type}`);

        // Perform operations based on the event.
    }
Office.SensitivityLabelDetails:interface:
  - |-
    // Check whether the catalog of sensitivity labels is enabled on the current mailbox.
    Office.context.sensitivityLabelsCatalog.getIsEnabledAsync((asyncResult) => {
        // If the catalog is enabled, get all available sensitivity labels.
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded && asyncResult.value == true) {
            Office.context.sensitivityLabelsCatalog.getAsync((asyncResult) => {
                if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
                    const catalog = asyncResult.value;
                    console.log("Sensitivity Labels Catalog:");
                    
                    // Log the details of the available sensitivity labels to the console.
                    catalog.forEach((sensitivityLabel) => {
                        console.log(`Name: ${sensitivityLabel.name}`);
                        console.log(`ID: ${sensitivityLabel.id}`);
                        console.log(`Tooltip: ${sensitivityLabel.tooltip}`);
                        console.log(`Color: ${sensitivityLabel.color}`);
                        console.log(`Sublabels: ${JSON.stringify(sensitivityLabel.children)}`);
                    });
                } else {
                    console.log("Action failed with error: " + asyncResult.error.message);
                }
            });
        } else {
            console.log("Action failed with error: " + asyncResult.error.message);
        }
    });
Office.SeriesTime#getDuration:member(1):
  - |-
    // This example gets the duration of a usual instance in a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const duration = recurrence.seriesTime.getDuration();
    }
Office.SeriesTime#getEndDate:member(1):
  - |-
    // This example gets the end date of a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const endDate = recurrence.seriesTime.getEndDate();
    }
Office.SeriesTime#getEndTime:member(1):
  - |-
    // This example gets the end time of a usual instance in a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const endDate = recurrence.seriesTime.getEndTime();
    }
Office.SeriesTime#getStartDate:member(1):
  - |-
    // This example gets the start date of a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const endDate = recurrence.seriesTime.getStartDate();
    }
Office.SeriesTime#getStartTime:member(1):
  - |-
    // This example gets the start time of a usual
    // instance in a recurring appointment series.
    const seriesTimeObject = new SeriesTime();
    seriesTimeObject.setDuration(120);
Office.SeriesTime#setDuration:member(1):
  - |-
    // This example sets the duration of each appointment
    // in a recurring series to 2 hours.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const endDate = recurrence.seriesTime.getStartTime();
    }
Office.SeriesTime#setEndDate:member(1):
  - |-
    // This example sets the end date of a recurring
    // appointment series to November 2, 2017.
    const seriesTimeObject = new SeriesTime();
    seriesTimeObject.setEndDate(2017, 10, 2);
Office.SeriesTime#setEndDate:member(2):
  - |-
    // This example sets the end date of a
    // recurring appointment series to November 2, 2017
    // using ISO 8601 date standard.
    const seriesTimeObject = new SeriesTime()
    seriesTimeObject.setEndDate("2017-11-02");
Office.SeriesTime#setStartDate:member(1):
  - |-
    // This example sets the start date of a recurring
    // appointment series to November 2, 2017.
    const seriesTimeObject = new SeriesTime();
    seriesTimeObject.setStartDate(2017, 10, 2);
Office.SeriesTime#setStartDate:member(2):
  - |-
    // This example sets the start date of a recurring
    // appointment series to November 2, 2017
    // using ISO 8601 date standard.
    const seriesTimeObject = new SeriesTime()
    seriesTimeObject.setStartDate("2017-11-02");
Office.SeriesTime#setStartTime:member(1):
  - |-
    // This example sets the start time of each instance
    // of a recurring appointment series to 1:30 PM.
    const seriesTimeObject = new SeriesTime();
    seriesTimeObject.setStartTime(13, 30);

    // This example sets the start time of each instance
    // of a recurring appointment series to 11:30 AM.
    seriesTimeObject.setStartTime(11, 30);
Office.SeriesTime#setStartTime:member(2):
  - |-
    // This example sets the start time of each instance
    // of a recurring appointment series to 11:30 PM.
    const seriesTimeObject = new SeriesTime()
    seriesTimeObject.setStartTime("T23:30:00");
Office.SmartAlertsEventCompletedOptions:interface:
  - |-
    // The following example checks whether a location is specified in an appointment before it's sent.
    function onAppointmentSendHandler(event) {
        Office.context.mailbox.item.location.getAsync({ asyncContext: event }, asyncResult => {
            const event = asyncResult.asyncContext;
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(asyncResult.error.message);
                // If the add-in is unable to retrieve the appointment's location, the appointment isn't sent.
                event.completed({ allowEvent: false, errorMessage: "Failed to get the appointment's location." });
                return;
            }

            if (asyncResult.value === "") {
                // If no location is specified, the appointment isn't sent and the user is alerted to include a location.
                event.completed(
                    {
                        allowEvent: false,
                        cancelLabel: "Add a location",
                        commandId: "msgComposeOpenPaneButton",
                        contextData: JSON.stringify({ a: "aValue", b: "bValue" }),
                        errorMessage: "Don't forget to add a meeting location.",
                        errorMessageMarkdown: `
                            Don't forget to add a meeting location.\n\n
                            **Tip**: For a list of locations,
                            see [Meeting Locations]("https://www.contoso.com/meeting-locations).`,
                        sendModeOverride: Office.MailboxEnums.SendModeOverride.PromptUser
                    }
                );
            } else {
                // If a location is specified, the appointment is sent.
                event.completed({ allowEvent: true });
            }
        });
    }
Office.SpamReportingEventArgs:interface:
  - |-
    // This example handles a SpamReporting event to process a reported spam or phishing message.
    function onSpamReport(event) {
        if (event.type === "SpamReporting") {
            const reportedOptions = event.options;
            const additionalInfo = event.freeText;

            // Run additional processing operations here.

            // Signal that the event has completed processing.
            event.completed({
                moveItemTo: Office.MailboxEnums.MoveSpamItemTo.CustomFolder,
                folderName: "Reported Messages",
                onErrorDeleteItem: true,
                showPostProcessingDialog: {
                    title: "Contoso Spam Reporting",
                    description: "Thank you for reporting this message."
                }
            });
        }
    }
Office.SpamReportingEventCompletedOptions:interface:
  - |-
    // The following example handles a SpamReporting event to process a reported spam or phishing message.
    function onSpamReport(event) {
        // Gets the Base64-encoded EML format of a reported message.
        Office.context.mailbox.item.getAsFileAsync({ asyncContext: event }, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(`Error encountered during message processing: ${asyncResult.error.message}`);
                return;
            }

            // Run additional processing operations here.

            /**
            * Signals that the spam-reporting event has completed processing.
            * It then moves the reported message to a custom mailbox folder named "Reported Messages"
            * and shows a post-processing dialog to the user.
            * If an error occurs while the message is being processed, the `onErrorDeleteItem`
            * property determines whether the message will be deleted.
            */
            const event = asyncResult.asyncContext;
            event.completed({
                moveItemTo: Office.MailboxEnums.MoveSpamItemTo.CustomFolder,
                folderName: "Reported Messages",
                onErrorDeleteItem: true,
                showPostProcessingDialog: {
                    title: "Contoso Spam Reporting",
                    description: "Thank you for reporting this message.",
                },
            });
        });
    }
Office.SpamReportingEventCompletedOptions#postProcessingAction:member:
  - |-
    // The following example handles a SpamReporting event to process a reported spam or phishing message.
    function onSpamReport(event) {
        // Gets the Base64-encoded EML format of a reported message.
        Office.context.mailbox.item.getAsFileAsync({ asyncContext: event }, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(`Error encountered during message processing: ${asyncResult.error.message}`);
                return;
            }

            // Run additional processing operations here.

            /**
            * Signals that the spam-reporting event has completed processing.
            * It then moves the reported message to the Junk Email folder of the mailbox and shows a
            * post-processing dialog to the user.
            */
            const event = asyncResult.asyncContext;
            event.completed({
                postProcessingAction: "moveToSpamFolder",
                showPostProcessingDialog: {
                    title: "Contoso Spam Reporting",
                    description: "Thank you for reporting this message.",
                },
            });
        });
    }
Office.Subject#getAsync:member(2):
  - |-
    Office.context.mailbox.item.subject.getAsync(callback);

    function callback(asyncResult) {
        const subject = asyncResult.value;
    }
Office.Subject#setAsync:member(1):
  - |-
    Office.context.mailbox.item.subject.setAsync("New subject!", function (asyncResult) {
        if (asyncResult.status === "failed") {
            console.log("Action failed with error: " + asyncResult.error.message);
        }
    });
Office.TaskSuggestion:interface:
  - |-
    const item = Office.context.mailbox.item;
    // Get an array of strings that represent task suggestions in the current item's body.
    const taskSuggestions = item.getEntitiesByType(Office.MailboxEnums.EntityType.TaskSuggestion);
    console.log("There are " + taskSuggestions.length + " task suggestions.")
    taskSuggestions.forEach(function (taskSuggestion) {
        console.log("Assignees: " + JSON.stringify(taskSuggestion.assignees));
        console.log("Task: " + JSON.stringify(taskSuggestion.taskString));
    });
Office.Time#setAsync:member(1):
  - |-
    const startTime = new Date("3/14/2015");
    const options = {
        // Pass information that can be used in the callback.
        asyncContext: {verb: "Set"}
    };
    Office.context.mailbox.item.start.setAsync(startTime, options, function(result) {
        if (result.error) {
            console.debug(result.error);
        } else {
            // Access the asyncContext that was passed to the setAsync method.
            console.debug("Start Time " + result.asyncContext.verb);
        }
    });
Office.UserProfile#accountType:member:
  - |-
    console.log(Office.context.mailbox.userProfile.accountType);
Office.UserProfile#displayName:member:
  - |-
    // Example: Allie Bellew
    console.log(Office.context.mailbox.userProfile.displayName);
Office.UserProfile#emailAddress:member:
  - |-
    // Example: allieb@contoso.com
    console.log(Office.context.mailbox.userProfile.emailAddress);
Office.UserProfile#timeZone:member:
  - |-
    // Example: Pacific Standard Time
    console.log(Office.context.mailbox.userProfile.timeZone);
