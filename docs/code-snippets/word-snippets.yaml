Word.Body#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to clear the contents of the body.
        body.clear();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Cleared the body contents.');
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });

    // The Silly stories add-in sample shows how the 
    // clear method can be used to clear the contents of a document.
    // https://aka.ms/sillystorywordaddin
Word.Body#font:member:
  - |-
    // Get the style and the font size, font name, and font color properties on the body object.
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to load font and style information for the document body.
        context.load(body, 'font/size, font/name, font/color, style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            // Show the results of the load method. Here we show the
            // property values on the body object.
            var results = 'Font size: ' + body.font.size +
                          '; Font name: ' + body.font.name +
                          '; Font color: ' + body.font.color +
                          '; Body style: ' + body.style;
    
            console.log(results);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to get the HTML contents of the body.
        var bodyHTML = body.getHtml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log("Body HTML contents: " + bodyHTML.value);
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to get the OOXML contents of the body.
        var bodyOOXML = body.getOoxml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log("Body OOXML contents: " + bodyOOXML.value);
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#insertBreak:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (ctx) {
    
        // Create a proxy object for the document body.
        var body = ctx.document.body;
    
        // Queue a command to insert a page break at the start of the document body.
        body.insertBreak(Word.BreakType.page, Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            console.log('Added a page break at the start of the document body.');
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#insertContentControl:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to wrap the body in a content control.
        body.insertContentControl();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Wrapped the body in a content control.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#insertFileFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to insert base64 encoded .docx at the beginning of the content body.
        // You will need to implement getBase64() to pass in a string of a base64 encoded docx file.
        body.insertFileFromBase64(getBase64(), Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Added base64 encoded text to the beginning of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to insert HTML in to the beginning of the body.
        body.insertHtml(
            '<strong>This is text inserted with body.insertHtml()</strong>', Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('HTML added to the beginning of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#insertInlinePictureFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to insert OOXML in to the beginning of the body.
        body.insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('OOXML added to the beginning of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });

    // Read "Create better add-ins for Word with Office Open XML" for guidance on working with OOXML.
    // https://docs.microsoft.com/office/dev/add-ins/word/create-better-add-ins-for-word-with-office-open-xml

    // The Word-Add-in-DocumentAssembly sample shows how you can use this API to assemble a document.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.Body#insertParagraph:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to insert the paragraph at the end of the document body.
        body.insertParagraph('Content of a new paragraph', Word.InsertLocation.end);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Paragraph added at the end of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });

    // The Word-Add-in-DocumentAssembly sample shows how you can use the insertParagraph method to assemble a document.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.Body#insertText:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to insert text in to the beginning of the body.
        body.insertText('This is text inserted with body.insertText()', Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Text added to the beginning of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#search:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to search the document.
        var searchResults = context.document.body.search('video', {matchCase: false});
    
        // Queue a command to load the results.
        context.load(searchResults, 'text, font');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            var results = 'Found count: ' + searchResults.items.length +
                          '; we highlighted the results.';
    
            // Queue a command to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
              searchResults.items[i].font.color = '#FF0000'    // Change color to Red
              searchResults.items[i].font.highlightColor = '#FFFF00';
              searchResults.items[i].font.bold = true;
            }
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log(results);
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });

    // The Word-Add-in-DocumentAssembly sample provides another example of how to search a document.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.Body#select:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to select the document body. The Word UI will
        // move to the selected document body.
        body.select();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Selected the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body#text:member:
  - |-
    // Get the text property on the body object
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to load the text in document body.
        context.load(body, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log("Body contents: " + body.text);
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the content controls collection.
        contentControls.load('text');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            if (contentControls.items.length === 0) {
                console.log("There isn't a content control in this document.");
            } else {
                
                // Queue a command to clear the contents of the first content control.
                contentControls.items[0].clear();
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync().then(function () {
                    console.log('Content control cleared of contents.');
                });      
            }
                
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
    
Word.ContentControl#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the content controls collection.
        contentControls.load('text');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            if (contentControls.items.length === 0) {
                console.log("There isn't a content control in this document.");
            } else {
                
                // Queue a command to delete the first content control. The
                // contents will remain in the document.
                contentControls.items[0].delete(true);
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync().then(function () {
                    console.log('Content control cleared of contents.');
                });      
            }
                
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection that contains a specific tag.
        var contentControlsWithTag = context.document.contentControls.getByTag('Customer-Address');
        
        // Queue a command to load the tag property for all of content controls. 
        context.load(contentControlsWithTag, 'tag');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControlsWithTag.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to get the HTML contents of the first content control.
                var html = contentControlsWithTag.items[0].getHtml();
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Content control HTML: ' + html.value);
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to get the OOXML contents of the first content control.
                var ooxml = contentControls.items[0].getOoxml();
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Content control OOXML: ' + ooxml.value);
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#insertBreak:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of content controls. 
        context.load(contentControls, 'id');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion. We now will have 
        // access to the content control collection.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to insert a page break after the first content control. 
                contentControls.items[0].insertBreak('page', "After");
                
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion. 
                return context.sync()
                    .then(function () {
                        console.log('Inserted a page break after the first content control.');    
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#insertHtml:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to put HTML into the contents of the first content control.
                contentControls.items[0].insertHtml(
                    '<strong>HTML content inserted into the content control.</strong>',
                    'Start');
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Inserted HTML in the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#insertOoxml:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to put OOXML into the contents of the first content control.
                contentControls.items[0].insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", "End");
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Inserted OOXML in the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });

    // Read "Create better add-ins for Word with Office Open XML" for guidance on working with OOXML.
    // https://docs.microsoft.com/office/dev/add-ins/word/create-better-add-ins-for-word-with-office-open-xml
Word.ContentControl#insertParagraph:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to insert a paragraph after the first content control. 
                contentControls.items[0].insertParagraph('Text of the inserted paragraph.', 'After');
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Inserted a paragraph after the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#insertText:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to replace text in the first content control. 
                contentControls.items[0].insertText('Replaced text in the first content control.', 'Replace');
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Replaced text in the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });

    // The Silly stories add-in sample shows how to use the insertText method.
    // https://aka.ms/sillystorywordaddin
Word.ContentControl#tag:member:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy range object for the current selection.
        var range = context.document.getSelection();
        
        // Queue a command to create the content control.
        var myContentControl = range.insertContentControl();
        myContentControl.tag = 'Customer-Address';
        myContentControl.title = ' has t';
        myContentControl.style = 'Heading 2';
        myContentControl.insertText('One Microsoft Way, Redmond, WA 98052', 'Replace');
        myContentControl.cannotEdit = true;
        
        // Queue a command to load the id property for the content control you created.
        context.load(myContentControl, 'id');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Created content control with id: ' + myContentControl.id);
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#load:member(1):
  - |-
    // Load all of the content control properties
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to load the properties on the first content control. 
                contentControls.items[0].load(  'appearance,' +
                                                'cannotDelete,' +
                                                'cannotEdit,' +
                                                'id,' +
                                                'placeHolderText,' +
                                                'removeWhenEdited,' +
                                                'title,' +
                                                'text,' +
                                                'type,' +
                                                'style,' +
                                                'tag,' +
                                                'font/size,' +
                                                'font/name,' +
                                                'font/color');             
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Property values of the first content control:' + 
                            '   ----- appearance: ' + contentControls.items[0].appearance + 
                            '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                            '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                            '   ----- color: ' + contentControls.items[0].color +
                            '   ----- id: ' + contentControls.items[0].id +
                            '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                            '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                            '   ----- title: ' + contentControls.items[0].title +
                            '   ----- text: ' + contentControls.items[0].text +
                            '   ----- type: ' + contentControls.items[0].type +
                            '   ----- style: ' + contentControls.items[0].style +
                            '   ----- tag: ' + contentControls.items[0].tag +
                            '   ----- font size: ' + contentControls.items[0].font.size +
                            '   ----- font name: ' + contentControls.items[0].font.name +
                            '   ----- font color: ' + contentControls.items[0].font.color);
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl#search:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to select the first content control.
                contentControls.items[0].select();
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Selected the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection#getById:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the content control that contains a specific id.
        var contentControl = context.document.contentControls.getById(30086310);
    
        // Queue a command to load the text property for a content control.
        context.load(contentControl, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The content control with that Id has been found in this document.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the content control that contains a specific id.
        var contentControl = context.document.contentControls.getByIdOrNullObject(30086310);
    
        // Queue a command to load the text property for a content control.
        context.load(contentControl, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControl.isNullObject) {
                console.log('There is no content control with that ID.')
            } else {
                console.log('The content control with that ID has been found in this document.');
            }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection#getByIdOrNullObject:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the content control that contains a specific id.
        var contentControl = context.document.contentControls.getByIdOrNullObject(30086310);
    
        // Queue a command to load the text property for a content control.
        context.load(contentControl, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControl.isNullObject) {
                console.log('There is no content control with that ID.')
            } else {
                console.log('The content control with that ID has been found in this document.');
            }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection#getByTag:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the content controls collection that contains a specific tag.
        var contentControlsWithTag = context.document.contentControls.getByTag('Customer-Address');
    
        // Queue a command to load the text property for all of content controls with a specific tag.
        context.load(contentControlsWithTag, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControlsWithTag.items.length === 0) {
                console.log("There isn't a content control with a tag of Customer-Address in this document.");
            } else {
                console.log(
                    'The first content control with the tag of Customer-Address has this text: ' + 
                    contentControlsWithTag.items[0].text);
            }
    
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });

    // The Word-Add-in-DocumentAssembly sample has another example of using the getByTag method.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.ContentControlCollection#getByTitle:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the content controls collection that contains a specific title.
        var contentControlsWithTitle = context.document.contentControls.getByTitle('Enter Customer Address Here');
    
        // Queue a command to load the text property for all of content controls with a specific title.
        context.load(contentControlsWithTitle, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControlsWithTitle.items.length === 0) {
                console.log(
                    "There isn't a content control with a title of 'Enter Customer Address Here' in this document.");
            } else {
                console.log(
                    "The first content control with the title of 'Enter Customer Address Here' has this text: " + 
                    contentControlsWithTitle.items[0].text);
            }
    
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });

    // The Word-Add-in-DocumentAssembly sample has another example of using the getByTitle method.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.ContentControlCollection#getFirst:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the first content control in the document.
        var contentControl = context.document.contentControls.getFirstOrNullObject();
    
        // Queue a command to load the text property for a content control.
        context.load(contentControl, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControl.isNullObject) {
                console.log('There are no content controls in this document.')
            } else {
                console.log('The first content control has been found in this document.');
            }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection#load:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
    
        // Queue a command to load the id property for all of the content controls.
        context.load(contentControls, 'id');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to load the properties on the first content control.
                contentControls.items[0].load(  'appearance,' +
                                                'cannotDelete,' +
                                                'cannotEdit,' +
                                                'color,' +
                                                'id,' +
                                                'placeHolderText,' +
                                                'removeWhenEdited,' +
                                                'title,' +
                                                'text,' +
                                                'type,' +
                                                'style,' +
                                                'tag,' +
                                                'font/size,' +
                                                'font/name,' +
                                                'font/color');
    
                // Synchronize the document state by executing the queued commands,
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Property values of the first content control:' +
                            '   ----- appearance: ' + contentControls.items[0].appearance +
                            '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                            '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                            '   ----- color: ' + contentControls.items[0].color +
                            '   ----- id: ' + contentControls.items[0].id +
                            '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                            '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                            '   ----- title: ' + contentControls.items[0].title +
                            '   ----- text: ' + contentControls.items[0].text +
                            '   ----- type: ' + contentControls.items[0].type +
                            '   ----- style: ' + contentControls.items[0].style +
                            '   ----- tag: ' + contentControls.items[0].tag +
                            '   ----- font size: ' + contentControls.items[0].font.size +
                            '   ----- font name: ' + contentControls.items[0].font.name +
                            '   ----- font color: ' + contentControls.items[0].font.color);
                });
            }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });

    // The Silly stories add-in sample shows how the load method is used
    // to load the content control collection with the tag and title properties.
    // https://aka.ms/sillystorywordaddin
Word.Document#getSelection:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        var textSample = 'This is an example of the insert text method. This is a method ' + 
            'which allows users to insert text into a selection. It can insert text into a ' +
            'relative location or it can overwrite the current selection. Since the ' +
            'getSelection method returns a range object, look up the range object documentation ' +
            'for everything you can do with a selection.';
        
        // Create a range proxy object for the current selection.
        var range = context.document.getSelection();
        
        // Queue a command to insert text at the end of the selection.
        range.insertText(textSample, Word.InsertLocation.end);
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Inserted the text at the end of the selection.');
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Document#load:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the document.
        var thisDocument = context.document;
        
        // Queue a command to load content control properties.
        context.load(thisDocument, 'contentControls/id, contentControls/text, contentControls/tag');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (thisDocument.contentControls.items.length !== 0) {
                for (var i = 0; i < thisDocument.contentControls.items.length; i++) {
                    console.log(thisDocument.contentControls.items[i].id);
                    console.log(thisDocument.contentControls.items[i].text);
                    console.log(thisDocument.contentControls.items[i].tag);
                }
            } else {
                console.log('No content controls in this document.');
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Document#save:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the document.
        var thisDocument = context.document;
    
        // Queue a command to load the document save state (on the saved property).
        context.load(thisDocument, 'saved');    
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            if (thisDocument.saved === false) {
                // Queue a command to save this document.
                thisDocument.save();
                
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync().then(function () {
                    console.log('Saved the document');
                });
            } else {
                console.log('The document has not changed since the last save.');
            }
        });  
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OfficeExtension.Error:class:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the document body.
        var body = context.document.body;
    
        // Queue a command to insert text in to the beginning of the body.
        // This will cause an OfficeExtension.Error.
        body.insertText(0);
    
        // Synchronize the document state by executing the queued-up commands,
        // and return a promise to indicate task completion.
        return context.sync();
    })
    .catch(function (error) {
        if (error instanceof OfficeExtension.Error) {
            console.log('Error code and message: ' + error.toString());
        }
    });
OfficeExtension.Error#traceMessages:member:
  - |-
    // The following example shows how you can instrument a batch of commands
    // to determine where an error occurred. The first batch successfully
    // inserts the first two paragraphs into the document and cause no errors.
    // The second batch successfully inserts the third and fourth paragraphs
    // but fails in the call to insert the fifth paragraph. All other commands
    // after the failed command in the batch are not executed, including the
    // command that adds the fifth trace message. In this case, the error
    // occurred after the fourth paragraph was inserted, and before adding the
    // fifth trace message.

    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a command to insert the paragraph at the end of the document body.
        // Start a batch of commands.
        body.insertParagraph('1st paragraph', Word.InsertLocation.end);
        // Queue a command for instrumenting this part of the batch.
        context.trace('1st paragraph successful');

        body.insertParagraph('2nd paragraph', Word.InsertLocation.end);
        context.trace('2nd paragraph successful');

        // Synchronize the document state by executing the queued-up commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            // Queue a command to insert the paragraph at the end of the document body.
            // Start a new batch of commands.
            body.insertParagraph('3rd paragraph', Word.InsertLocation.end);
            context.trace('3rd paragraph successful');

            body.insertParagraph('4th paragraph', Word.InsertLocation.end);
            context.trace('4th paragraph successful');

            // This command will cause an error. The trace messages in the queue up to
            // this point will be available via Error.traceMessages.
            body.insertParagraph(0, '5th paragraph', Word.InsertLocation.end);
            // Queue a command for instrumenting this part of the batch.
            // This trace message will not be set on Error.traceMessages.
            context.trace('5th paragraph successful');
        }).then(context.sync);
    })
    .catch(function (error) {
        if (error instanceof OfficeExtension.Error) {
            console.log('Trace messages: ' + error.traceMessages);
        }
    });

    // Output: "Trace messages: 3rd paragraph successful,4th paragraph successful"
Word.Font#load:member(1):
  - |-
    // Change the font name
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();
    
        // Queue a command to change the current selection's font name.
        selection.font.name = 'Arial';
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The font name has changed.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Change the font color
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();
    
        // Queue a command to change the font color of the current selection.
        selection.font.color = 'blue';
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The font color of the selection has been changed.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Change the font size
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();
    
        // Queue a command to change the current selection's font size.
        selection.font.size = 20;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The font size has changed.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Highlight selected text
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();
    
        // Queue a command to highlight the current selection.
        selection.font.highlightColor = '#FFFF00'; // Yellow
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The selection has been highlighted.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Bold format text
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();
    
        // Queue a command to make the current selection bold.
        selection.font.bold = true;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The selection is now bold.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Underline format text
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();
    
        // Queue a command to underline the current selection.
        selection.font.underline = Word.UnderlineType.single;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The selection now has an underline style.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Strike format text
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();
    
        // Queue a command to strikethrough the font of the current selection.
        selection.font.strikeThrough = true;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The selection now has a strikethrough.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.InlinePicture#getNext:member(1):
  - |-
    // To use this snippet, add an inline picture to the document and assign it an alt text title.
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the first inline picture.
        var firstPicture = context.document.body.inlinePictures.getFirstOrNullObject();
    
        // Queue a command to load the alternative text title of the picture.
        context.load(firstPicture, 'altTextTitle');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (firstPicture.isNullObject) {
                console.log('There are no inline pictures in this document.')
            } else {
                console.log(firstPicture.altTextTitle);
            }
        });   
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.InlinePicture#getNextOrNullObject:member(1):
  - |-
    // To use this snippet, add an inline picture to the document and assign it an alt text title.
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the first inline picture.
        var firstPicture = context.document.body.inlinePictures.getFirstOrNullObject();
    
        // Queue a command to load the alternative text title of the picture.
        context.load(firstPicture, 'altTextTitle');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (firstPicture.isNullObject) {
                console.log('There are no inline pictures in this document.')
            } else {
                console.log(firstPicture.altTextTitle);
            }
        });   
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        context.load(paragraphs, 'style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to clear the contents of the first paragraph.
            paragraphs.items[0].clear();
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Cleared the contents of the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the text property for all of the paragraphs.
        context.load(paragraphs, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to delete the first paragraph.
            paragraphs.items[0].delete();
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Deleted the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        context.load(paragraphs, 'style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a a set of commands to get the HTML of the first paragraph.
            var html = paragraphs.items[0].getHtml();
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Paragraph HTML: ' + html.value);
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        context.load(paragraphs, {select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a a set of commands to get the OOXML of the first paragraph.
            var ooxml = paragraphs.items[0].getOoxml();
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Paragraph OOXML: ' + ooxml.value);
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#getPreviousOrNullObject:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the text property for all of the paragraphs.
        context.load(paragraphs, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue commands to create a proxy object for the next-to-last paragraph.
            var indexOfLastParagraph = paragraphs.items.length - 1;
            var precedingParagraph = paragraphs.items[indexOfLastParagraph].getPreviousOrNullObject();
    
            // Queue a command to load the text of the preceding paragraph.
            context.load(precedingParagraph, 'text');
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                if (precedingParagraph.isNullObject) {
                    console.log('There are no paragraphs before the current one.');
                } else {
                    console.log('The preceding paragraph is: ' + precedingParagraph.text);
                }
            });
        });
    }).catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#insertBreak:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];
    
            // Queue a command to insert a page break after the first paragraph.
            paragraph.insertBreak('page', 'After');
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Inserted a page break after the paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#insertContentControl:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];
    
            // Queue a command to wrap the first paragraph in a rich text content control.
            paragraph.insertContentControl();
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Wrapped the first paragraph in a content control.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];
    
            // Queue a command to insert HTML content at the end of the first paragraph.
            paragraph.insertHtml('<strong>Inserted HTML.</strong>', Word.InsertLocation.end);
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Inserted HTML content at the end of the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
    
Word.Paragraph#insertInlinePictureFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        context.load(paragraphs, 'style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];
    
            var b64encodedImg = "iVBORw0KGgoAAAANSUhEUgAAAB4AAAANCAIAAAAxEEnAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACFSURBVDhPtY1BEoQwDMP6/0+XgIMTBAeYoTqso9Rkx1zG+tNj1H94jgGzeNSjteO5vtQQuG2seO0av8LzGbe3anzRoJ4ybm/VeKEerAEbAUpW4aWQCmrGFWykRzGBCnYy2ha3oAIq2MloW9yCCqhgJ6NtcQsqoIKdjLbFLaiACnYyf2fODbrjZcXfr2F4AAAAAElFTkSuQmCC";
    
            // Queue a command to insert a base64 encoded image at the beginning of the first paragraph.
            paragraph.insertInlinePictureFromBase64(b64encodedImg, Word.InsertLocation.start);
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Added an image to the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#insertParagraph:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];
    
            // Queue a command to insert the paragraph after the current paragraph.
            paragraph.insertParagraph('Content of a new paragraph', Word.InsertLocation.after);
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Inserted a new paragraph at the end of the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#insertText:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];
    
            // Queue a command to insert text into the end of the paragraph.
            paragraph.insertText('New text inserted into the paragraph.', Word.InsertLocation.end);
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Inserted text at the end of the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph#select:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        context.load(paragraphs, 'style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a command to get the last paragraph a create a
            // proxy paragraph object.
            var paragraph = paragraphs.items[paragraphs.items.length - 1];
    
            // Queue a command to select the paragraph. The Word UI will
            // move to the selected paragraph.
            paragraph.select();
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Selected the last paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ParagraphCollection#load:member(1):
  - |-
    // This example shows how to get the paragraphs in the Word document
    // along with their text and font size properties.
    // 
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a command to load the text and font properties.
        // It is best practice to always specify the property set. Otherwise, all properties are
        // returned in on the object.
        context.load(paragraphs, 'text, font/size');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

        // Insert code that works with the paragraphs loaded by context.load().
        })
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to clear the contents of the proxy range object.
        range.clear();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Cleared the selection (range object)');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to delete the range object.
        range.delete();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Deleted the selection (range object)');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to get the HTML of the current selection.
        var html = range.getHtml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The HTML read from the document was: ' + html.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to get the OOXML of the current selection.
        var ooxml = range.getOoxml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The OOXML read from the document was:  ' + ooxml.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#insertBreak:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to insert a page break after the selected text.
        range.insertBreak('page', 'After');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Inserted a page break after the selected text.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#insertContentControl:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to insert a content control around the selected text,
        // and create a proxy content control object. We'll update the properties
        // on the content control.
        var myContentControl = range.insertContentControl();
        myContentControl.tag = "Customer-Address";
        myContentControl.title = "Enter Customer Address Here:";
        myContentControl.style = "Normal";
        myContentControl.insertText("One Microsoft Way, Redmond, WA 98052", 'Replace');
        myContentControl.cannotEdit = true;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Wrapped a content control around the selected text.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#insertFileFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to insert base64 encoded .docx at the beginning of the range.
        // You'll need to implement getBase64() to make this work.
        range.insertFileFromBase64(getBase64(), Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Added base64 encoded text to the beginning of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to insert HTML in to the beginning of the range.
        range.insertHtml('<strong>This is text inserted with range.insertHtml()</strong>', Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('HTML added to the beginning of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#insertOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to insert OOXML in to the beginning of the range.
        range.insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('OOXML added to the beginning of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
    
    // Read "Create better add-ins for Word with Office Open XML" for guidance on working with OOXML.
    // https://docs.microsoft.com/office/dev/add-ins/word/create-better-add-ins-for-word-with-office-open-xml
Word.Range#insertParagraph:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to insert the paragraph after the range.
        range.insertParagraph('Content of a new paragraph', Word.InsertLocation.after);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Paragraph added to the end of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#insertText:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to insert the paragraph at the end of the range.
        range.insertText('New text inserted into the range.', Word.InsertLocation.end);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Text added to the end of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range#select:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();
    
        // Queue a command to insert HTML in to the beginning of the range.
        range.insertHtml('<strong>This is text inserted with range.insertHtml()</strong>', Word.InsertLocation.start);
    
        // Queue a command to select the HTML that was inserted.
        range.select();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Selected the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.RequestContext:class:
  - |-
    // The following example shows how the request context is used to load the text property on a paragraph collection.
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the text property for all of the paragraphs.
        context.load(paragraphs, 'text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            // Queue a a set of commands to get the HTML of the first paragraph.
            var html = paragraphs.items[0].getHtml();
    
            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Paragraph HTML: ' + html.value);
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
    // Note: You must call load() after adding tracked objects.    
  - |-
    // The following example shows the sync method used twice: 
    //   1) load the content controls collection with the text property for each content control, and
    //   2) clearing the contents of the first content control in the collection.
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
    
        // Queue a command to load the content controls collection.
        contentControls.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
    
            if (contentControls.items.length === 0) {
                console.log("There isn't a content control in this document.");
            } else {
    
                // Queue a command to clear the contents of the first content control.
                contentControls.items[0].clear();
                // Synchronize the document state by executing the queued commands,
                // and return a promise to indicate task completion.
                return context.sync().then(function () {
                    console.log('Content control cleared of contents.');
                });
            }
    
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.SearchOptions#load:member(1):
  - |-
    // Ignore punctuation search
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Queue a command to search the document and ignore punctuation.
        var searchResults = context.document.body.search('video you', {ignorePunct: true});
    
        // Queue a command to load the search results and get the font property values.
        context.load(searchResults, 'font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Found count: ' + searchResults.items.length);
    
            // Queue a set of commands to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
                searchResults.items[i].font.color = 'purple';
                searchResults.items[i].font.highlightColor = '#FFFF00'; //Yellow
                searchResults.items[i].font.bold = true;
            }
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync();
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Search based on a prefix
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Queue a command to search the document based on a prefix.
        var searchResults = context.document.body.search('vid', {matchPrefix: true});
    
        // Queue a command to load the search results and get the font property values.
        context.load(searchResults, 'font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Found count: ' + searchResults.items.length);
    
            // Queue a set of commands to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
                searchResults.items[i].font.color = 'purple';
                searchResults.items[i].font.highlightColor = '#FFFF00'; //Yellow
                searchResults.items[i].font.bold = true;
            }
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync();
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Search based on a suffix
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue a command to search the document for any string of characters after 'ly'.
        var searchResults = context.document.body.search('ly', {matchSuffix: true});
    
        // Queue a command to load the search results and get the font property values.
        context.load(searchResults, 'font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Found count: ' + searchResults.items.length);
    
            // Queue a set of commands to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
                searchResults.items[i].font.color = 'orange';
                searchResults.items[i].font.highlightColor = 'black';
                searchResults.items[i].font.bold = true;
            }
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync();
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Search using a wildcard
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Queue a command to search the document with a wildcard
        // for any string of characters that starts with 'to' and ends with 'n'.
        var searchResults = context.document.body.search('to*n', {matchWildCards: true});
    
        // Queue a command to load the search results and get the font property values.
        context.load(searchResults, 'font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Found count: ' + searchResults.items.length);
    
            // Queue a set of commands to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
                searchResults.items[i].font.color = 'purple';
                searchResults.items[i].font.highlightColor = 'pink';
                searchResults.items[i].font.bold = true;
            }
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync();
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Section#getFooter:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy sectionsCollection object.
        var mySections = context.document.sections;
        
        // Queue a command to load the sections.
        context.load(mySections, 'body/style');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            // Create a proxy object the primary footer of the first section. 
            // Note that the footer is a body object.
            var myFooter = mySections.items[0].getFooter("primary");
            
            // Queue a command to insert text at the end of the footer.
            myFooter.insertText("This is a footer.", Word.InsertLocation.end);
            
            // Queue a command to wrap the header in a content control.
            myFooter.insertContentControl();
                                  
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log("Added a footer to the first section.");
            });                    
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Section#getHeader:member(2):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy sectionsCollection object.
        var mySections = context.document.sections;
        
        // Queue a command to load the sections.
        context.load(mySections, 'body/style');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            // Create a proxy object the primary header of the first section. 
            // Note that the header is a body object.
            var myHeader = mySections.items[0].getHeader("primary");
            
            // Queue a command to insert text at the end of the header.
            myHeader.insertText("This is a header.", Word.InsertLocation.end);
            
            // Queue a command to wrap the header in a content control.
            myHeader.insertContentControl();
                                  
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log("Added a header to the first section.");
            });                    
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Setting#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue commands add a setting.
        var settings = context.document.settings;
        var startMonth = settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        var count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log(count.value);
    
            // Queue a command to delete the setting.
            startMonth.delete();
    
            // Queue a command to get the new count of settings.
            count = settings.getCount();
        })
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        .then(context.sync)
        .then(function () {
            console.log(count.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.SettingCollection#deleteAll:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue commands add a setting.
        var settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        var count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log(count.value);
    
            // Queue a command to delete all settings.
            settings.deleteAll();
    
            // Queue a command to get the new count of settings.
            count = settings.getCount();
        })
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        .then(context.sync)
        .then(function () {
            console.log(count.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.SettingCollection#getCount:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue commands add a setting.
        var settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        var count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log(count.value);
    
            // Queue a command to delete all settings.
            settings.deleteAll();
    
            // Queue a command to get the new count of settings.
            count = settings.getCount();
        })
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        .then(context.sync)
        .then(function () {
            console.log(count.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.SettingCollection#getItem:member(1):
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue commands add a setting.
        var settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to retrieve a setting.
        var startMonth = settings.getItem('startMonth');
    
        // Queue a command to load the setting.
        context.load(startMonth);
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log(JSON.stringify(startMonth.value));
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
    
        // Queue commands add a setting.
        var settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
        
        // Queue commands to retrieve settings.
        var startMonth = settings.getItemOrNullObject('startMonth');
        var endMonth = settings.getItemOrNullObject('endMonth');
    
        // Queue commands to load settings.
        context.load(startMonth);
        context.load(endMonth);
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
           return context.sync().then(function () {
               if (startMonth.isNullObject) {
                   console.log("No such setting.");
               }
               else {
                   console.log(JSON.stringify(startMonth.value));
               }
                if (endMonth.isNullObject) {
                   console.log("No such setting.");
               }
               else {
                   console.log(JSON.stringify(endMonth.value));
               }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
