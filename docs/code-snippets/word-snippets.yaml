Word.Application#createDocument:member(1):
  - |-
    // Update the text of the current document with the text from another document
    // passed in as a base64-encoded string.
    await Word.run(async (context) => {
        // Important: You'll need to implement getBase64() to get the base64-encoded 
        // string representation of a docx file.
        const externalDoc = context.application.createDocument(getBase64());
        await context.sync();

        const externalDocBody = externalDoc.body;
        externalDocBody.load("text");
        await context.sync();

        const externalDocBodyText = externalDocBody.text;
        const currentDocBody = context.document.body;
        currentDocBody .insertText(externalDocBodyText, WordInsertLocation.start);
        await context.sync();
    });
Word.Body#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to clear the contents of the body.
        body.clear();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
  
        console.log('Cleared the body contents.');
    });

    // The Silly stories add-in sample shows how the 
    // clear method can be used to clear the contents of a document.
    // https://aka.ms/sillystorywordaddin
Word.Body#font:member:
  - |-
    // Get the style and the font size, font name, and font color properties on the body object.
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to load font and style information for the document body.
        body.load('font/size, font/name, font/color, style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        
        // Show the results of the load method.
        // Here we show the property values on the body object.
        const results = 'Font size: ' + body.font.size +
                        '; Font name: ' + body.font.name +
                        '; Font color: ' + body.font.color +
                        '; Body style: ' + body.style;

        console.log(results);
    });
Word.Body#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to get the HTML contents of the body.
        const bodyHTML = body.getHtml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log("Body HTML contents: " + bodyHTML.value);
    });
Word.Body#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to get the OOXML contents of the body.
        const bodyOOXML = body.getOoxml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log("Body OOXML contents: " + bodyOOXML.value);
    });
Word.Body#insertBreak:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to insert a page break at the start of the document body.
        body.insertBreak(Word.BreakType.page, Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Added a page break at the start of the document body.');
    });
Word.Body#insertContentControl:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to wrap the body in a content control.
        body.insertContentControl();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Wrapped the body in a content control.');
    });
Word.Body#insertFileFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to insert base64 encoded .docx at the beginning of the content body.
        // You will need to implement getBase64() to pass in a string of a base64 encoded docx file.
        body.insertFileFromBase64(getBase64(), Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Added base64 encoded text to the beginning of the document body.');
    });
Word.Body#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to insert HTML in to the beginning of the body.
        body.insertHtml(
            '<strong>This is text inserted with body.insertHtml()</strong>', Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('HTML added to the beginning of the document body.');
    });
Word.Body#insertInlinePictureFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        const b64encodedImg = "iVBORw0KGgoAAAANSUhEUgAAAB4AAAANCAIAAAAxEEnAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACFSURBVDhPtY1BEoQwDMP6/0+XgIMTBAeYoTqso9Rkx1zG+tNj1H94jgGzeNSjteO5vtQQuG2seO0av8LzGbe3anzRoJ4ybm/VeKEerAEbAUpW4aWQCmrGFWykRzGBCnYy2ha3oAIq2MloW9yCCqhgJ6NtcQsqoIKdjLbFLaiACnYyf2fODbrjZcXfr2F4AAAAAElFTkSuQmCC";

        // Queue a command to insert a base64 encoded image at the beginning of the first paragraph.
        body.insertInlinePictureFromBase64(b64encodedImg, Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Added an image to the body.');
    });
Word.Body#insertOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to insert OOXML in to the beginning of the body.
        body.insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('OOXML added to the beginning of the document body.');
    });

    // Read "Create better add-ins for Word with Office Open XML" for guidance on working with OOXML.
    // https://learn.microsoft.com/office/dev/add-ins/word/create-better-add-ins-for-word-with-office-open-xml

    // The Word-Add-in-DocumentAssembly sample shows how you can use this API to assemble a document.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.Body#insertParagraph:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to insert the paragraph at the end of the document body.
        body.insertParagraph('Content of a new paragraph', Word.InsertLocation.end);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Paragraph added at the end of the document body.');
    });

    // The Word-Add-in-DocumentAssembly sample shows how you can use the insertParagraph method to assemble a document.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.Body#insertText:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to insert text in to the beginning of the body.
        body.insertText('This is text inserted with body.insertText()', Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Text added to the beginning of the document body.');
    });
Word.Body#select:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to select the document body.
        // The Word UI will move to the selected document body.
        body.select();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Selected the document body.');
    });
Word.Body#text:member:
  - |-
    // Get the text property on the body object
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the document body.
        const body = context.document.body;
    
        // Queue a command to load the text in document body.
        body.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log("Body contents: " + body.text);
    });
Word.ContentControl:class:
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
    
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to load the properties on the first content control.
            contentControls.items[0].load(  'appearance,' +
                                            'cannotDelete,' +
                                            'cannotEdit,' +
                                            'color,' +
                                            'id,' +
                                            'placeHolderText,' +
                                            'removeWhenEdited,' +
                                            'title,' +
                                            'text,' +
                                            'type,' +
                                            'style,' +
                                            'tag,' +
                                            'font/size,' +
                                            'font/name,' +
                                            'font/color');

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Property values of the first content control:' +
                '   ----- appearance: ' + contentControls.items[0].appearance +
                '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                '   ----- color: ' + contentControls.items[0].color +
                '   ----- id: ' + contentControls.items[0].id +
                '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                '   ----- title: ' + contentControls.items[0].title +
                '   ----- text: ' + contentControls.items[0].text +
                '   ----- type: ' + contentControls.items[0].type +
                '   ----- style: ' + contentControls.items[0].style +
                '   ----- tag: ' + contentControls.items[0].tag +
                '   ----- font size: ' + contentControls.items[0].font.size +
                '   ----- font name: ' + contentControls.items[0].font.name +
                '   ----- font color: ' + contentControls.items[0].font.color);
        }
    });
Word.ContentControl#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the content controls collection.
        contentControls.load('text');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            
        if (contentControls.items.length === 0) {
            console.log("There isn't a content control in this document.");
        } else {
            // Queue a command to clear the contents of the first content control.
            contentControls.items[0].clear();

            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Content control cleared of contents.');
        }
    });
    
Word.ContentControl#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the content controls collection.
        contentControls.load('text');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            
        if (contentControls.items.length === 0) {
            console.log("There isn't a content control in this document.");
        } else {            
            // Queue a command to delete the first content control. 
            // The contents will remain in the document.
            contentControls.items[0].delete(true);

            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Content control cleared of contents.'); 
        }
    });
Word.ContentControl#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection that contains a specific tag.
        const contentControlsWithTag = context.document.contentControls.getByTag('Customer-Address');
        
        // Queue a command to load the tag property for all of content controls.
        contentControlsWithTag.load('tag');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControlsWithTag.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to get the HTML contents of the first content control.
            const html = contentControlsWithTag.items[0].getHtml();
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Content control HTML: ' + html.value);
        }
    });
Word.ContentControl#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to get the OOXML contents of the first content control.
            const ooxml = contentControls.items[0].getOoxml();
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Content control OOXML: ' + ooxml.value);
        }
    });
Word.ContentControl#insertBreak:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of content controls.
        contentControls.load('id');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        // We now will have access to the content control collection.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to insert a page break after the first content control.
            contentControls.items[0].insertBreak(Word.BreakType.page, Word.InsertLocation.after);
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Inserted a page break after the first content control.');    
        }
    });
Word.ContentControl#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to put HTML into the contents of the first content control.
            contentControls.items[0].insertHtml(
                '<strong>HTML content inserted into the content control.</strong>',
                'Start');
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Inserted HTML in the first content control.');
        }
    });
Word.ContentControl#insertOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to put OOXML into the contents of the first content control.
            contentControls.items[0].insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", "End");
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Inserted OOXML in the first content control.');
        }
    });  

    // Read "Create better add-ins for Word with Office Open XML" for guidance on working with OOXML.
    // https://learn.microsoft.com/office/dev/add-ins/word/create-better-add-ins-for-word-with-office-open-xml
Word.ContentControl#insertParagraph:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to insert a paragraph after the first content control.
            contentControls.items[0].insertParagraph('Text of the inserted paragraph.', 'After');
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Inserted a paragraph after the first content control.');
        }
    });  
Word.ContentControl#insertText:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to replace text in the first content control.
            contentControls.items[0].insertText('Replaced text in the first content control.', 'Replace');
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Replaced text in the first content control.');
        }
    });  

    // The Silly stories add-in sample shows how to use the insertText method.
    // https://aka.ms/sillystorywordaddin
Word.ContentControl#load:member(1):
  - |-
    // Load all of the content control properties
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        } else {
            // Queue a command to load the properties on the first content control.
            contentControls.items[0].load(  'appearance,' +
                                            'cannotDelete,' +
                                            'cannotEdit,' +
                                            'id,' +
                                            'placeHolderText,' +
                                            'removeWhenEdited,' +
                                            'title,' +
                                            'text,' +
                                            'type,' +
                                            'style,' +
                                            'tag,' +
                                            'font/size,' +
                                            'font/name,' +
                                            'font/color');             
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Property values of the first content control:' + 
                '   ----- appearance: ' + contentControls.items[0].appearance + 
                '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                '   ----- color: ' + contentControls.items[0].color +
                '   ----- id: ' + contentControls.items[0].id +
                '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                '   ----- title: ' + contentControls.items[0].title +
                '   ----- text: ' + contentControls.items[0].text +
                '   ----- type: ' + contentControls.items[0].type +
                '   ----- style: ' + contentControls.items[0].style +
                '   ----- tag: ' + contentControls.items[0].tag +
                '   ----- font size: ' + contentControls.items[0].font.size +
                '   ----- font name: ' + contentControls.items[0].font.name +
                '   ----- font color: ' + contentControls.items[0].font.color);
        }
    });  
Word.ContentControl#search:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to select the first content control.
            contentControls.items[0].select();
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Selected the first content control.');
        }
    });  
Word.ContentControlCollection#getById:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content control that contains a specific id.
        const contentControl = context.document.contentControls.getById(30086310);
    
        // Queue a command to load the text property for a content control.
        contentControl.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The content control with that Id has been found in this document.');
    });
Word.ContentControlCollection#getByIdOrNullObject:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content control that contains a specific id.
        const contentControl = context.document.contentControls.getByIdOrNullObject(30086310);
    
        // Queue a command to load the text property for a content control.
        contentControl.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControl.isNullObject) {
            console.log('There is no content control with that ID.')
        } else {
            console.log('The content control with that ID has been found in this document.');
        }
    });
Word.ContentControlCollection#getByTitle:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content controls collection that contains a specific title.
        const contentControlsWithTitle = context.document.contentControls.getByTitle('Enter Customer Address Here');
    
        // Queue a command to load the text property for all of content controls with a specific title.
        contentControlsWithTitle.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControlsWithTitle.items.length === 0) {
            console.log(
                "There isn't a content control with a title of 'Enter Customer Address Here' in this document.");
        } else {
            console.log(
                "The first content control with the title of 'Enter Customer Address Here' has this text: " + 
                contentControlsWithTitle.items[0].text);
        }
    });

    // The Word-Add-in-DocumentAssembly sample has another example of using the getByTitle method.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.ContentControlCollection#getFirst:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the first content control in the document.
        const contentControl = context.document.contentControls.getFirstOrNullObject();
    
        // Queue a command to load the text property for a content control.
        contentControl.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControl.isNullObject) {
            console.log('There are no content controls in this document.')
        } else {
            console.log('The first content control has been found in this document.');
        }
    });
Word.ContentControlCollection#load:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
    
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to load the properties on the first content control.
            contentControls.items[0].load(  'appearance,' +
                                            'cannotDelete,' +
                                            'cannotEdit,' +
                                            'color,' +
                                            'id,' +
                                            'placeHolderText,' +
                                            'removeWhenEdited,' +
                                            'title,' +
                                            'text,' +
                                            'type,' +
                                            'style,' +
                                            'tag,' +
                                            'font/size,' +
                                            'font/name,' +
                                            'font/color');

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Property values of the first content control:' +
                '   ----- appearance: ' + contentControls.items[0].appearance +
                '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                '   ----- color: ' + contentControls.items[0].color +
                '   ----- id: ' + contentControls.items[0].id +
                '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                '   ----- title: ' + contentControls.items[0].title +
                '   ----- text: ' + contentControls.items[0].text +
                '   ----- type: ' + contentControls.items[0].type +
                '   ----- style: ' + contentControls.items[0].style +
                '   ----- tag: ' + contentControls.items[0].tag +
                '   ----- font size: ' + contentControls.items[0].font.size +
                '   ----- font name: ' + contentControls.items[0].font.name +
                '   ----- font color: ' + contentControls.items[0].font.color);
        }
    });

    // The Silly stories add-in sample shows how the load method is used
    // to load the content control collection with the tag and title properties.
    // https://aka.ms/sillystorywordaddin
Word.ContentControlType:enum:
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
    
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to load the properties on the first content control.
            contentControls.items[0].load(  'appearance,' +
                                            'cannotDelete,' +
                                            'cannotEdit,' +
                                            'color,' +
                                            'id,' +
                                            'placeHolderText,' +
                                            'removeWhenEdited,' +
                                            'title,' +
                                            'text,' +
                                            'type,' +
                                            'style,' +
                                            'tag,' +
                                            'font/size,' +
                                            'font/name,' +
                                            'font/color');

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Property values of the first content control:' +
                '   ----- appearance: ' + contentControls.items[0].appearance +
                '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                '   ----- color: ' + contentControls.items[0].color +
                '   ----- id: ' + contentControls.items[0].id +
                '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                '   ----- title: ' + contentControls.items[0].title +
                '   ----- text: ' + contentControls.items[0].text +
                '   ----- type: ' + contentControls.items[0].type +
                '   ----- style: ' + contentControls.items[0].style +
                '   ----- tag: ' + contentControls.items[0].tag +
                '   ----- font size: ' + contentControls.items[0].font.size +
                '   ----- font name: ' + contentControls.items[0].font.name +
                '   ----- font color: ' + contentControls.items[0].font.color);
        }
    });
Word.Document#getSelection:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        const textSample = 'This is an example of the insert text method. This is a method ' + 
            'which allows users to insert text into a selection. It can insert text into a ' +
            'relative location or it can overwrite the current selection. Since the ' +
            'getSelection method returns a range object, look up the range object documentation ' +
            'for everything you can do with a selection.';
        
        // Create a range proxy object for the current selection.
        const range = context.document.getSelection();
        
        // Queue a command to insert text at the end of the selection.
        range.insertText(textSample, Word.InsertLocation.end);
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Inserted the text at the end of the selection.');
    });  
Word.Document#load:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the document.
        const thisDocument = context.document;
        
        // Queue a command to load content control properties.
        thisDocument.load('contentControls/id, contentControls/text, contentControls/tag');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (thisDocument.contentControls.items.length !== 0) {
            for (let i = 0; i < thisDocument.contentControls.items.length; i++) {
                console.log(thisDocument.contentControls.items[i].id);
                console.log(thisDocument.contentControls.items[i].text);
                console.log(thisDocument.contentControls.items[i].tag);
            }
        } else {
            console.log('No content controls in this document.');
        }
    });
Word.Document#save:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the document.
        const thisDocument = context.document;
    
        // Queue a command to load the document save state (on the saved property).
        thisDocument.load('saved');    
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            
        if (thisDocument.saved === false) {
            // Queue a command to save this document.
            thisDocument.save();
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Saved the document');
        } else {
            console.log('The document has not changed since the last save.');
        }
    });
Word.DocumentCreated:class:
  - |-
    // Update the text of the current document with the text from another document
    // passed in as a base64-encoded string.
    await Word.run(async (context) => {
        // Important: You'll need to implement getBase64() to get the base64-encoded 
        // string representation of a docx file.
        const externalDoc = context.application.createDocument(getBase64());
        await context.sync();

        const externalDocBody = externalDoc.body;
        externalDocBody.load("text");
        await context.sync();

        const externalDocBodyText = externalDocBody.text;
        const currentDocBody = context.document.body;
        currentDocBody .insertText(externalDocBodyText, WordInsertLocation.start);
        await context.sync();
    });
Word.DocumentCreated#open:member(1):
  - |-
    // Create and open a new document in a new tab or window.
    await Word.run(async (context) => {
        const externalDoc = context.application.createDocument();
        await context.sync();

        externalDoc.open();
        await context.sync();
    });
Word.Font#name:member:
  - |-
    // Change the font name
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to change the current selection's font name.
        selection.font.name = 'Arial';
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The font name has changed.');
    });
Word.Font#color:member:
  - |-
    // Change the font color
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to change the font color of the current selection.
        selection.font.color = 'blue';
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The font color of the selection has been changed.');
    });
Word.Font#size:member:
  - |-
    // Change the font size
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to change the current selection's font size.
        selection.font.size = 20;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The font size has changed.');
    });
Word.Font#highlightColor:member:
  - |-
    // Highlight selected text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to highlight the current selection.
        selection.font.highlightColor = '#FFFF00'; // Yellow
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection has been highlighted.');
    });
Word.Font#bold:member:
  - |-
    // Bold format text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to make the current selection bold.
        selection.font.bold = true;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection is now bold.');
    });
Word.Font#underline:member:
  - |-
    // Underline format text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to underline the current selection.
        selection.font.underline = Word.UnderlineType.single;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection now has an underline style.');
    });
Word.Font#strikeThrough:member:
  - |-
    // Strike format text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to strikethrough the font of the current selection.
        selection.font.strikeThrough = true;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection now has a strikethrough.');
    });
Word.InlinePicture#getNext:member(1):
  - |-
    // To use this snippet, add an inline picture to the document and assign it an alt text title.
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the first inline picture.
        const firstPicture = context.document.body.inlinePictures.getFirstOrNullObject();
    
        // Queue a command to load the alternative text title of the picture.
        firstPicture.load('altTextTitle');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (firstPicture.isNullObject) {
            console.log('There are no inline pictures in this document.')
        } else {
            console.log(firstPicture.altTextTitle);
        }
    }); 
Word.InlinePicture#getNextOrNullObject:member(1):
  - |-
    // To use this snippet, add an inline picture to the document and assign it an alt text title.
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the first inline picture.
        const firstPicture = context.document.body.inlinePictures.getFirstOrNullObject();
    
        // Queue a command to load the alternative text title of the picture.
        firstPicture.load('altTextTitle');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (firstPicture.isNullObject) {
            console.log('There are no inline pictures in this document.')
        } else {
            console.log(firstPicture.altTextTitle);
        }
    }); 
Word.Paragraph#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        paragraphs.load('style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to clear the contents of the first paragraph.
        paragraphs.items[0].clear();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Cleared the contents of the first paragraph.');
    });
Word.Paragraph#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the text property for all of the paragraphs.
        paragraphs.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to delete the first paragraph.
        paragraphs.items[0].delete();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Deleted the first paragraph.');
    });
Word.Paragraph#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        paragraphs.load('style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a set of commands to get the HTML of the first paragraph.
        const html = paragraphs.items[0].getHtml();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Paragraph HTML: ' + html.value);
    });
Word.Paragraph#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        paragraphs.load({select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a set of commands to get the OOXML of the first paragraph.
        const ooxml = paragraphs.items[0].getOoxml();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Paragraph OOXML: ' + ooxml.value);
    });
Word.Paragraph#getPreviousOrNullObject:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the text property for all of the paragraphs.
        paragraphs.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue commands to create a proxy object for the next-to-last paragraph.
        const indexOfLastParagraph = paragraphs.items.length - 1;
        const precedingParagraph = paragraphs.items[indexOfLastParagraph].getPreviousOrNullObject();

        // Queue a command to load the text of the preceding paragraph.
        precedingParagraph.load('text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (precedingParagraph.isNullObject) {
            console.log('There are no paragraphs before the current one.');
        } else {
            console.log('The preceding paragraph is: ' + precedingParagraph.text);
        }
    });
Word.Paragraph#insertBreak:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        paragraphs.load({select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to get the first paragraph.
        const paragraph = paragraphs.items[0];

        // Queue a command to insert a page break after the first paragraph.
        paragraph.insertBreak(Word.BreakType.page, Word.InsertLocation.after);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Inserted a page break after the paragraph.');
    });
Word.Paragraph#insertContentControl:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        paragraphs.load({select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to get the first paragraph.
        const paragraph = paragraphs.items[0];

        // Queue a command to wrap the first paragraph in a rich text content control.
        paragraph.insertContentControl();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Wrapped the first paragraph in a content control.');
    });
Word.Paragraph#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        paragraphs.load({select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to get the first paragraph.
        const paragraph = paragraphs.items[0];

        // Queue a command to insert HTML content at the end of the first paragraph.
        paragraph.insertHtml('<strong>Inserted HTML.</strong>', Word.InsertLocation.end);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Inserted HTML content at the end of the first paragraph.');
    });
Word.Paragraph#insertInlinePictureFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        paragraphs.load('style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to get the first paragraph.
        const paragraph = paragraphs.items[0];

        const b64encodedImg = "iVBORw0KGgoAAAANSUhEUgAAAB4AAAANCAIAAAAxEEnAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACFSURBVDhPtY1BEoQwDMP6/0+XgIMTBAeYoTqso9Rkx1zG+tNj1H94jgGzeNSjteO5vtQQuG2seO0av8LzGbe3anzRoJ4ybm/VeKEerAEbAUpW4aWQCmrGFWykRzGBCnYy2ha3oAIq2MloW9yCCqhgJ6NtcQsqoIKdjLbFLaiACnYyf2fODbrjZcXfr2F4AAAAAElFTkSuQmCC";

        // Queue a command to insert a base64 encoded image at the beginning of the first paragraph.
        paragraph.insertInlinePictureFromBase64(b64encodedImg, Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Added an image to the first paragraph.');
    });
Word.ParagraphCollection#load:member(1):
  - |-
    // This example shows how to get the paragraphs in the Word document
    // along with their text and font size properties.
    // 
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {

        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;

        // Queue a command to load the text and font properties.
        // It is best practice to always specify the property set. Otherwise, all properties are
        // returned in on the object.
        paragraphs.load('text, font/size');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();

        // Insert code that works with the paragraphs loaded by paragraphs.load().
    });
Word.Range#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to clear the contents of the proxy range object.
        range.clear();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Cleared the selection (range object)');
    });
Word.Range#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to delete the range object.
        range.delete();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Deleted the selection (range object)');
    });
Word.Range#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to get the HTML of the current selection.
        const html = range.getHtml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The HTML read from the document was: ' + html.value);
    });
Word.Range#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to get the OOXML of the current selection.
        const ooxml = range.getOoxml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The OOXML read from the document was:  ' + ooxml.value);
    });
Word.Range#insertBreak:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert a page break after the selected text.
        range.insertBreak(Word.BreakType.page, Word.InsertLocation.after);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Inserted a page break after the selected text.');
    });
Word.Range#insertFileFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert base64 encoded .docx at the beginning of the range.
        // You'll need to implement getBase64() to make this work.
        range.insertFileFromBase64(getBase64(), Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Added base64 encoded text to the beginning of the range.');
    });
Word.Range#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert HTML in to the beginning of the range.
        range.insertHtml('<strong>This is text inserted with range.insertHtml()</strong>', Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('HTML added to the beginning of the range.');
    });
Word.Range#insertOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert OOXML in to the beginning of the range.
        range.insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('OOXML added to the beginning of the range.');
    });
    
    // Read "Create better add-ins for Word with Office Open XML" for guidance on working with OOXML.
    // https://learn.microsoft.com/office/dev/add-ins/word/create-better-add-ins-for-word-with-office-open-xml
Word.Range#insertParagraph:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert the paragraph after the range.
        range.insertParagraph('Content of a new paragraph', Word.InsertLocation.after);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Paragraph added to the end of the range.');
    });
Word.Range#insertText:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert the paragraph at the end of the range.
        range.insertText('New text inserted into the range.', Word.InsertLocation.end);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Text added to the end of the range.');
    });
Word.Range#select:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert HTML in to the beginning of the range.
        range.insertHtml('<strong>This is text inserted with range.insertHtml()</strong>', Word.InsertLocation.start);
    
        // Queue a command to select the HTML that was inserted.
        range.select();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Selected the range.');
    });
Word.SearchOptions#load:member(1):
  - |-
    // Ignore punctuation search
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Queue a command to search the document and ignore punctuation.
        const searchResults = context.document.body.search('video you', {ignorePunct: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Found count: ' + searchResults.items.length);

        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'purple';
            searchResults.items[i].font.highlightColor = '#FFFF00'; //Yellow
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    });  
  - |-
    // Search based on a prefix
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Queue a command to search the document based on a prefix.
        const searchResults = context.document.body.search('vid', {matchPrefix: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'purple';
            searchResults.items[i].font.highlightColor = '#FFFF00'; //Yellow
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    }); 
  - |-
    // Search based on a suffix
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to search the document for any string of characters after 'ly'.
        const searchResults = context.document.body.search('ly', {matchSuffix: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Found count: ' + searchResults.items.length);

        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'orange';
            searchResults.items[i].font.highlightColor = 'black';
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    });  
  - |-
    // Search using a wildcard
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Queue a command to search the document with a wildcard
        // for any string of characters that starts with 'to' and ends with 'n'.
        const searchResults = context.document.body.search('to*n', {matchWildcards: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Found count: ' + searchResults.items.length);

        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'purple';
            searchResults.items[i].font.highlightColor = 'pink';
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    }); 
Word.Section#getFooter:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy sectionsCollection object.
        const mySections = context.document.sections;
        
        // Queue a command to load the sections.
        mySections.load('body/style');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            
        // Create a proxy object the primary footer of the first section.
        // Note that the footer is a body object.
        const myFooter = mySections.items[0].getFooter(Word.HeaderFooterType.primary);
        
        // Queue a command to insert text at the end of the footer.
        myFooter.insertText("This is a footer.", Word.InsertLocation.end);
        
        // Queue a command to wrap the header in a content control.
        myFooter.insertContentControl();
                                
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log("Added a footer to the first section.");   
    });  
Word.Section#getHeader:member(2):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy sectionsCollection object.
        const mySections = context.document.sections;
        
        // Queue a command to load the sections.
        mySections.load('body/style');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        
        // Create a proxy object the primary header of the first section.
        // Note that the header is a body object.
        const myHeader = mySections.items[0].getHeader("Primary");
        
        // Queue a command to insert text at the end of the header.
        myHeader.insertText("This is a header.", Word.InsertLocation.end);
        
        // Queue a command to wrap the header in a content control.
        myHeader.insertContentControl();
                                
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log("Added a header to the first section.");
    });  
Word.Setting#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        const startMonth = settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        const count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);

        // Queue a command to delete the setting.
        startMonth.delete();

        // Queue a command to get the new count of settings.
        count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);
    });
Word.SettingCollection#deleteAll:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        const count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);

        // Queue a command to delete all settings.
        settings.deleteAll();

        // Queue a command to get the new count of settings.
        count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);
    });
Word.SettingCollection#getCount:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        const count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);

        // Queue a command to delete all settings.
        settings.deleteAll();

        // Queue a command to get the new count of settings.
        count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);
    });
Word.SettingCollection#getItem:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to retrieve a setting.
        const startMonth = settings.getItem('startMonth');
    
        // Queue a command to load the setting.
        startMonth.load();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(JSON.stringify(startMonth.value));
    });
Word.SettingCollection#getItemOrNullObject:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
        
        // Queue commands to retrieve settings.
        const startMonth = settings.getItemOrNullObject('startMonth');
        const endMonth = settings.getItemOrNullObject('endMonth');
    
        // Queue commands to load settings.
        startMonth.load();
        endMonth.load();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            if (startMonth.isNullObject) {
                console.log("No such setting.");
            }
            else {
                console.log(JSON.stringify(startMonth.value));
            }
            if (endMonth.isNullObject) {
                console.log("No such setting.");
            }
            else {
                console.log(JSON.stringify(endMonth.value));
            }
    });
Word.UnderlineType:enum:
  - |-
    // Underline format text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to underline the current selection.
        selection.font.underline = Word.UnderlineType.single;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection now has an underline style.');
    });
