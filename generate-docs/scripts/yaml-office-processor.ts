// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * Post-processor for Office API documentation YAML files.
 *
 * This script adds Office-specific enhancements to YAML files generated by api-documenter:
 * 1. Injects code examples from snippets.yaml files
 * 2. Hyperlinks API set references with product-specific URLs
 *
 * Previously these features were implemented in a custom OfficeYamlDocumenter class
 * that extended api-documenter. This post-processing approach allows us to use the
 * standard api-documenter tool.
 */

import * as fsx from 'fs-extra';
import * as yaml from 'js-yaml';
import * as path from 'path';

// ---- Configuration ----

const YAML_BASE_PATH = path.resolve('../yaml');
const JSON_BASE_PATH = path.resolve('../json');

// All product folders to process
const PRODUCT_FOLDERS = [
  'office',
  'office_release',
  'office-runtime',
  'excel',
  'excel_1_1',
  'excel_1_2',
  'excel_1_3',
  'excel_1_4',
  'excel_1_5',
  'excel_1_6',
  'excel_1_7',
  'excel_1_8',
  'excel_1_9',
  'excel_1_10',
  'excel_1_11',
  'excel_1_12',
  'excel_1_13',
  'excel_1_14',
  'excel_1_15',
  'excel_1_16',
  'excel_1_17',
  'excel_1_18',
  'excel_1_19',
  'excel_1_20',
  'excel_online',
  'excel_desktop_1_1',
  'onenote',
  'outlook',
  'outlook_1_1',
  'outlook_1_2',
  'outlook_1_3',
  'outlook_1_4',
  'outlook_1_5',
  'outlook_1_6',
  'outlook_1_7',
  'outlook_1_8',
  'outlook_1_9',
  'outlook_1_10',
  'outlook_1_11',
  'outlook_1_12',
  'outlook_1_13',
  'outlook_1_14',
  'outlook_1_15',
  'powerpoint',
  'powerpoint_1_1',
  'powerpoint_1_2',
  'powerpoint_1_3',
  'powerpoint_1_4',
  'powerpoint_1_5',
  'powerpoint_1_6',
  'powerpoint_1_7',
  'powerpoint_1_8',
  'powerpoint_1_9',
  'powerpoint_1_10',
  'visio',
  'word',
  'word_1_1',
  'word_1_2',
  'word_1_3',
  'word_1_4',
  'word_1_5',
  'word_1_6',
  'word_1_7',
  'word_1_8',
  'word_1_9',
  'word_1_3_hidden_document',
  'word_1_4_hidden_document',
  'word_1_5_hidden_document',
  'word_desktop_1_1',
  'word_desktop_1_2',
  'word_desktop_1_3',
  'word_desktop_1_4',
  'word_online'
];

// Requirement set URL mappings
const REQUIREMENT_SET_URLS: Record<string, string> = {
  excel: '/javascript/api/requirement-sets/excel/excel-api-requirement-sets',
  word: '/javascript/api/requirement-sets/word/word-api-requirement-sets',
  outlook: '/javascript/api/requirement-sets/outlook/outlook-api-requirement-sets',
  powerpoint: '/javascript/api/requirement-sets/powerpoint/powerpoint-api-requirement-sets',
  onenote: '/javascript/api/requirement-sets/onenote/onenote-api-requirement-sets',
  visio: '/office/dev/add-ins/reference/overview/visio-javascript-reference-overview',
  default: '/office/dev/add-ins/reference/javascript-api-for-office'
};

// ---- Interfaces ----

interface ISnippetsFile {
  [apiName: string]: string[];
}

interface IYamlItem {
  uid?: string;
  summary?: string;
  remarks?: string;
  syntax?: {
    return?: {
      description?: string;
    };
  };
}

// ---- Main Processing ----

async function main(): Promise<void> {
  console.log('\n=== Office YAML Post-Processor ===\n');

  let totalFiles = 0;
  let totalFolders = 0;

  for (const folder of PRODUCT_FOLDERS) {
    const result = await processFolderIfExists(folder);
    if (result) {
      totalFiles += result.filesProcessed;
      totalFolders++;
    }
  }

  console.log(`\n✓ Office YAML processing complete`);
  console.log(`  Processed ${totalFiles} files across ${totalFolders} folders\n`);
}

async function processFolderIfExists(folderName: string): Promise<{ filesProcessed: number } | null> {
  const folderPath = path.join(YAML_BASE_PATH, folderName);

  if (!fsx.existsSync(folderPath)) {
    return null;
  }

  console.log(`Processing ${folderName}...`);

  const snippets = loadSnippets(folderName);
  const snippetsAll = new Map(snippets);
  const usedSnippets = new Set<string>();

  const yamlFiles = findYamlFiles(folderPath);

  for (const filePath of yamlFiles) {
    await processYamlFile(filePath, snippetsAll, usedSnippets);
  }

  reportUnusedSnippets(snippets, usedSnippets, folderName);

  return { filesProcessed: yamlFiles.length };
}

function loadSnippets(folderName: string): Map<string, string[]> {
  // Try versioned snippets first, fallback to main snippets.yaml
  const versionedPath = path.join(JSON_BASE_PATH, folderName, 'snippets.yaml');
  const mainPath = path.join(JSON_BASE_PATH, 'snippets.yaml');

  let snippetsPath: string;
  if (fsx.existsSync(versionedPath)) {
    snippetsPath = versionedPath;
  } else if (fsx.existsSync(mainPath)) {
    snippetsPath = mainPath;
  } else {
    return new Map();
  }

  const content = fsx.readFileSync(snippetsPath, 'utf-8');
  const obj = yaml.load(content) as ISnippetsFile;

  return new Map(Object.entries(obj));
}

function findYamlFiles(dirPath: string): string[] {
  const files: string[] = [];

  function walk(currentPath: string): void {
    const entries = fsx.readdirSync(currentPath, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(currentPath, entry.name);
      if (entry.isDirectory()) {
        walk(fullPath);
      } else if (entry.name.endsWith('.yml')) {
        files.push(fullPath);
      }
    }
  }

  walk(dirPath);
  return files;
}

async function processYamlFile(
  filePath: string,
  snippets: Map<string, string[]>,
  usedSnippets: Set<string>
): Promise<void> {
  const content = fsx.readFileSync(filePath, 'utf-8');

  // Preserve the YamlMime header if present
  const lines = content.split('\n');
  const yamlMimeHeader = lines[0].startsWith('### YamlMime:') ? lines[0] + '\n' : '';

  let doc: any;

  try {
    doc = yaml.load(content);
  } catch (error) {
    console.warn(`  Warning: Failed to parse ${filePath}: ${error}`);
    return;
  }

  if (!doc || typeof doc !== 'object') {
    return;
  }

  let modified = false;

  // Process main item
  if (doc.uid) {
    modified = injectExamples(doc, snippets, usedSnippets) || modified;
    modified = hyperlinkApiSets(doc) || modified;
  }

  // Process nested items in arrays
  const arrayNames = ['properties', 'methods', 'events', 'functions', 'fields', 'typeParameters'];
  for (const arrayName of arrayNames) {
    if (Array.isArray(doc[arrayName])) {
      for (const item of doc[arrayName]) {
        if (item && item.uid) {
          modified = injectExamples(item, snippets, usedSnippets) || modified;
          modified = hyperlinkApiSets(item) || modified;
        }
      }
    }
  }

  if (modified) {
    let output = yaml.dump(doc, {
      lineWidth: -1,
      noRefs: true,
      sortKeys: false
    });

    // Prepend the YamlMime header if it existed
    if (yamlMimeHeader) {
      output = yamlMimeHeader + output;
    }

    fsx.writeFileSync(filePath, output, 'utf-8');
  }
}

function injectExamples(
  item: IYamlItem,
  snippets: Map<string, string[]>,
  usedSnippets: Set<string>
): boolean {
  if (!item.uid) {
    return false;
  }

  // Remove package prefix: "excel!Excel.Range#clear:member(1)" -> "Excel.Range#clear:member(1)"
  const nameWithoutPackage = item.uid.replace(/^[^.]+\!/, '');
  const snippetCode = snippets.get(nameWithoutPackage);

  if (!snippetCode || snippetCode.length === 0) {
    return false;
  }

  usedSnippets.add(nameWithoutPackage);

  // Generate example text
  const examplesSection = generateExampleSnippetText(snippetCode);

  // Inject into remarks (preferred) or syntax.return.description (fallback)
  if (item.remarks) {
    if (!item.remarks.includes('#### Examples')) {
      item.remarks += examplesSection;
      return true;
    }
  } else if (item.syntax?.return?.description !== undefined) {
    if (!item.syntax.return.description.includes('#### Examples')) {
      if (item.syntax.return.description === '') {
        item.syntax.return.description = examplesSection.substring(2); // Remove leading \n\n
      } else {
        item.syntax.return.description += examplesSection;
      }
      return true;
    }
  } else {
    // Create new remarks field
    item.remarks = examplesSection.substring(2); // Remove leading \n\n
    return true;
  }

  return false;
}

function generateExampleSnippetText(snippets: string[]): string {
  const text: string[] = ['\n\n#### Examples\n'];
  for (const snippet of snippets) {
    text.push(`\`\`\`TypeScript\n${snippet}\n\`\`\``);
  }
  return text.join('\n');
}

function hyperlinkApiSets(item: IYamlItem): boolean {
  if (!item.uid) {
    return false;
  }

  let modified = false;
  const url = getApiSetUrl(item.uid);

  if (item.summary && typeof item.summary === 'string') {
    // First capitalize "Api" to "API"
    let newSummary = item.summary.replace(/Api set:/g, 'API set:');
    // Then add hyperlink: \[API set: ExcelApi 1.1\] -> \[ [API set: ExcelApi 1.1](url) \]
    newSummary = newSummary.replace(/\\\[(API set:[^\]]+)\\\]/g, (match, apiSetText) => {
      return `\\[ [${apiSetText}](${url}) \\]`;
    });

    if (newSummary !== item.summary) {
      item.summary = newSummary;
      modified = true;
    }
  }

  if (item.remarks && typeof item.remarks === 'string') {
    // First capitalize "Api" to "API"
    let newRemarks = item.remarks.replace(/Api set:/g, 'API set:');
    // Then add hyperlink: \[API set: ExcelApi 1.1\] -> \[ [API set: ExcelApi 1.1](url) \]
    newRemarks = newRemarks.replace(/\\\[(API set:[^\]]+)\\\]/g, (match, apiSetText) => {
      return `\\[ [${apiSetText}](${url}) \\]`;
    });

    if (newRemarks !== item.remarks) {
      item.remarks = newRemarks;
      modified = true;
    }
  }

  return modified;
}

function getApiSetUrl(uid: string): string {
  if (!uid) {
    return REQUIREMENT_SET_URLS.default;
  }

  const lowerUid = uid.toLowerCase();

  for (const key of Object.keys(REQUIREMENT_SET_URLS)) {
    if (key !== 'default' && lowerUid.includes(key)) {
      return REQUIREMENT_SET_URLS[key];
    }
  }

  return REQUIREMENT_SET_URLS.default;
}

function reportUnusedSnippets(
  snippets: Map<string, string[]>,
  usedSnippets: Set<string>,
  folderName: string
): void {
  const unused = Array.from(snippets.keys()).filter(k => !usedSnippets.has(k));

  if (unused.length > 0) {
    console.log();
    for (const apiName of unused) {
      console.warn(`Warning: Unused snippet ${apiName}`);
    }
  }
}

// ---- Entry Point ----

main().catch((error) => {
  console.error('\n✗ Error during Office YAML processing:');
  console.error(error);
  process.exit(1);
});
