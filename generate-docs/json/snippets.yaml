Excel.Application.calculate:
  - |-
    Excel.run(function (ctx) {
        ctx.workbook.application.calculate('Full');
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Application.load:
  - |-
    Excel.run(function (ctx) {
        var application = ctx.workbook.application;
        application.load('calculationMode');
        return ctx.sync().then(function() {
            console.log(application.calculationMode);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Binding.getRange:
  - |-
    Excel.run(function (ctx) { 
        var binding = ctx.workbook.bindings.getItemAt(0);
        var range = binding.getRange();
        range.load('cellCount');
        return ctx.sync().then(function() {
            console.log(range.cellCount);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Binding.getTable:
  - |-
    Excel.run(function (ctx) { 
        var binding = ctx.workbook.bindings.getItemAt(0);
        var table = binding.getTable();
        table.load('name');
        return ctx.sync().then(function() {
                console.log(table.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Binding.getText:
  - |-
    Excel.run(function (ctx) { 
        var binding = ctx.workbook.bindings.getItemAt(0);
        var text = binding.getText();
        binding.load('text');
        return ctx.sync().then(function() {
            console.log(text);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Binding.load:
  - |-
    Excel.run(function (ctx) { 
        var binding = ctx.workbook.bindings.getItemAt(0);
        binding.load('type');
        return ctx.sync().then(function() {
            console.log(binding.type);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.BindingCollection.getItem:
  - >-
    function addEventHandler() {
        //Create Table1
    Excel.run(function (ctx) { 
        ctx.workbook.tables.add("Sheet1!A1:C4", true);
        return ctx.sync().then(function() {
                 console.log("My Diet Data Inserted!");
        })
        .catch(function (error) {
                 console.log(JSON.stringify(error));
        });
    });
        //Create a new table binding for Table1
    Office.context.document.bindings.addFromNamedItemAsync("Table1",
    Office.CoercionType.Table, { id: "myBinding" }, function (asyncResult) {
        if (asyncResult.status == "failed") {
            console.log("Action failed with error: " + asyncResult.error.message);
        }
        else {
            // If succeeded, then add event handler to the table binding.
            Office.select("bindings#myBinding").addHandlerAsync(Office.EventType.BindingDataChanged, onBindingDataChanged);
        }
    });

    }
        
    // when data in the table is changed, this event will be triggered.

    function onBindingDataChanged(eventArgs) {

    Excel.run(function (ctx) { 
        // highlight the table in orange to indicate data has been changed.
        ctx.workbook.bindings.getItem(eventArgs.binding.id).getTable().getDataBodyRange().format.fill.color = "Orange";
        return ctx.sync().then(function() {
                console.log("The value in this table got changed!");
        })
        .catch(function (error) {
                console.log(JSON.stringify(error));
        });
    });

    }
  - |-
    Excel.run(function (ctx) { 
        var lastPosition = ctx.workbook.bindings.count - 1;
        var binding = ctx.workbook.bindings.getItemAt(lastPosition);
        binding.load('type')
        return ctx.sync().then(function() {
                console.log(binding.type); 
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.BindingCollection.getItemAt:
  - |-
    Excel.run(function (ctx) { 
        var lastPosition = ctx.workbook.bindings.count - 1;
        var binding = ctx.workbook.bindings.getItemAt(lastPosition);
        binding.load('type')
        return ctx.sync().then(function() {
                console.log(binding.type); 
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.BindingCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var bindings = ctx.workbook.bindings;
        bindings.load('items');
        return ctx.sync().then(function() {
            for (var i = 0; i < bindings.items.length; i++)
            {
                console.log(bindings.items[i].id);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var bindings = ctx.workbook.bindings;
        bindings.load('count');
        return ctx.sync().then(function() {
            console.log("Bindings: Count= " + bindings.count);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Chart.delete:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.delete();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Chart.getImage:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        var image = chart.getImage();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Chart.setData:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        var sourceData = "A1:B4";
        chart.setData(sourceData, "Columns");
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Chart.setPosition:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Charts";
        var rangeSelection = "A1:B4";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeSelection);
        var sourceData = sheetName + "!" + "A1:B4";
        var chart = ctx.workbook.worksheets.getItem(sheetName).charts.add("pie", range, "auto");
        chart.width = 500;
        chart.height = 300;
        chart.setPosition("C2", null);
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Chart.load:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.load('name');
        return ctx.sync().then(function() {
                console.log(chart.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.name="New Name";
        chart.top = 100;
        chart.left = 100;
        chart.height = 200;
        chart.width = 200;
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");
        chart.name="New Name";    
        chart.top = 100;
        chart.left = 100;
        chart.height =200;
        chart.width =200;
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartAxis.load:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        var axis = chart.axes.valueAxis;
        axis.load('maximum');
        return ctx.sync().then(function() {
                console.log(axis.maximum);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.axes.valueAxis.maximum = 5;
        chart.axes.valueAxis.minimum = 0;
        chart.axes.valueAxis.majorUnit = 1;
        chart.axes.valueAxis.minorUnit = 0.2;
        return ctx.sync().then(function() {
                console.log("Axis Settings Changed");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartCollection.add:
  - |-
    Excel.run(function (ctx) { 
        var rangeSelection = "A1:B4";
        var range = ctx.workbook.worksheets.getItem(sheetName)
            .getRange(rangeSelection);
        var chart = ctx.workbook.worksheets.getItem(sheetName)
            .charts.add("ColumnClustered", range, "auto");    return ctx.sync().then(function() {
                console.log("New Chart Added");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartCollection.getItem:
  - |-
    Excel.run(function (ctx) { 
        var chartname = 'Chart1';
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem(chartname);
        return ctx.sync().then(function() {
                console.log(chart.height);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var chartId = 'SamplChartId';
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem(chartId);
        return ctx.sync().then(function() {
                console.log(chart.height);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var lastPosition = ctx.workbook.worksheets.getItem("Sheet1").charts.count - 1;
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItemAt(lastPosition);
        return ctx.sync().then(function() {
                console.log(chart.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartCollection.getItemAt:
  - |-
    Excel.run(function (ctx) { 
        var lastPosition = ctx.workbook.worksheets.getItem("Sheet1").charts.count - 1;
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItemAt(lastPosition);
        return ctx.sync().then(function() {
                console.log(chart.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var charts = ctx.workbook.worksheets.getItem("Sheet1").charts;
        charts.load('items');
        return ctx.sync().then(function() {
            for (var i = 0; i < charts.items.length; i++)
            {
                console.log(charts.items[i].name);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var charts = ctx.workbook.worksheets.getItem("Sheet1").charts;
        charts.load('count');
        return ctx.sync().then(function() {
            console.log("charts: Count= " + charts.count);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartDataLabels.load:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.datalabels.showValue = true;
        chart.datalabels.position = "top";
        chart.datalabels.showSeriesName = true;
        return ctx.sync().then(function() {
                console.log("Datalabels Shown");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartFill.clear:
  - |-
    Excel.run(function (ctx) { 
        var gridlines = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").axes.valueAxis.majorGridlines;    
        gridlines.format.line.clear();
        return ctx.sync().then(function() {
                console.log("Chart Major Gridlines Format Cleared");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartFill.setSolidColor:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    

        chart.format.fill.setSolidColor("#FF0000");

        return ctx.sync().then(function() {
                console.log("Chart1 Background Color Changed.");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartFont.load:
  - |-
    Excel.run(function (ctx) { 
        var title = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").title;
        title.format.font.name = "Calibri";
        title.format.font.size = 12;
        title.format.font.color = "#FF0000";
        title.format.font.italic =  false;
        title.format.font.bold = true;
        title.format.font.underline = "None";
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var title = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").title;
        title.format.font.name = "Calibri";
        title.format.font.size = 12;
        title.format.font.color = "#FF0000";
        title.format.font.italic =  false;
        title.format.font.bold = true;
        title.format.font.underline = "None";
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartGridlines.load:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        var majGridlines = chart.axes.valueaxis.majorGridlines;
        majGridlines.load('visible');
        return ctx.sync().then(function() {
                console.log(majGridlines.visible);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.axes.valueAxis.majorGridlines.visible = true;
        return ctx.sync().then(function() {
                console.log("Axis Gridlines Added ");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartLegend.load:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        var legend = chart.legend;
        legend.load('position');
        return ctx.sync().then(function() {
                console.log(legend.position);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.legend.visible = true;
        chart.legend.position = "top"; 
        chart.legend.overlay = false; 
        return ctx.sync().then(function() {
                console.log("Legend Shown ");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartLineFormat.clear:
  - |-
    Excel.run(function (ctx) { 
        var gridlines = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").axes.valueAxis.majorGridlines;    
        gridlines.format.line.clear();
        return ctx.sync().then(function() {
                console.log("Chart Major Gridlines Format Cleared");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartLineFormat.load:
  - |-
    Excel.run(function (ctx) {
        var gridlines = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").axes.valueAxis.majorGridlines;
        gridlines.format.line.color = "#FF0000";
        return ctx.sync().then(function () {
            console.log("Chart Gridlines Color Updated");
        });
    }).catch(function (error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartPointsCollection.getItemAt:
  - |-
    Excel.run(function (ctx) { 
        var points = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series.getItemAt(0).points;
        points.getItemAt(0).format.fill.setSolidColor("8FBC8F");
        return ctx.sync().then(function() {
            console.log("Point Border Color Changed");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartPointsCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var pointsCollection = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series.getItemAt(0).points;
        pointsCollection.load('items');
        return ctx.sync().then(function() {
            console.log("Points Collection loaded");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var pointsCollection = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series.getItemAt(0).points;
        pointsCollection.load('count');
        return ctx.sync().then(function() {
            console.log("points: Count= " + pointsCollection.count);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartSeries.load:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.series.getItemAt(0).name = "New Series Name";
        return ctx.sync().then(function() {
                console.log("Series1 Renamed");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartSeriesCollection.getItemAt:
  - |-
    Excel.run(function (ctx) { 
        var seriesCollection = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series;
        seriesCollection.load('items');
        return ctx.sync().then(function() {
            console.log(seriesCollection.items[0].name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartSeriesCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var seriesCollection = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series;
        seriesCollection.load('items');
        return ctx.sync().then(function() {
            for (var i = 0; i < seriesCollection.items.length; i++)
            {
                console.log(seriesCollection.items[i].name);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var seriesCollection = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series;
        seriesCollection.load('count');
        return ctx.sync().then(function() {
            console.log("series: Count= " + seriesCollection.count);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ChartTitle.load:
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        
        var title = chart.title;
        title.load('text');
        return ctx.sync().then(function() {
                console.log(title.text);
        }).catch(function(error) {
            console.log("Error: " + error);
            if (error instanceof OfficeExtension.Error) {
                console.log("Debug info: " + JSON.stringify(error.debugInfo));
            }
        });
    });
  - |-
    Excel.run(function (ctx) { 
        var chart = ctx.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        
        chart.title.text= "My Chart"; 
        chart.title.visible=true;
        chart.title.overlay=true;
        
        return ctx.sync().then(function() {
            console.log("Char Title Changed");
        }).catch(function(error) {
            console.log("Error: " + error);
            if (error instanceof OfficeExtension.Error) {
                console.log("Debug info: " + JSON.stringify(error.debugInfo));
            }
        });
    });
Excel.ConditionalFormatCollection.add:
  - |-
    Excel.run(function (ctx) {
        var sheetName = "Sheet1";
        var rangeAddress = "A1:C3";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var conditionalFormat = range.conditionalFormats.add(Excel.ConditionalFormatType.iconSet);
        conditionalFormat.iconOrNull.style = "YellowThreeArrows";
        return ctx.sync().then(function () {
            console.log("Added new yellow three arrow icon set.");
        });
    }).catch(function (error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ConditionalFormatCollection.clearAll:
  - |-
    Excel.run(function (ctx) {
        var sheetName = "Sheet1";
        var rangeAddress = "A1:C3";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var conditionalFormats = range.conditionalFormats;
        var conditionalFormat = conditionalFormats.clearAll();
        return ctx.sync().then(function () {
            console.log("Cleared all conditional formats from this range.");
        });
    }).catch(function (error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ConditionalFormatCollection.getCount:
  - |-
    Excel.run(function (ctx) {
        var sheetName = "Sheet1";
        var rangeAddress = "A1:C3";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var conditionalFormat = range.conditionalFormats.add(Excel.ConditionalFormatType.iconSet);
        conditionalFormat.iconOrNull.style = Excel.IconSet.fourTrafficLights;
        var cfCount = range.conditionalFormats.getCount(); 

        return ctx.sync().then(function () {
            console.log("Count: " + cfCount.value);
        });
    }).catch(function (error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ConditionalFormatCollection.getItem:
  - |-
    Excel.run(function (ctx) {
        var sheetName = "Sheet1";
        var rangeAddress = "A1:C3";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var conditionalFormats = range.conditionalFormats;
        var conditionalFormat = conditionalFormats.getItemAt(3);
        return ctx.sync().then(function () {
            console.log("Conditional Format at Item 3 Loaded");
        });
    }).catch(function (error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.ConditionalFormatCollection.getItemAt:
  - |-
    Excel.run(function (ctx) {
        var sheetName = "Sheet1";
        var rangeAddress = "A1:C3";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var conditionalFormats = range.conditionalFormats;
        var conditionalFormat = conditionalFormats.getItemAt(3);
        return ctx.sync().then(function () {
            console.log("Conditional Format at Item 3 Loaded");
        });
    }).catch(function (error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const worksheetRange = sheet.getRange();
        worksheetRange.conditionalFormats.load("type");

        await context.sync();

        let cfRangePairs: { cf: Excel.ConditionalFormat, range: Excel.Range }[] = [];
        worksheetRange.conditionalFormats.items.forEach(item => {
            cfRangePairs.push({
                cf: item,
                range: item.getRange().load("address")
            });
        });

        await context.sync();

        $("#conditional-formats li").remove();
        if (cfRangePairs.length > 0) {
            cfRangePairs.forEach(item => {
                let $p = $("<p></p>").text(
                    `${item.cf.type}`)
                let $li = $(`<li></li>`);
                $li.append($p);
                $("#conditional-formats").append($li);
                $(".conditional-formats").show()[0].scrollIntoView();
            })
        }
        else {
            OfficeHelpers.UI.notify("None to display", "No conditional formats in workbook", "warning");
        }
    });
Excel.NamedItem.getRange:
  - |-
    Excel.run(function (ctx) { 
        var names = ctx.workbook.names;
        var range = names.getItem('MyRange').getRange();
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.NamedItem.load:
  - |-
    Excel.run(function (ctx) { 
        var names = ctx.workbook.names;
        var namedItem = names.getItem('MyRange');
        namedItem.load('type');
        return ctx.sync().then(function() {
                console.log(namedItem.type);
        });
    }).catch(function(error) {
            console.log("Error: " + error);
            if (error instanceof OfficeExtension.Error) {
                console.log("Debug info: " + JSON.stringify(error.debugInfo));
            }
    });
Excel.NamedItemCollection.getItem:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = 'Sheet1';
        var nameditem = ctx.workbook.names.getItem(sheetName);
        nameditem.load('type');
        return ctx.sync().then(function() {
                console.log(nameditem.type);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.NamedItemCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var nameditems = ctx.workbook.names;
        nameditems.load('items');
        return ctx.sync().then(function() {
            for (var i = 0; i < nameditems.items.length; i++)
            {
                console.log(nameditems.items[i].name);
                console.log(nameditems.items[i].index);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.clear:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "D:F";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.clear();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.delete:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "D:F";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.delete();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getBoundingRect:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "D4:G6";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var range = range.getBoundingRect("G4:H8");
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address); // Prints Sheet1!D4:H8
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getCell:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var cell = range.cell(0,0);
        cell.load('address');
        return ctx.sync().then(function() {
            console.log(cell.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getColumn:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet19";
        var rangeAddress = "A1:F8";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getColumn(1);
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address); // prints Sheet1!B1:B8
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getEntireColumn:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "D:F";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var rangeEC = range.getEntireColumn();
        rangeEC.load('address');
        return ctx.sync().then(function() {
            console.log(rangeEC.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getEntireRow:
  - |-
    Excel.run(function (ctx) {
        var sheetName = "Sheet1";
        var rangeAddress = "D:F"; 
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var rangeER = range.getEntireRow();
        rangeER.load('address');
        return ctx.sync().then(function() {
            console.log(rangeER.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getIntersection:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getIntersection("D4:G6");
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address); // prints Sheet1!D4:F6
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getLastCell:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getLastCell();
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address); // prints Sheet1!F8
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getLastColumn:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getLastColumn();
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address); // prints Sheet1!F1:F8
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getLastRow:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getLastRow();
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address); // prints Sheet1!A8:F8
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getOffsetRange:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "D4:F6";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getOffsetRange(-1,4);
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address); // prints Sheet1!H3:K5
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getRow:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getRow(1);
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address); // prints Sheet1!A2:F2
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.getUsedRange:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "D:F";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        var rangeUR = range.getUsedRange();
        rangeUR.load('address');
        return ctx.sync().then(function() {
            console.log(rangeUR.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");    
        const salesTable = sheet.tables.getItem("SalesTable");
        const dataRange = salesTable.getDataBodyRange();

        // We want the most recent quarter that has data, so 
        // exclude quarters without data and get the last of 
        // the remaining columns.
        const usedDataRange = dataRange.getUsedRange(true /* valuesOnly */);
        const currentQuarterRange = usedDataRange.getLastColumn();

        // Asian and European teams have separate contests.
        const asianSalesRange = sheet.getRange("A2:E4");
        const europeanSalesRange = sheet.getRange("A5:E7");

        // The data for each chart is the intersection of 
        // the current quarter column and the rows for the 
        // continent.
        const asianContestRange = asianSalesRange.getIntersectionOrNullObject(currentQuarterRange);
        const europeanContestRange = europeanSalesRange.getIntersectionOrNullObject(currentQuarterRange);

        // Must sync before you can test the output of *OrNullObject 
        // method/property.
        await context.sync();

        if (asianContestRange.isNullObject) {
            // See the declaration of this method for how to 
            // test this code path.
            reportMissingData("Asian");
        } else {
            createContinentChart(sheet, "Asian", asianContestRange, "A9", "F24");
        }

        if (europeanContestRange.isNullObject) {
            // See the declaration of this method for how to 
            // test this code path.
            reportMissingData("European");
        } else {
            createContinentChart(sheet, "European", europeanContestRange, "A25", "F40");
        }

        await context.sync();
    });
Excel.Range.insert:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F5:F10";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.insert();
        return ctx.sync(); 
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.merge:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:C3";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.merge(true);
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:C3";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.unmerge();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.select:
  - |-
    Excel.run(function (ctx) {
        var sheetName = "Sheet1";
        var rangeAddress = "F5:F10"; 
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.select();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.unmerge:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:C3";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.unmerge();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Range.load:
  - |-
    Excel.run(function (ctx) {
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8"; 
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        range.load('cellCount');
        return ctx.sync().then(function() {
            console.log(range.cellCount);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var rangeName = 'MyRange';
        var range = ctx.workbook.names.getItem(rangeName).range;
        range.load('cellCount');
        return ctx.sync().then(function() {
            console.log(range.cellCount);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F5:G7";
        var numberFormat = [[null, "d-mmm"], [null, "d-mmm"], [null, null]]
        var values = [["Today", 42147], ["Tomorrow", "5/24"], ["Difference in days", null]];
        var formulas = [[null,null], [null,null], [null,"=G6-G5"]];
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.numberFormat = numberFormat;
        range.values = values;
        range.formulas= formulas;
        range.load('text');
        return ctx.sync().then(function() {
            console.log(range.text);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.RangeBorder.load:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var borders = range.format.borders;
        borders.load('items');
        return ctx.sync().then(function() {
            console.log(borders.count);
            for (var i = 0; i < borders.items.length; i++)
            {
                console.log(borders.items[i].sideIndex);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.format.borders.getItem('InsideHorizontal').style = 'Continuous';
        range.format.borders.getItem('InsideVertical').style = 'Continuous';
        range.format.borders.getItem('EdgeBottom').style = 'Continuous';
        range.format.borders.getItem('EdgeLeft').style = 'Continuous';
        range.format.borders.getItem('EdgeRight').style = 'Continuous';
        range.format.borders.getItem('EdgeTop').style = 'Continuous';
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.RangeBorderCollection.getItem:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var borderName = 'EdgeTop';
        var border = range.format.borders.getItem(borderName);
        border.load('style');
        return ctx.sync().then(function() {
                console.log(border.style);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var border = range.format.borders.getItemAt(0);
        border.load('sideIndex');
        return ctx.sync().then(function() {
                console.log(border.sideIndex);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.RangeBorderCollection.getItemAt:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var border = range.format.borders.getItemAt(0);
        border.load('sideIndex');
        return ctx.sync().then(function() {
            console.log(border.sideIndex);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.RangeBorderCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var borders = range.format.borders;
        border.load('items');
        return ctx.sync().then(function() {
            console.log(borders.count);
            for (var i = 0; i < borders.items.length; i++)
            {
                console.log(borders.items[i].sideIndex);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.format.borders.getItem('InsideHorizontal').style = 'Continuous';
        range.format.borders.getItem('InsideVertical').style = 'Continuous';
        range.format.borders.getItem('EdgeBottom').style = 'Continuous';
        range.format.borders.getItem('EdgeLeft').style = 'Continuous';
        range.format.borders.getItem('EdgeRight').style = 'Continuous';
        range.format.borders.getItem('EdgeTop').style = 'Continuous';
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.RangeFill.clear:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F:G";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var rangeFill = range.format.fill;
        rangeFill.clear();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.RangeFill.load:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F:G";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var rangeFill = range.format.fill;
        rangeFill.load('color');
        return ctx.sync().then(function() {
            console.log(rangeFill.color);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F:G";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.format.fill.color = '0000FF';
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.RangeFont.load:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F:G";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        var rangeFont = range.format.font;
        rangeFont.load('name');
        return ctx.sync().then(function() {
            console.log(rangeFont.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F:G";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.format.font.name = 'Times New Roman';
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.RangeFormat.load:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F:G";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        range.load(["format/*", "format/fill", "format/borders", "format/font"]);
        return ctx.sync().then(function() {
            console.log(range.format.wrapText);
            console.log(range.format.fill.color);
            console.log(range.format.font.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F:G";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.format.wrapText = true;
        range.format.font.name = 'Times New Roman';
        range.format.fill.color = '0000FF';
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "F:G";
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.format.borders.getItem('InsideHorizontal').style = 'Continuous';
        range.format.borders.getItem('InsideVertical').style = 'Continuous';
        range.format.borders.getItem('EdgeBottom').style = 'Continuous';
        range.format.borders.getItem('EdgeLeft').style = 'Continuous';
        range.format.borders.getItem('EdgeRight').style = 'Continuous';
        range.format.borders.getItem('EdgeTop').style = 'Continuous';
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Table.convertToRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        table.convertToRange();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Table.delete:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        table.delete();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Table.getDataBodyRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        var tableDataRange = table.getDataBodyRange();
        tableDataRange.load('address')
        return ctx.sync().then(function() {
                console.log(tableDataRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Table.getHeaderRowRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        var tableHeaderRange = table.getHeaderRowRange();
        tableHeaderRange.load('address');
        return ctx.sync().then(function() {
            console.log(tableHeaderRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Table.getRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        var tableRange = table.getRange();
        tableRange.load('address');    
        return ctx.sync().then(function() {
                console.log(tableRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Table.getTotalRowRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        var tableTotalsRange = table.getTotalRowRange();
        tableTotalsRange.load('address');    
        return ctx.sync().then(function() {
                console.log(tableTotalsRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Table.load:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        table.load('index')
        return ctx.sync().then(function() {
                console.log(table.index);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var index = 0;
        var table = ctx.workbook.tables.getItemAt(0);
        table.load('id')
        return ctx.sync().then(function() {
                console.log(table.id);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        table.name = 'Table1-Renamed';
        table.showTotals = false;
        table.style = 'TableStyleMedium2';
        table.load('tableStyle');
        return ctx.sync().then(function() {
                console.log(table.style);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableCollection.add:
  - |-
    Excel.run(function (ctx) { 
        var table = ctx.workbook.tables.add('Sheet1!A1:E7', true);
        table.load('name');
        return ctx.sync().then(function() {
            console.log(table.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableCollection.getItem:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        table.load('name');
        return ctx.sync().then(function() {
                console.log(table.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var table = ctx.workbook.tables.getItemAt(0);
        table.load('name');
        return ctx.sync().then(function() {
                console.log(table.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableCollection.getItemAt:
  - |-
    Excel.run(function (ctx) { 
        var table = ctx.workbook.tables.getItemAt(0);
        table.load('name');
        return ctx.sync().then(function() {
                console.log(table.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var tables = ctx.workbook.tables;
        tables.load();
        return ctx.sync().then(function() {
            console.log("tables Count: " + tables.count);
            for (var i = 0; i < tables.items.length; i++)
            {
                console.log(tables.items[i].name);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var tables = ctx.workbook.tables;
        tables.load('count');
        return ctx.sync().then(function() {
            console.log(tables.count);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumn.delete:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var column = ctx.workbook.tables.getItem(tableName).columns.getItemAt(2);
        column.delete();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumn.getDataBodyRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var column = ctx.workbook.tables.getItem(tableName).columns.getItemAt(0);
        var dataBodyRange = column.getDataBodyRange();
        dataBodyRange.load('address');
        return ctx.sync().then(function() {
            console.log(dataBodyRange.address);
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumn.getHeaderRowRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var columns = ctx.workbook.tables.getItem(tableName).columns.getItemAt(0);
        var headerRowRange = columns.getHeaderRowRange();
        headerRowRange.load('address');
        return ctx.sync().then(function() {
            console.log(headerRowRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumn.getRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var columns = ctx.workbook.tables.getItem(tableName).columns.getItemAt(0);
        var columnRange = columns.getRange();
        columnRange.load('address');
        return ctx.sync().then(function() {
            console.log(columnRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumn.getTotalRowRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var columns = ctx.workbook.tables.getItem(tableName).columns.getItemAt(0);
        var totalRowRange = columns.getTotalRowRange();
        totalRowRange.load('address');
        return ctx.sync().then(function() {
            console.log(totalRowRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumn.load:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var column = ctx.workbook.tables.getItem(tableName).columns.getItem(0);
        column.load('index');
        return ctx.sync().then(function() {
            console.log(column.index);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var tables = ctx.workbook.tables;
        var newValues = [["New"], ["Values"], ["For"], ["New"], ["Column"]];
        var column = ctx.workbook.tables.getItem(tableName).columns.getItemAt(2);
        column.values = newValues;
        column.load('values');
        return ctx.sync().then(function() {
            console.log(column.values);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumnCollection.add:
  - |-
    Excel.run(function (ctx) { 
        var tables = ctx.workbook.tables;
        var values = [["Sample"], ["Values"], ["For"], ["New"], ["Column"]];
        var column = tables.getItem("Table1").columns.add(null, values);
        column.load('name');
        return ctx.sync().then(function() {
            console.log(column.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumnCollection.getItem:
  - |-
    Excel.run(function (ctx) { 
        var tablecolumn = ctx.workbook.tables.getItem('Table1').columns.getItem(0);
        tablecolumn.load('name');
        return ctx.sync().then(function() {
                console.log(tablecolumn.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var tablecolumn = ctx.workbook.tables.getItem['Table1'].columns.getItemAt(0);
        tablecolumn.load('name');
        return ctx.sync().then(function() {
                console.log(tablecolumn.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumnCollection.getItemAt:
  - |-
    Excel.run(function (ctx) { 
        var tablecolumn = ctx.workbook.tables.getItem['Table1'].columns.getItemAt(0);
        tablecolumn.load('name');
        return ctx.sync().then(function() {
                console.log(tablecolumn.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableColumnCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var tablecolumns = ctx.workbook.tables.getItem('Table1').columns;
        tablecolumns.load('items');
        return ctx.sync().then(function() {
            console.log("tablecolumns Count: " + tablecolumns.count);
            for (var i = 0; i < tablecolumns.items.length; i++)
            {
                console.log(tablecolumns.items[i].name);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableRow.delete:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var row = ctx.workbook.tables.getItem(tableName).rows.getItemAt(2);
        row.delete();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableRow.getRange:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var row = ctx.workbook.tables.getItem(tableName).rows.getItemAt(0);
        var rowRange = row.getRange();
        rowRange.load('address');
        return ctx.sync().then(function() {
            console.log(rowRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableRow.load:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var row = ctx.workbook.tables.getItem(tableName).rows.getItem(0);
        row.load('index');
        return ctx.sync().then(function() {
            console.log(row.index);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var tables = ctx.workbook.tables;
        var newValues = [["New", "Values", "For", "New", "Row"]];
        var tableName = 'Table1';
        var row = ctx.workbook.tables.getItem(tableName).rows.getItemAt(2);
        row.values = newValues;
        row.load('values');
        return ctx.sync().then(function() {
            console.log(row.values);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableRowCollection.add:
  - |-
    Excel.run(function (ctx) { 
        var tables = ctx.workbook.tables;
        var values = [["Sample", "Values", "For", "New", "Row"]];
        var row = tables.getItem("Table1").rows.add(null, values);
        row.load('index');
        return ctx.sync().then(function() {
            console.log(row.index);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableRowCollection.getItemAt:
  - |-
    Excel.run(function (ctx) { 
        var tablerow = ctx.workbook.tables.getItem('Table1').rows.getItemAt(0);
        tablerow.load('name');
        return ctx.sync().then(function() {
                console.log(tablerow.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableRowCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var tablerows = ctx.workbook.tables.getItem('Table1').rows;
        tablerows.load('items');
        return ctx.sync().then(function() {
            console.log("tablerows Count: " + tablerows.count);
            for (var i = 0; i < tablerows.items.length; i++)
            {
                console.log(tablerows.items[i].index);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.TableSort.apply:
  - |-
    Excel.run(function (ctx) { 
        var tableName = 'Table1';
        var table = ctx.workbook.tables.getItem(tableName);
        table.sort.apply([ 
                {
                    key: 2,
                    ascending: true
                },
            ], true);
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Workbook.getSelectedRange:
  - |-
    Excel.run(function (ctx) { 
        var selectedRange = ctx.workbook.getSelectedRange();
        selectedRange.load('address');
        return ctx.sync().then(function() {
                console.log(selectedRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Worksheet.activate:
  - |-
    Excel.run(function (ctx) { 
        var wSheetName = 'Sheet1';
        var worksheet = ctx.workbook.worksheets.getItem(wSheetName);
        worksheet.activate();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Worksheet.delete:
  - |-
    Excel.run(function (ctx) { 
        var wSheetName = 'Sheet1';
        var worksheet = ctx.workbook.worksheets.getItem(wSheetName);
        worksheet.delete();
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Worksheet.getCell:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var cell = worksheet.getCell(0,0);
        cell.load('address');
        return ctx.sync().then(function() {
            console.log(cell.address);
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Worksheet.getRange:
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeAddress = "A1:F8";
        var worksheet = ctx.workbook.worksheets.getItem(sheetName);
        var range = worksheet.getRange(rangeAddress);
        range.load('cellCount');
        return ctx.sync().then(function() {
            console.log(range.cellCount);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var sheetName = "Sheet1";
        var rangeName = 'MyRange';
        var range = ctx.workbook.worksheets.getItem(sheetName).getRange(rangeName);
        range.load('address');
        return ctx.sync().then(function() {
            console.log(range.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getActiveWorksheet();

        // To create a Range with multiple child areas, pass a 
        // comma-delimited string of range addresses to 
        // Worksheet.getRange.
        const range = sheet.getRange("F3:F5, H3:H5");
        range.format.fill.color = "pink";

        await context.sync();
    });
Excel.Worksheet.getUsedRange:
  - |-
    Excel.run(function (ctx) { 
        var wSheetName = 'Sheet1';
        var worksheet = ctx.workbook.worksheets.getItem(wSheetName);
        var usedRange = worksheet.getUsedRange();
        usedRange.load('address');
        return ctx.sync().then(function() {
                console.log(usedRange.address);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.Worksheet.load:
  - |-
    Excel.run(function (ctx) { 
        var wSheetName = 'Sheet1';
        var worksheet = ctx.workbook.worksheets.getItem(wSheetName);
        worksheet.load('position')
        return ctx.sync().then(function() {
                console.log(worksheet.position);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function (ctx) { 
        var wSheetName = 'Sheet1';
        var worksheet = ctx.workbook.worksheets.getItem(wSheetName);
        worksheet.position = 2;
        return ctx.sync(); 
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.WorksheetCollection.add:
  - |-
    Excel.run(function (ctx) { 
        var wSheetName = 'Sample Name';
        var worksheet = ctx.workbook.worksheets.add(wSheetName);
        worksheet.load('name');
        return ctx.sync().then(function() {
            console.log(worksheet.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.WorksheetCollection.getActiveWorksheet:
  - |-
    Excel.run(function (ctx) {  
        var activeWorksheet = ctx.workbook.worksheets.getActiveWorksheet();
        activeWorksheet.load('name');
        return ctx.sync().then(function() {
                console.log(activeWorksheet.name);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.WorksheetCollection.load:
  - |-
    Excel.run(function (ctx) { 
        var worksheets = ctx.workbook.worksheets;
        worksheets.load('items');
        return ctx.sync().then(function() {
            for (var i = 0; i < worksheets.items.length; i++)
            {
                console.log(worksheets.items[i].name);
                console.log(worksheets.items[i].index);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.WorksheetProtection.protect:
  - |-
    Excel.run(function(ctx) {
      // get a reference to Sheet1
      var sheet = ctx.workbook.worksheets.getItem("Sheet1");

      // Protect inserting or deleting rows in Sheet1
      sheet.protection.protect({
        allowInsertRows: false,
        allowDeleteRows: false
      });

      return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Excel.WorksheetProtection.unprotect:
  - |-
    Excel.run(function(ctx) {
      // get a reference to Sheet1
      var sheet = ctx.workbook.worksheets.getItem("Sheet1");

      // Remove all protects applied to Sheet1
      sheet.protection.unprotect();

      return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Excel.run(function(ctx) {
      var sheet = ctx.workbook.worksheets.getItem("Sheet1");
      sheet.protection.protect({
        allowInsertRows: false, // Protect row insertion
        allowDeleteRows: true // Unprotect row deletion
      });
    });
OneNote.Application.getActiveNotebook:
  - |-
    OneNote.run(function (context) {
            
        // Get the active notebook.
        var notebook = context.application.getActiveNotebook();
                
        // Queue a command to load the notebook. 
        // For best performance, request specific properties.           
        notebook.load('id,name');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                        
                // Show some properties.
                console.log("Notebook name: " + notebook.name);
                console.log("Notebook ID: " + notebook.id);
                
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.getActiveNotebookOrNull:
  - |-
    OneNote.run(function (context) {

        // Get the active notebook.
        var notebook = context.application.getActiveNotebookOrNull();

        // Queue a command to load the notebook. 
        // For best performance, request specific properties.           
        notebook.load('id,name');

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // check if active notebook is set.
                if (!notebook.isNull) {
                    console.log("Notebook name: " + notebook.name);
                    console.log("Notebook ID: " + notebook.id);
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.getActiveOutline:
  - |-
    OneNote.run(function (context) {

        // get active outline.
        var outline = context.application.getActiveOutline();

        // Queue a command to load the id of the outline.         
        outline.load('id');

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Show some properties.
                console.log("outline id: " + outline.id);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.getActiveOutlineOrNull:
  - |-
    OneNote.run(function (context) {

        // get active outline.
        var outline = context.application.getActiveOutlineOrNull();

        // Queue a command to load the id of the outline.         
        outline.load('id');

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                if (!outline.isNull) {
                    console.log("outline id: " + outline.id);
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.getActivePage:
  - |-
    OneNote.run(function (context) {
            
        // Get the active page.
        var page = context.application.getActivePage();
                
        // Queue a command to load the page. 
        // For best performance, request specific properties.           
        page.load('id,title');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                        
                // Show some properties.
                console.log("Page title: " + page.title);
                console.log("Page ID: " + page.id);
                
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.getActivePageOrNull:
  - |-
    OneNote.run(function (context) {

        // Get the active page.
        var page = context.application.getActivePageOrNull();

        // Queue a command to load the page. 
        // For best performance, request specific properties.           
        page.load('id,title');

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                
                if (!page.isNull) {
                    // Show some properties.
                    console.log("Page title: " + page.title);
                    console.log("Page ID: " + page.id);
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.getActiveSection:
  - |-
    OneNote.run(function (context) {
            
        // Get the active section.
        var section = context.application.getActiveSection();
                
        // Queue a command to load the section. 
        // For best performance, request specific properties.           
        section.load('id,name');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                        
                // Show some properties.
                console.log("Section name: " + section.name);
                console.log("Section ID: " + section.id);
                
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.getActiveSectionOrNull:
  - |-
    OneNote.run(function (context) {

        // Get the active section.
        var section = context.application.getActiveSectionOrNull();

        // Queue a command to load the section. 
        // For best performance, request specific properties.           
        section.load('id,name');

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                if (!section.isNull) {
                    // Show some properties.
                    console.log("Section name: " + section.name);
                    console.log("Section ID: " + section.id);
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.navigateToPage:
  - |-
    OneNote.run(function (context) {
            
        // Get the pages in the current section.
        var pages = context.application.getActiveSection().pages;
                
        // Queue a command to load the pages. 
        // For best performance, request specific properties.           
        pages.load('id');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                        
                // This example loads the first page in the section.
                var page = pages.items[0];
                            
                // Open the page in the application.                    
                context.application.navigateToPage(page);
                        
                // Run the queued command.
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Application.navigateToPageWithClientUrl:
  - |-
    OneNote.run(function (context) {

        // Get the pages in the current section.
        var pages = context.application.getActiveSection().pages;

        // Queue a command to load the pages. 
        // For best performance, request specific properties.           
        pages.load('clientUrl');

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // This example loads the first page in the section.
                var page = pages.items[0];

                // Open the page in the application.                    
                context.application.navigateToPageWithClientUrl(page.clientUrl);

                // Run the queued command.
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.FloatingInk.load:
  - |-
    OneNote.run(function(context) {

        // Gets the active page.
        var page = context.application.getActivePage();
        var contents = page.contents;
        
        // Load page contents and their types.
        page.load('contents/type');
        return context.sync()
            .then(function(){
            
                // Load every ink content.
                $.each(contents.items, function(i, content) {
                    if (content.type == "Ink")
                    {
                        content.load('ink/id');
                    }                            
                })
                return context.sync();
            })
            .then(function(){
            
                // Log ID of every ink content.
                $.each(contents.items, function(i, content) {
                    if (content.type == "Ink")
                    {
                        console.log(content.ink.id);
                    }                            
                })                
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.Image.getBase64Image:
  - |-

    var image = null;
    var imageString;

    OneNote.run(function(ctx){
        // Get the current outline.         
        var outline = ctx.application.getActiveOutline();
        
        // Queue a command to load paragraphs and their types. 
        outline.load("paragraphs/type")
        return ctx.sync().
            then(function(){
                for (var i=0; i < outline.paragraphs.items.length; i++)
                {
                    var paragraph = outline.paragraphs.items[i];
                    if (paragraph.type == "Image")
                    {
                        image = paragraph.image;
                    }
                }
            })
            .then(function(){
                if (image != null)
                {
                    imageString = image.getBase64Image();
                    return ctx.sync();
                }
            })
            .then(function(){
                console.log(imageString);
            });
    });
OneNote.Image.load:
  - |-
    OneNote.run(function(ctx){
        // Get the current outline.         
        var outline = ctx.application.getActiveOutline();
        var image = null;
        
        // Queue a command to load paragraphs and their types. 
        outline.load("paragraphs/type")
        return ctx.sync().
            then(function(){
                for (var i=0; i < outline.paragraphs.items.length; i++)
                {
                    var paragraph = outline.paragraphs.items[i];
                    if (paragraph.type == "Image")
                    {
                        image = paragraph.image;
                    }
                }
            })
            .then(function(){
                if (image != null)
                {
                    // load every properties and relationships
                    ctx.load(image);
                    return ctx.sync();
                }
            })
            .then(function(){
                if (image != null)
                {                   
                    console.log("image " + image.id + " width is " + image.width + " height is " + image.height);
                    console.log("description: " + image.description);                   
                    console.log("hyperlink: " + image.hyperlink);
                }
            });
    });
  - |-
    var image = null;

    OneNote.run(function(ctx){
        // Get the current outline.
        var outline = ctx.application.getActiveOutline();

        // Queue a command to load paragraphs and their types.
        outline.load("paragraphs")
        return ctx.sync().
            then(function(){
                for (var i=0; i < outline.paragraphs.items.length; i++)
                {
                    var paragraph = outline.paragraphs.items[i];
                    if (paragraph.type == "Image")
                    {
                        image = paragraph.image;
                    }
                }
                if (image != null)
                {
                   image.load("ocrData");
                }
                return ctx.sync();
            })
            .then(function(){
                console.log(image.ocrData);
            });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function(ctx){
        // Get the current outline.         
        var outline = ctx.application.getActiveOutline();
        var searchedParagraph = null;
        
        // Queue a command to load paragraphs and their types. 
        outline.load("paragraphs/type")
        return ctx.sync().
            then(function() {
                for (var i=0; i < outline.paragraphs.items.length; i++)
                {
                    var paragraph = outline.paragraphs.items[i];
                    if (paragraph.type == "Image")
                    {
                        searchedParagraph = paragraph;
                        break;
                    }
                }
            })
            .then(function() {
                if (searchedParagraph != null)
                {
                    // load every properties and relationships
                    searchedParagraph.image.load('paragraph');
                    return ctx.sync();
                }
            })
            .then(function() {
                if (searchedParagraph != null)
                {                   
                    if (searchedParagraph.id != searchedParagraph.image.paragraph.id)
                    {
                        console.log("id must match");
                    }
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.ImageOcrData.load:
  - |-
    var image = null;

    OneNote.run(function(ctx){
        // Get the current outline.
        var outline = ctx.application.getActiveOutline();

        // Queue a command to load paragraphs and their types.
        outline.load("paragraphs")
        return ctx.sync().
            then(function(){
                for (var i=0; i < outline.paragraphs.items.length; i++)
                {
                    var paragraph = outline.paragraphs.items[i];
                    if (paragraph.type == "Image")
                    {
                        image = paragraph.image;
                    }
                }
                if (image != null)
                {
                   image.load("ocrData");
                }
                return ctx.sync();
            })
            .then(function(){
                
                // Log ocrText and ocrLanguageId
                console.log(image.ocrData.ocrText);
                console.log(image.ocrData.ocrLanguageId);
            });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.InkAnalysis.load:
  - |-
    OneNote.run(function (ctx) {        
        var app = ctx.application;
        
        // Gets the active page.
        var page = app.getActivePage();
        
        // Load ink paragraphs.
        page.load('inkAnalysisOrNull/paragraphs');
        
        return ctx.sync()
            .then(function() {
                console.log(page.inkAnalysisOrNull.paragraphs.items.length);
            })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.InkAnalysisLine.load:
  - |-
    OneNote.run(function (ctx) {        
        var app = ctx.application;
        
        // Gets the active page.
        var page = app.getActivePage();
        page.load('inkAnalysisOrNull/paragraphs/lines/words');
        
        return ctx.sync()
            .then(function() {
                var inkParagraphs = page.inkAnalysisOrNull.paragraphs;
                $.each(inkParagraphs.items, function(i, inkParagraph) {
                    var inkLines = inkParagraph.lines;
                    $.each(inkLines.items, function(j, inkLine) {
                        // Word counts in a line.
                        console.log(inkLine.words.items.length);
                    })
                })
            })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.InkAnalysisParagraph.load:
  - |-
    OneNote.run(function (ctx) {        
        var app = ctx.application;
        
        // Gets the active page.
        var page = app.getActivePage();
        
        // Load a line of ink words.
        page.load('inkAnalysisOrNull/paragraphs/lines');
        
        return ctx.sync()
            .then(function() {
                var inkParagraphs = page.inkAnalysisOrNull.paragraphs;
                
                // Log id of each line in ink paragraphs.
                $.each(inkParagraphs.items, function(i, inkParagraph){
                    var inkLines = inkParagraph.lines;
                    $.each(inkLines.items, function (j, inkLine) {
                        console.log(inkLine.id);
                    })
                })
            })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.InkAnalysisWord.load:
  - |-
    OneNote.run(function (ctx) {        
        var app = ctx.application;
        
        // Gets the active page.
        var page = app.getActivePage();
        
        page.load('inkAnalysisOrNull/paragraphs/lines/words');
        return ctx.sync()
            .then(function() {
                var inkParagraphs = page.inkAnalysisOrNull.paragraphs;
                $.each(inkParagraphs.items, function(i, inkParagraph) {
                    var inkLines = inkParagraph.lines;
                    $.each(inkLines.items, function(j, inkLine) {
                        var inkWords = inkLine.words;
                        $.each(inkWords.items, function(k, inkWord) {
                        
                            // Log language Id of the word
                            console.log(inkWord.languageId);
                            
                            // Log every ink analyzed words.
                            $.each(inkWord.wordAlternates, function(l, word) {
                                console.log(word);                                    
                            })
                        })
                    })
                })
            })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.Notebook.addSection:
  - |-
    OneNote.run(function (context) {

        // Gets the active notebook.
        var notebook = context.application.getActiveNotebook();

        // Queue a command to add a new section. 
        var section = notebook.addSection("Sample section");
        
        // Queue a command to load the new section. This example reads the name property later.
        section.load("name");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                console.log("New section name is " + section.name);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.Notebook.addSectionGroup:
  - |-
    OneNote.run(function (context) {

        // Gets the active notebook.
        var notebook = context.application.getActiveNotebook();

        // Queue a command to add a new section group.
        var sectionGroup = notebook.addSectionGroup("Sample section group");

        // Queue a command to load the new section group.
        sectionGroup.load();

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                console.log("New section group name is " + sectionGroup.name);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.Notebook.getRestApiId:
  - |-
    OneNote.run(function(ctx){
        // Get the current notebook.         
        var notebook = ctx.application.getActiveNotebook();
        var restApiId = notebook.getRestApiId();

        return ctx.sync().
            then(function(){
                console.log("The REST API ID is " + restApiId.value);
                // Note that the REST API ID isn't all you need to interact with the OneNote REST API. For SharePoint notebooks, the notebook baseUrl should be used to talk to the OneNote REST API according to [OneNote Development Blog](https://blogs.msdn.microsoft.com/onenotedev/2015/06/11/and-sharepoint-makes-three/)
                // (this is only required for SharePoint notebooks, baseUrl will be null for OneDrive notebooks)
            });
    });
OneNote.Notebook.load:
  - |-
    OneNote.run(function (context) {
            
        // Get the current notebook.
        var notebook = context.application.getActiveNotebook();
                
        // Queue a command to load the notebook. 
        // For best performance, request specific properties.           
        notebook.load('baseUrl');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                console.log("Base url: " + notebook.baseUrl);
                // This baseUrl should be used to talk to OneNote REST APIs according to https://blogs.msdn.microsoft.com/onenotedev/2015/06/11/and-sharepoint-makes-three/ (only required for SharePoint notebooks, will be null for OneDrive notebooks)
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {
            
        // Get the current notebook.
        var notebook = context.application.getActiveNotebook();
                
        // Queue a command to load the notebook. 
        // For best performance, request specific properties.           
        notebook.load('id');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                console.log("Notebook ID: " + notebook.id);
                
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {
            
        // Get the current notebook.
        var notebook = context.application.getActiveNotebook();
                
        // Queue a command to load the notebook. 
        // For best performance, request specific properties.           
        notebook.load('name');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                console.log("Notebook name: " + notebook.name);
                
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {

        // Get the section groups in the notebook. 
        var sectionGroups = context.application.getActiveNotebook().sectionGroups;

        // Queue a command to load the sectionGroups. 
        sectionGroups.load("name");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                $.each(sectionGroups.items, function(index, sectionGroup) {
                    console.log("Section group name: " + sectionGroup.name);
                });
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {

        // Gets the active notebook.
        var notebook = context.application.getActiveNotebook();
        
        // Queue a command to get immediate child sections of the notebook. 
        var childSections = notebook.sections;

        // Queue a command to load the childSections. 
        context.load(childSections);

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                $.each(childSections.items, function(index, childSection) {
                    console.log("Immediate child section name: " + childSection.name);
                });            
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });   
OneNote.NotebookCollection.getByName:
  - |-
    OneNote.run(function (context) {

        // Get the notebooks that are open in the application instance and have the specified name.
        var notebooks = context.application.notebooks.getByName("Homework");

        // Queue a command to load the notebooks. 
        // For best performance, request specific properties.           
        notebooks.load("id,name");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Iterate through the collection or access items individually by index, for example: notebooks.items[0]
                if (notebooks.items.length > 0) {
                    console.log("Notebook name: " + notebooks.items[0].name);
                    console.log("Notebook ID: " + notebooks.items[0].id);
                }
                    
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.NotebookCollection.load:
  - |-
    OneNote.run(function (context) {

        // Get the notebooks that are open in the application instance and have the specified name.
        var notebooks = context.application.notebooks.getByName("Homework");

        // Queue a command to load the notebooks. 
        // For best performance, request specific properties.           
        notebooks.load("id");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Iterate through the collection or access items individually by index, for example: notebooks.items[0]
                $.each(notebooks.items, function(index, notebook) {
                    notebook.addSection("Biology");
                    notebook.addSection("Spanish");
                    notebook.addSection("Computer Science");
                });
                
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Outline.appendHtml:
  - |-
    OneNote.run(function (context) {

        // Gets the active page.
        var activePage = context.application.getActivePage();

        // Get pageContents of the activePage. 
        var pageContents = activePage.contents;

        // Queue a command to load the pageContents to access its data.
        context.load(pageContents);

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                if (pageContents.items.length != 0 && pageContents.items[0].type == "Outline")
                {
                    // First item is an outline.
                    outline = pageContents.items[0].outline;

                    // Queue a command to append a paragraph to the outline.
                    outline.appendHtml("<p>new paragraph</p>");

                    // Run the queued commands.
                    return context.sync();
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Outline.appendTable:
  - |-
    OneNote.run(function (context) {

        // Gets the active page.
        var activePage = context.application.getActivePage();

        // Get pageContents of the activePage. 
        var pageContents = activePage.contents;

        // Queue a command to load the pageContents to access its data.
        context.load(pageContents);

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                if (pageContents.items.length != 0 && pageContents.items[0].type == "Outline") {
                    // First item is an outline.
                    var outline = pageContents.items[0].outline;

                    // Queue a command to append a paragraph to the outline.
                    outline.appendTable(2, 2, [[1, 2],[3, 4]]);

                    // Run the queued commands.
                    return context.sync();
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Page.addOutline:
  - |-
    OneNote.run(function (context) {

        // Gets the active page.
        var page = context.application.getActivePage();

        // Queue a command to add an outline with given html. 
        var outline = page.addOutline(200, 200,
    "<p>Images and a table below:</p> \
     <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\"> \
     <img src=\"http://imagenes.es.sftcdn.net/es/scrn/6653000/6653659/microsoft-onenote-2013-01-535x535.png\"> \
     <table> \
       <tr> \
         <td>Jill</td> \
         <td>Smith</td> \
         <td>50</td> \
       </tr> \
       <tr> \
         <td>Eve</td> \
         <td>Jackson</td> \
         <td>94</td> \
       </tr> \
     </table>"     
            );

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .catch(function(error) {
                console.log("Error: " + error);
                if (error instanceof OfficeExtension.Error) {
                    console.log("Debug info: " + JSON.stringify(error.debugInfo));
                }
            });
    });
OneNote.Page.copyToSection:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        
        // Gets the active notebook.
        var notebook = app.getActiveNotebook();
        
        // Gets the active page.
        var page = app.getActivePage();
        
        // Queue a command to load sections under the notebook.
        notebook.load('sections');
        
        var newPage;
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync()
            .then(function() {
                var section = notebook.sections.items[0];
                
                // copy page to the section.
                newPage = page.copyToSection(section);
                newPage.load('id');
                return ctx.sync();
            })
            .then(function() {
                console.log(newPage.id);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Page.getRestApiId:
  - |-
    OneNote.run(function(ctx){
        // Get the current page.         
        var page = ctx.application.getActivePage();
        var restApiId = page.getRestApiId();

        return ctx.sync().
            then(function(){
                console.log("The REST API ID is " + restApiId.value);
                // Note that the REST API ID isn't all you need to interact with the OneNote REST API. For SharePoint notebooks, the notebook baseUrl should be used to talk to the OneNote REST API according to [OneNote Development Blog](https://blogs.msdn.microsoft.com/onenotedev/2015/06/11/and-sharepoint-makes-three/)
                // (this is only required for SharePoint notebooks, baseUrl will be null for OneDrive notebooks)
            });
    });
OneNote.Page.insertPageAsSibling:
  - |-
    OneNote.run(function (context) {

        // Gets the active page.
        var activePage = context.application.getActivePage();

        // Queue a command to add a new page after the active page. 
        var newPage = activePage.insertPageAsSibling("After", "Next Page");

        // Queue a command to load the newPage to access its data.
        context.load(newPage);

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                console.log("page is created with title: " + newPage.title);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Page.load:
  - |-
    OneNote.run(function (context) {

        // Gets the active page.
        var activePage = context.application.getActivePage();

        // Queue a command to add a new page after the active page. 
        var pageContents = activePage.contents;

        // Queue a command to load the pageContents to access its data.
        context.load(pageContents);

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                for(var i=0; i < pageContents.items.length; i++)
                {
                    var pageContent = pageContents.items[i];
                    if (pageContent.type == "Outline")
                    {
                        console.log("Found an outline");
                    }
                    else if (pageContent.type == "Image")
                    {
                        console.log("Found an image");
                    }
                    else if (pageContent.type == "Other")
                    {
                        console.log("Found a type not supported yet.");
                    }
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {

        var app = context.application;
        
        // Gets the active page.
        var page = app.getActivePage();
        
        // Queue a command to load the webUrl of the page.
        page.load("webUrl");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                console.log(page.webUrl);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (ctx) {        
        var app = ctx.application;
        
        // Gets the active page.
        var page = app.getActivePage();
        
        // Load ink words
        page.load('inkAnalysisOrNull/paragraphs/lines/words');
        
        return ctx.sync()
            .then(function() {
                if (!page.inkAnalysisOrNull.isNull)
                    console.log(page.inkAnalysisOrNull.paragraphs.length);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.PageCollection.getByTitle:
  - |-
    OneNote.run(function (context) {

        // Get all the pages in the current section.
        var allPages = context.application.getActiveSection().pages;

        // Queue a command to load the pages. 
        // For best performance, request specific properties.
        allPages.load("id"); 

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Get the sections with the specified name.
                var todoPages = allPages.getByTitle("Todo list");

                // Queue a command to load the section. 
                // For best performance, request specific properties.
                todoPages.load("id,title"); 

                return context.sync()
                    .then(function () {

                        // Iterate through the collection or access items individually by index.
                        if (todoPages.items.length > 0) {
                            console.log("Page title: " + todoPages.items[0].title);
                            console.log("Page ID: " + todoPages.items[0].id);
                        }
                    });
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.PageCollection.load:
  - |-
    OneNote.run(function (context) {
        
        // Get the pages in the current section.
        var pages = context.application.getActiveSection().pages;
        
        // Queue a command to load the id and title for each page.            
        pages.load('id,title');
        
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                
                // Display the properties.
                $.each(pages.items, function(index, page) {
                    console.log(page.title);
                    console.log(page.id);
                });
            }); 
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.PageContent.delete:
  - |-
    OneNote.run(function (context) {

        var page = context.application.getActivePage();
        var pageContents = page.contents;

        var firstPageContent = pageContents.getItemAt(0);
        firstPageContent.load('type');

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                if(firstPageContent.isNull === false) {
                    firstPageContent.delete();
                    return context.sync();
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.PageContentCollection.getItemAt:
  - |-
    OneNote.run(function (context) {

        var page = context.application.getActivePage();
        var pageContents = page.contents;
        var firstPageContent = pageContents.getItemAt(0);
        firstPageContent.load('type');

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                console.log("The first page content item is of type: " + firstPageContent.type);
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.PageContentCollection.load:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Queue a command to load the type of each pageContent.
        pageContents.load("type");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                $.each(pageContents.items, function(index, pageContent) {
                    console.log("PageContent type: " + pageContent.type);
                });
            });
    })                
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {
       var page = context.application.getActivePage();
       var pageContents = page.contents;
       pageContents.load('type');
       var outlines = ;
       return context.sync()
           .then(function () {      
                  $.each(pageContents.items, function (index, pageContent) {
                         console.log(pageContent.type);
                         if (pageContent.type === 'Outline') {
                               outlines.push(pageContent);
                         }
                  });
                  $.each(outlines, function (index, outline) {
                         outline.load("id,paragraphs,paragraphs/type");
                  });
                  return context.sync();
           })
           .then(function () {
                  $.each(outlines, function (index, outline) {
                         console.log("An outline was found with id : " + outline.id);
                  });
                  return Promise.resolve(outlines);
           });
    });
OneNote.Paragraph.delete:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Get the first PageContent on the page
        // Assuming its an outline, get the outline's paragraphs.
        var pageContent = pageContents.getItemAt(0);
        
        var paragraphs = pageContent.outline.paragraphs;
        
        var firstParagraph = paragraphs.getItemAt(0);
        
        // Queue a command to load the id and type of the first paragraph
        firstParagraph.load("id,type");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                
                // Queue a command to delete the first paragraph                 
                firstParagraph.delete();
                
                // Run the command to delete it
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Paragraph.insertHtmlAsSibling:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Get the first PageContent on the page
        // Assuming its an outline, get the outline's paragraphs.
        var pageContent = pageContents.getItemAt(0);
        var paragraphs = pageContent.outline.paragraphs;
        var firstParagraph = paragraphs.getItemAt(0);

        // Queue a command to load the id and type of the first paragraph
        firstParagraph.load("id,type");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Queue commands to insert before and after the first paragraph
                firstParagraph.insertHtmlAsSibling("Before", "<p>ContentBeforeFirstParagraph</p>");
                firstParagraph.insertHtmlAsSibling("After", "<p>ContentAfterFirstParagraph</p>");
                
                // Run the command to run inserts
                return context.sync();
            });
    ))
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Paragraph.insertImageAsSibling:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Get the first PageContent on the page
        // Assuming its an outline, get the outline's paragraphs.
        var pageContent = pageContents.getItemAt(0);
        var paragraphs = pageContent.outline.paragraphs;
        var firstParagraph = paragraphs.getItemAt(0);

        // Queue a command to load the id and type of the first paragraph
        firstParagraph.load("id,type");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Queue commands to insert before and after the first paragraph
                firstParagraph.insertImageAsSibling("Before", "R0lGODlhDwAPAKECAAAAzMzM/////wAAACwAAAAADwAPAAACIISPeQHsrZ5ModrLlN48CXF8m2iQ3YmmKqVlRtW4MLwWACH+H09wdGltaXplZCBieSBVbGVhZCBTbWFydFNhdmVyIQAAOw==");
                firstParagraph.insertImageAsSibling("After", "R0lGODlhDwAPAKECAAAAzMzM/////wAAACwAAAAADwAPAAACIISPeQHsrZ5ModrLlN48CXF8m2iQ3YmmKqVlRtW4MLwWACH+H09wdGltaXplZCBieSBVbGVhZCBTbWFydFNhdmVyIQAAOw==");
                
                // Run the command to insert images
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Paragraph.insertRichTextAsSibling:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Get the first PageContent on the page
        // Assuming its an outline, get the outline's paragraphs.
        var pageContent = pageContents.getItemAt(0);
        var paragraphs = pageContent.outline.paragraphs;
        var firstParagraph = paragraphs.getItemAt(0);

        // Queue a command to load the id and type of the first paragraph
        firstParagraph.load("id,type");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Queue commands to insert before and after the first paragraph
                firstParagraph.insertRichTextAsSibling("Before", "Text Appears Before Paragraph");
                firstParagraph.insertRichTextAsSibling("After", "Text Appears After Paragraph");
                
                // Run the command to insert text contents
                return context.sync();
            });
    })    
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.Paragraph.load:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;
        
        // Queue a command to load the outline property of each pageContent.
        pageContents.load("outline");
            
        // Get the first PageContent on the page, and then get its Outline.
        var pageContent = pageContents._GetItem(0);
        var paragraphs = pageContent.outline.paragraphs;
                
        // Queue a command to load the id and type of each paragraph.
        paragraphs.load("id,type");
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                
                // Write the text.                  
                $.each(paragraphs.items, function(index, paragraph) {
                    console.log("Paragraph type: " + paragraph.type);
                    console.log("Paragraph ID: " + paragraph.id);
                });
            });
    })        
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
  - |-
    OneNote.run(function(context) {
        var app = context.application;
        
        // Gets the active outline
        var outline = app.getActiveOutline();
        
        // load nested paragraphs and their types.
        outline.load("paragraphs/type");
        
        return context.sync().then(function () {
            var paragraphs = outline.paragraphs.items;
            
            var promise;
            // for each nested paragraphs, load tables only
            for (var i = 0; i < paragraphs.length; i++) {
                var paragraph = paragraphs[i];
                if (paragraph.type == "Table") {
                    paragraph.load("table/id");
                    promise =  context.sync().then(function() {
                        console.log(paragraph.table.id);
                    });
                }
            }
            return promise;
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.ParagraphCollection.getItemAt:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Get the first PageContent on the page, and then get its Outline's first paragraph.
        var pageContent = pageContents.getItemAt(0);
        var paragraphs = pageContent.outline.paragraphs;

        var firstParagraph = paragraphs.getItemAt(0);

        // Queue a command to load the type and richText.text property of this paragraph.
        firstParagraph.load("id,type");


        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                // Write text from paragraph to console
                console.log("First Paragraph found with id : " + firstParagraph.id + " and type " + firstParagraph.type);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.ParagraphCollection.load:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Get the first PageContent on the page, and then get its Outline's first paragraph.
        var pageContent = pageContents.getItem(0);
        var paragraphs = pageContent.outline.paragraphs;
        
        // Queue a command to load the id and type of each paragraph.
        paragraphs.load("id,type");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                var firstParagraph = paragraphs.items[0];
                // Write text from first paragraph to console
                console.log("First Paragraph found with id : " + firstParagraph.id + " and type " + firstParagraph.type);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Get the first PageContent on the page, and then get its outline's paragraphs.
        var outlinePageContents = ;
        var paragraphs = ;
        var richTextParagraphs = ;
        // Queue a command to load the id and type of each page content in the outline.
        pageContents.load("id,type");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                // Load all page contents of type Outline
                $.each(pageContents.items, function(index, pageContent) {
                    if(pageContent.type == 'Outline')
                    {
                        pageContent.load('outline,outline/paragraphs,outline/paragraphs/type');
                        outlinePageContents.push(pageContent);
                    }
                });
                return context.sync();
            })
            .then(function () {
                // Load all rich text paragraphs across outlines
                $.each(outlinePageContents, function(index, outlinePageContent) {
                    var outline = outlinePageContent.outline;
                    paragraphs = paragraphs.concat(outline.paragraphs.items);
                });
                $.each(paragraphs, function(index, paragraph) {
                    if(paragraph.type == 'RichText')
                    {
                        richTextParagraphs.push(paragraph);
                        paragraph.load("id,richText/text");
                    }
                });
                return context.sync();
            })
            .then(function () {
                // Display all rich text paragraphs to the console
                $.each(richTextParagraphs, function(index, richTextParagraph) {
                    var richText = richTextParagraph.richText;
                    console.log("Paragraph found with richtext content : " + richText.text + " and richtext id : " + richText.id);
                });
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.RichText.load:
  - |-
    OneNote.run(function (context) {

        // Get the collection of pageContent items from the page.
        var pageContents = context.application.getActivePage().contents;

        // Get the first PageContent on the page, and then get its outline's paragraphs.
        var outlinePageContents = ;
        var paragraphs = ;
        var richTextParagraphs = ;
        // Queue a command to load the id and type of each page content in the outline.
        pageContents.load("id,type");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                // Load all page contents of type Outline
                $.each(pageContents.items, function(index, pageContent) {
                    if(pageContent.type == 'Outline')
                    {
                        pageContent.load('outline,outline/paragraphs,outline/paragraphs/type');
                        outlinePageContents.push(pageContent);
                    }
                });
                return context.sync();
            })
            .then(function () {
                // Load all rich text paragraphs across outlines
                $.each(outlinePageContents, function(index, outlinePageContent) {
                    var outline = outlinePageContent.outline;
                    paragraphs = paragraphs.concat(outline.paragraphs.items);
                });
                $.each(paragraphs, function(index, paragraph) {
                    if(paragraph.type == 'RichText')
                    {
                        richTextParagraphs.push(paragraph);
                        paragraph.load("id,richText/text");
                    }
                });
                return context.sync();
            })
            .then(function () {
                // Display all rich text paragraphs to the console
                $.each(richTextParagraphs, function(index, richTextParagraph) {
                    var richText = richTextParagraph.richText;
                    console.log("Paragraph found with richtext content : " + richText.text + " and richtext id : " + richText.id);
                });
                return context.sync();
            });
    });
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.Section.addPage:
  - |-
    OneNote.run(function (context) {
                
        // Queue a command to add a page to the current section.
        var page = context.application.getActiveSection().addPage("Wish list");
                
        // Queue a command to load the id and title of the new page. 
        // This example loads the new page so it can read its properties later.           
        page.load('id,title');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                 
                // Display the properties.       
                console.log("Page name: " + page.title);
                console.log("Page ID: " + page.id);

            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Section.copyToNotebook:
  - |-
    OneNote.run(function (context) {
        var app = context.application;
        
        // Gets the active Notebook.
        var notebook = app.getActiveNotebook();
        
        // Gets the active Section.
        var section = app.getActiveSection();
        
        var newSection;
        
        return context.sync()
            .then(function() {
                newSection = section.copyToNotebook(notebook);
                newSection.load('id');
                return context.sync();
            })
            .then(function() {
                console.log(newSection.id);
            });
    })
    .catch(function (error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Section.copyToSectionGroup:
  - |-
    OneNote.run(function (ctx) {
        var app = ctx.application;
        
        // Gets the active Notebook.
        var notebook = app.getActiveNotebook();
        
        // Gets the active Section.
        var section = app.getActiveSection();
        
        var newSection;
        
        return ctx.sync()
            .then(function() {
                var firstSectionGroup = notebook.sectionGroups.items[0];
                newSection = section.copyToSectionGroup(firstSectionGroup);
                newSection.load('id');
                return ctx.sync();
            })
            .then(function() {
                console.log(newSection.id);
            });
    })
    .catch(function (error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Section.insertSectionAsSibling:
  - |-
    OneNote.run(function (context) {
                
        // Queue a command to insert a section after the current section.
        var section = context.application.getActiveSection().insertSectionAsSibling("After", "New section");
                
        // Queue a command to load the id and name of the new section. 
        // This example loads the new section so it can read its properties later.           
        section.load('id,name');
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                 
                // Display the properties.       
                console.log("Section name: " + section.name);
                console.log("Section ID: " + section.id);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Section.getRestApiId:
  - |-
    OneNote.run(function(ctx){
        // Get the current section.         
        var section = ctx.application.getActiveSection();
        var restApiId = section.getRestApiId();

        return ctx.sync().
            then(function(){
                console.log("The REST API ID is " + restApiId.value);
                // Note that the REST API ID isn't all you need to interact with the OneNote REST API. For SharePoint notebooks, the notebook baseUrl should be used to talk to the OneNote REST API according to [OneNote Development Blog](https://blogs.msdn.microsoft.com/onenotedev/2015/06/11/and-sharepoint-makes-three/)
                // (this is only required for SharePoint notebooks, baseUrl will be null for OneDrive notebooks)
            });
    });
OneNote.Section.load:
  - |-
    OneNote.run(function (context) {
            
        // Get the current section.
        var section = context.application.getActiveSection();
                
        // Queue a command to load the section. 
        // For best performance, request specific properties.           
        section.load("id");
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                console.log("Section ID: " + section.id);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {
            
        // Get the current section.
        var section = context.application.getActiveSection();
                
        // Queue a command to load the section with the specified properties. 
        section.load("name,notebook/name");
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                console.log("Section name: " + section.name);
                console.log("Parent notebook name: " + section.notebook.name);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {
        // Queue a command to add a page to the current section.
        var section = context.application.getActiveSection();
        section.load('clientUrl,notebook');
        var sectionGroup = section.parentSectionGroupOrNull;
        
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                if(sectionGroup.isNull === false)
                {
                    // If a parent section group exists, queue a command to add a section in it!
                    sectionGroup.addSection("NewSectionInSectionGroup");
                }
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.SectionCollection.getByName:
  - |-
    OneNote.run(function (context) {

        // Get the sections in the current notebook.
        var sections = context.application.getActiveNotebook().sections;

        // Queue a command to load the sections. 
        // For best performance, request specific properties.
        sections.load("id"); 
        
        // Get the sections with the specified name.
        var groceriesSections = sections.getByName("Groceries");
        
        // Queue a command to load the sections with the specified name.
        groceriesSections.load("id,name");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Iterate through the collection or access items individually by index.
                if (groceriesSections.items.length > 0) {
                    console.log("Section name: " + groceriesSections.items[0].name);
                    console.log("Section ID: " + groceriesSections.items[0].id);
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.SectionCollection.load:
  - |-
    OneNote.run(function (context) {

        // Get the sections in the current notebook.
        var sections = context.application.getActiveNotebook().sections;

        // Queue a command to load the sections. 
        // For best performance, request specific properties.
        sections.load("name"); 

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                
                // Iterate through the collection or access items individually by index, for example: sections.items[0]
                $.each(sections.items, function(index, section) {
                    if (section.name === "Homework") {
                        section.addPage("Biology");
                        section.addPage("Spanish");
                        section.addPage("Computer Science");
                    }
                });
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.SectionGroup.addSection:
  - |-
    OneNote.run(function (context) {

        // Get the section groups that are direct children of the current notebook.
        var sectionGroups = context.application.getActiveNotebook().sectionGroups;
        
        // Queue a command to load the section groups.
        // For best performance, request specific properties.
        sectionGroups.load("id");

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                
                // Add a section to each section group.
                $.each(sectionGroups.items, function(index, sectionGroup) {
                    sectionGroup.addSection("Agenda");
                });
                
                // Run the queued commands.
                return context.sync();
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.SectionGroup.addSectionGroup:
  - |-
    OneNote.run(function (context) {
        var sectionGroup;
        var nestedSectionGroup;

        // Gets the active notebook.
        var notebook = context.application.getActiveNotebook();

        // Queue a command to add a new section group.
        var sectionGroups = notebook.sectionGroups;

        // Queue a command to load the new section group.
        sectionGroups.load();

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function(){
                sectionGroup = sectionGroups.items[0];
                sectionGroup.load();
                return context.sync();
            })
            .then(function(){
                nestedSectionGroup = sectionGroup.addSectionGroup("Sample nested section group");
                nestedSectionGroup.load();
                return context.sync();
            })
            .then(function() {
                console.log("New nested section group name is " + nestedSectionGroup.name);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    }); 
OneNote.SectionGroup.load:
  - |-
    OneNote.run(function (context) {
            
        // Get the parent section group that contains the current section.
        var sectionGroup = context.application.getActiveSection().parentSectionGroup;
                
        // Queue a command to load the section group. 
        // For best performance, request specific properties.           
        sectionGroup.load("id,name");
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                
                // Write the properties.
                console.log("Section group name: " + sectionGroup.name);
                console.log("Section group ID: " + sectionGroup.id);
                
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {
            
        // Get the parent section group that contains the current section.
        var sectionGroup = context.application.getActiveSection().parentSectionGroup;
                
        // Queue a command to load the section group with the specified properties.           
        sectionGroup.load("name,notebook/name"); 
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Write the properties.
                console.log("Section group name: " + sectionGroup.name);
                console.log("Parent notebook name: " + sectionGroup.notebook.name);
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {

        // Get the section groups that are direct children of the current notebook.
        var sectionGroups = context.application.getActiveNotebook().sectionGroups;

        // Queue a command to load the section groups.
        // For best performance, request specific properties.
        sectionGroups.load("name");
        
        // Get the child section groups of the first section group in the notebook.
        var nestedSectionGroups = sectionGroups._GetItem(0).sectionGroups;
        
        // Queue a command to load the ID and name properties of the child section groups.
        nestedSectionGroups.load("id,name");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                
                // Write the properties for each child section group.
                $.each(nestedSectionGroups.items, function(index, sectionGroup) {
                    console.log("Section group name: " + sectionGroup.name);  
                    console.log("Section group ID: " + sectionGroup.id);  
                });
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function (context) {

        // Get the sections that are siblings of the current section.
        var sections = context.application.getActiveSection().parentSectionGroup.sections;

        // Queue a command to load the section groups.
        // For best performance, request specific properties.
        sections.load("id,name");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function() {
                
                // Write the properties for each section.
                $.each(sections.items, function(index, section) {
                    console.log("Section name: " + section.name);  
                    console.log("Section ID: " + section.id);  
                });
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.SectionGroupCollection.getByName:
  - |-
    OneNote.run(function (context) {

        // Get the section groups that are direct children of the current notebook.
        var sectionGroups = context.application.getActiveNotebook().sectionGroups;

        // Queue a command to load the section groups. 
        // For best performance, request specific properties.
        sectionGroups.load("id"); 

        // Get the section groups with the specified name.
        var labsSectionGroups = sectionGroups.getByName("Labs");

        // Queue a command to load the section groups with the specified properties.
        labsSectionGroups.load("id,name"); 
                
        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {

                // Iterate through the collection or access items individually by index.
                if (labsSectionGroups.items.length > 0) {
                    console.log("Section group name: " + labsSectionGroups.items[0].name);
                    console.log("Section group ID: " + labsSectionGroups.items[0].id);
                }
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.SectionGroupCollection.load:
  - |-
    OneNote.run(function (context) {

        // Get the section groups that are direct children of the current notebook.
        var sectionGroups = context.application.getActiveNotebook().sectionGroups;

        // Queue a command to load the section groups. 
        // For best performance, request specific properties.
        sectionGroups.load("name"); 

        // Run the queued commands, and return a promise to indicate task completion.
        return context.sync()
            .then(function () {
                
                // Iterate through the collection or access items individually by index, for example: sectionGroups.items[0]
                $.each(sectionGroups.items, function(index, sectionGroup) {
                    console.log("Section group name: " + sectionGroup.name);  
                    console.log("Section group ID: " + sectionGroup.id);  
                });
            });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Table.appendColumn:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, append a column.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    table.appendColumn(["cell0", "cell1"]);
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Table.appendRow:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, append a column.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    var row = table.appendRow(["cell0", "cell1"]);
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Table.getCell:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, get a cell in the second row and third column.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    var cell = table.getCell(2 /*Row Index*/, 3 /*Column Index*/);
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Table.insertColumn:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, insert a column at index two.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    table.insertColumn(2, ["cell0", "cell1"]);
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Table.insertRow:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, insert a row at index two.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    var row = table.insertRow(2, ["cell0", "cell1"]);
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.Table.load:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // For each table, log properties.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    ctx.load(table);
                    return ctx.sync().then(function() {
                        console.log("Table Id: " + table.id);
                        console.log("Row Count: " + table.rowCount);
                        console.log("Column Count: " + table.columnCount);
                        return ctx.sync();
                    });
                }
            }
        });
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, log its paragraph id.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    ctx.load(table, "paragraph/id, rows/id");
                    return ctx.sync().then(function() {
                        console.log("Paragraph Id: " + table.paragraph.id);
                        var rows = table.rows;
                        
                        // for each rows in the table, log row index and id.
                        for (var i = 0; i < rows.items.length; i++) {
                            console.log("Row " + i + " Id: " + rows.items[i].id);
                        }
                        return ctx.sync();
                    });
                }
            }
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.TableCell.appendHtml:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, get a table cell at row one and column two and add "Hello".
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    var cell = table.getCell(1 /*Row Index*/, 2 /*Column Index*/);
                    cell.appendHtml("<p>Hello</p>");
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.TableCell.appendRichText:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        var appendedRichText = null;
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, get a table cell at row one and column two and add "Hello".
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    var cell = table.getCell(1 /*Row Index*/, 2 /*Column Index*/);
                    appendedRichText = cell.appendRichText("Hello");
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.TableCell.load:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, get a table cell at row one and column two.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    var cell = table.getCell(1 /*Row Index*/, 2 /*Column Index*/);
                    
                    // Queue a command to load the table cell.
                    ctx.load(cell);
                    ctx.sync().then(function() {
                        console.log("Cell Id: " + cell.id);
                        console.log("Cell Index: " + cell.cellIndex);
                        console.log("Cell's Row Index: " + cell.rowIndex);
                    });
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    ParentTable, ParentRow, Paragraphs
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, get a table cell at row one and column two.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    var cell = table.getCell(1 /*Row Index*/, 2 /*Column Index*/);
                    
                    // Queue a command to load parentTable, parentRow and paragraphs of the table cell.
                    ctx.load(cell, "parentTable, parentRow, paragraphs");
                    
                    ctx.sync().then(function() {
                        console.log("Parent Table Id: " + cell.parentTable.id);
                        console.log("Parent Row Id: " + cell.parentRow.id);
                        var paragraphs = cell.paragraphs;
                        
                        for (var i = 0; i < paragraphs.items.length; i++) {
                            console.log("Paragraph Id: " + paragraphs.items[i].id);
                        }
                    });
                }
            }
            return ctx.sync();
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.TableRow.insertRowAsSibling:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, get table rows.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    
                    // Queue a command to load table.rows.
                    ctx.load(table, "rows");
                    
                    // Run the queued commands
                    return ctx.sync().then(function() {
                        var rows = table.rows;
                        rows.items[1].insertRowAsSibling("Before", ["cell0", "cell1"]);
                        return ctx.sync();
                    });
                }
            }
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
OneNote.TableRow.load:
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, get table rows.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    
                    // Queue a command to load table.rows.
                    ctx.load(table, "rows");
                    return ctx.sync().then(function() {
                        var rows = table.rows;
                        
                        // for each table row, log cell count and row index.
                        for (var i = 0; i < rows.items.length; i++) {
                            console.log("Row " + i + " Id: " + rows.items[i].id);
                            console.log("Row " + i + " Cell Count: " + rows.items[i].cellCount);
                            console.log("Row " + i + " Row Index: " + rows.items[i].rowIndex);
                        }
                        return ctx.sync();
                    });
                }
            }
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    OneNote.run(function(ctx) {
        var app = ctx.application;
        var outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        ctx.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            var paragraphs = outline.paragraphs;
            
            // for each table, get table rows.
            for (var i = 0; i < paragraphs.items.length; i++) {
                var paragraph = paragraphs.items[i];
                if (paragraph.type == "Table") {
                    var table = paragraph.table;
                    
                    // Queue a command to load parentTable and cells of each row in the table.
                    ctx.load(table, "rows/parentTable, rows/cells");
                    return ctx.sync().then(function() {
                        var rows = table.rows;
                        
                        // for each row, log parentTable and cells
                        for (var i = 0; i < rows.items.length; i++) {
                            console.log("Row " + i + " Parent Table Id: " + rows.items[i].parentTable.id);
                            var cells = rows.items[i].cells;
                            for (var j = 0 ; j < cells.items.length; j++) {
                                console.log("Row " + i + " Cell " + j + " Id: " + cells.items[j].id);
                            }
                        }
                        return ctx.sync();
                    });
                }
            }
        })
    })
    .catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Office.Body.getAsync:
  - >-
    // This example gets the body of the message in plain text.

    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext:"This is passed to the callback" },
        function callback(result) {
            // Do something with the result
        });

    //The following is an example of the result parameter passed to the callback
    function.

    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.Body.prependAsync:
  - |-
    // DESCRIPTION EXAMPLE
    Office.context.mailbox.item.body.prependAsync(
        '<a id="LPNoLP" href="http://www.contoso.com">Click here!</a>',
        {coercionType: Office.CoercionType.Html},
        callback);
Office.Body.setAsync:
  - >-
    // DESCRIPTION EXAMPLE

    Office.context.mailbox.item.body.setAsync(
        '<a id="LPNoLP" href="http://www.contoso.com">Click here!</a>',
        {coercionType: Office.CoercionType.Html},
        callback);
    Office.context.mailbox.item.body.setAsync(
        "<b>(replaces all body, including threads you are replying to that may be on the bottom)</b>",
        { coercionType:"html", asyncContext:"This is passed to the callback" },
        function callback(result) {
            // Process the result
    });


    // The following is an example of the result parameter passed to the
    callback function.

    {
        "value":null,
        "status":"succeeded",
        "asyncContext":"This is passed to the callback"
    }
Office.Body.setSelectedDataAsync:
  - |-
    // DESCRIPTION EXAMPLE
    Office.context.mailbox.item.body.setSelectedDataAsync(
        '<a id="LPNoLP" href="http://www.contoso.com">Click here!</a>',
        {coercionType: Office.CoercionType.Html},
        callback);
Office.CustomProperties:
  - >-
    // The following example shows how to use the loadCustomPropertiesAsync
    method to asynchronously load custom properties that are specific to the
    current item. The example also shows how to use the saveAsync method to save
    these properties back to the server. After loading the custom properties,
    the example uses the get method to read the custom property myProp, the set
    method to write the custom property otherProp, and then finally calls the
    saveAsync method to save the custom properties.

    Office.initialize = function () {
        // Checks for the DOM to load using the jQuery ready function.
        $(document).ready(function () {
            // After the DOM is loaded, add-in-specific code can run.
            var mailbox = Office.context.mailbox;
            mailbox.item.loadCustomPropertiesAsync(customPropsCallback);
        });
    }

    function customPropsCallback(asyncResult) {
        var customProps = asyncResult.value;
        var myProp = customProps.get("myProp");

        customProps.set("otherProp", "value");
        customProps.saveAsync(saveCallback);
    }


    function saveCallback(asyncResult) {

    }
Office.CustomProperties.saveAsync:
  - >-
    // The following JavaScript code sample shows how to asynchronously use the
    loadCustomPropertiesAsync method to load custom properties that are specific
    to the current item, and the saveAsync method to save these properties back
    to the server. After loading the custom properties, the code sample uses the
    get method to read the custom property myProp, the set method to write the
    custom property otherProp, and then finally calls the saveAsync method to
    save the custom properties.

    // The initialize function is required for all add-ins.

    Office.initialize = function () {
        // Checks for the DOM to load using the jQuery ready function.
        $(document).ready(function () {
            // After the DOM is loaded, add-in-specific code can run.
            var item = Office.context.mailbox.item;
            item.loadCustomPropertiesAsync(customPropsCallback);
        });
    }

    function customPropsCallback(asyncResult) {
        var customProps = asyncResult.value;
        var myProp = customProps.get("myProp");

        customProps.set("otherProp", "value");
        customProps.saveAsync(saveCallback);
    }


    function saveCallback(asyncResult) {
        if (asyncResult.status == Office.AsyncResultStatus.Failed){
            write(asyncResult.error.message);
        }
        else {
            // Async call to save custom properties completed.
            // Proceed to do the appropriate for your add-in.
        }
    }


    // Writes to a div with id='message' on the page.

    function write(message){
        document.getElementById('message').innerText += message;
    }
Office.Event:
  - >-
    // DESCRIPTION EXAMPLE

    // MANIFEST EXAMPLE

    <Control xsi:type="Button" id="eventTestButton">
        <Label resid="eventButtonLabel" />
        <Tooltip resid="eventButtonTooltip" />
        <Supertip>
            <Title resid="eventSuperTipTitle" />
            <Description resid="eventSuperTipDescription" />
        </Supertip>
        <Icon>
            <bt:Image size="16" resid="blue-icon-16" />
            <bt:Image size="32" resid="blue-icon-32" />
            <bt:Image size="80" resid="blue-icon-80" />
        </Icon>
        <Action xsi:type="ExecuteFunction">
            <FunctionName>testEventObject</FunctionName>
        </Action>
    </Control>

    // The button has an id attribute set to eventTestButton, and will invoke
    the testEventObject function defined in the add-in. That function looks like
    this:

    function testEventObject(event) {
        // The event object implements the Event interface

        // This value will be "eventTestButton"
        var buttonId = event.source.id;

        // Signal to the host app that processing is complete.
        event.completed();
    }
Office.Event.source:
  - |-
    // Function is used by two buttons:
    // button1 and button2
    function multiButton (event) {
        // Check which button was clicked
        var buttonId = event.source.id;

        if (buttonId === 'button1') {
            doButton1Action();
        }
        else {
            doButton2Action();
        }

        event.completed();
    }
Office.Event.completed:
  - >-
    function processItem (event) {
        // Do some processing

        event.completed();
    }


    // In the following example, the checkMessage function has been registered
    as an event handler for ItemSend.

    function checkMessage(event) {
        // Get the item being sent
        var outgoingMsg = Office.context.mailbox.item;

        // Check if subject contains "BLOCK"
        outgoingMsg.subject.getAsync(function (result) {
            // Subject is in result.value
            if (result.value.indexOf('BLOCK') != -1) {
                // Value is found, stop send
                event.completed({allowEvent = false});
            } else {
                // Value wasn't found, allow send
                event.completed({allowEvent = true});
            }
        });
    }
Office.NotificationMessages.addAsync:
  - |-
    // Create three notifications, each with a different key
    Office.context.mailbox.item.notificationMessages.addAsync("progress", {
        type: "progressIndicator",
        message : "An add-in is processing this message."
    });
    Office.context.mailbox.item.notificationMessages.addAsync("information", {
        type: "informationalMessage",
        message : "The add-in processed this message.",
        icon : "iconid",
        persistent: false
    });
    Office.context.mailbox.item.notificationMessages.addAsync("error", {
        type: "errorMessage",
        message : "The add-in failed to process this message."
    });
Office.NotificationMessages.getAllAsync:
  - >-
    // Get all notifications

    Office.context.mailbox.item.notificationMessages.getAllAsync(function
    (asyncResult) {
        if (asyncResult.status != "failed") {
            Office.context.mailbox.item.notificationMessages.replaceAsync( "notifications", {
                type: "informationalMessage",
                message : "Found " + asyncResult.value.length + " notifications.",
                icon : "iconid",
                persistent: false
            });
        }
    });
Office.NotificationMessages.removeAsync:
  - |-
    // Remove a notification
    Office.context.mailbox.item.notificationMessages.removeAsync("progress");
Office.NotificationMessages.replaceAsync:
  - |-
    // Replace a notification with an informational notification
    Office.context.mailbox.item.notificationMessages.replaceAsync("progress", {
        type: "informationalMessage",
        message : "The message was processed successfully.",
        icon : "iconid",
        persistent: false
    });
Office.Recipients.addAsync:
  - >-
    // The following example creates an array of EmailUser objects and adds them
    to the To recipients of the message.

    var newRecipients = [
        {
            "displayName": "Allie Bellew",
            "emailAddress": "allieb@contoso.com"
        },
        {
            "displayName": "Alex Darrow",
            "emailAddress": "alexd@contoso.com"
        }
    ];


    Office.context.mailbox.item.to.addAsync(newRecipients, function(result) {
        if (result.error) {
            showMessage(result.error);
        } else {
            showMessage("Recipients added");
        }
    });
Office.Recipients.getAsync:
  - |-
    // The following example gets the optional attendees of a meeting.
    Office.context.mailbox.item.optionalAttendees.getAsync(function(result) {
        if (result.error) {
            showMessage(result.error);
        } else {
            var msg = "";
            result.value.forEach(function(recip, index) {
                msg = msg + recip.displayName + " (" + recip.emailAddress + ");";
            });
            showMessage(msg);
        }
    });
Office.Recipients.setAsync:
  - >-
    // The following example creates an array of EmailUser objects and replaces
    the CC recipients of the message with the array.

    var newRecipients = [
        {
            "displayName": "Allie Bellew",
            "emailAddress": "allieb@contoso.com"
        },
        {
            "displayName": "Alex Darrow",
            "emailAddress": "alexd@contoso.com"
        }
    ];


    Office.context.mailbox.item.cc.setAsync(newRecipients, function(result) {
        if (result.error) {
            showMessage(result.error);
        } else {
            showMessage("Recipients overwritten");
        }
    });
Office.Recurrence.getAsync:
  - >-
    // This example gets the recurrence object of an appointment or meeting
    request item.

    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult){
        var context = asyncResult.context;
        var recurrence = asyncResult.value;
        var endDate = recurrence.seriesTime.getEndDate();
    }


    // The following is an example of the results of the getAsync call.

    Recurrence = {"recurrenceType": "weekly","recurrenceProperties":
    {"interval": 2, "days": ["mon","thu","fri"], "firstDayOfWeek": "sun"},
    "seriesTime": {seriesTimeObject}, "recurrenceTimeZone": {"name": "Pacific
    Standard Time", "offset": -480}}
Office.Recurrence.setAsync:
  - >-
    // The following example sets the recurrence pattern of an appointment
    series.

    var seriesTimeObject = new SeriesTime(); 

    seriesTimeObject.setStartDate(2017,11,2);  

    seriesTimeObject.setEndDate(2017,12,2); 

    seriesTimeObject.setStartTime(10,30); 

    seriesTimeObject.setDuration(30);


    var pattern = {"seriesTime": seriesTimeObject, "type": "Weekly",
    "properties": {"interval": ", "days": ["Tue", "Thu"], "firstDayOfWeek":
    "Sun"}, "recurrenceTimeZone": {"name": "Pacific Standard Time"}}; 


    Office.context.mailbox.item.recurrence.setAsync(pattern, options, callback);


    //Result: This created a recurring event from November 2, 2017 to December
    2, 2017 at 10:30 A.M. to 11 A.M. PST every Tuesday and Thursday.
Office.RoamingSettings:
  - |-
    // DESCRIPTION EXAMPLE
    // Get the current value of the 'myKey' setting
    var value = Office.context.roamingSettings.get('myKey');
    // Update the value of the 'myKey' setting
    Office.context.roamingSettings.set('myKey', 'Hello World!');
    // Persist the change
    Office.context.roamingSettings.saveAsync();
Office.SeriesTime.getDuration:
  - >-
    // This example gets the duration of a usual instance in a recurring
    appointment series.

    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult){
        var context = asyncResult.context;
        var recurrence = asyncResult.value;
        var duration = recurrence.seriesTime.getDuration();
    }
Office.SeriesTime.getEndDate:
  - |-
    // This example gets the end date of a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);
    function callback(asyncResult){
        var context = asyncResult.context;
        var recurrence = asyncResult.value;
        var endDate = recurrence.seriesTime.getEndDate();
    }
Office.SeriesTime.getEndTime:
  - >-
    // This example gets the end time of a usual instance in a recurring
    appointment series.

    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult){
        var context = asyncResult.context;
        var recurrence = asyncResult.value;
        var endDate = recurrence.seriesTime.getEndTime();
    }
Office.SeriesTime.getStartDate:
  - |-
    // This example gets the start date of a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);
    function callback(asyncResult){
        var context = asyncResult.context;
        var recurrence = asyncResult.value;
        var endDate = recurrence.seriesTime.getStartDate();
    }
Office.SeriesTime.getStartTime:
  - >-
    // This example gets the start time of a usual instance in a recurring
    appointment series.

    var seriesTimeObject = new SeriesTime()

    seriesTimeObject.setDuration(120);
Office.SeriesTime.setDuration:
  - >-
    // This example sets the duration of each appointment in a recurring series
    to 2 hours.

    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult){
        var context = asyncResult.context;
        var recurrence = asyncResult.value;
        var endDate = recurrence.seriesTime.getStartTime();
    }
Office.SeriesTime.setEndDate:
  - >-
    // This example sets the end date of a recurring appointment series to
    November 2, 2017.

    var seriesTimeObject = new SeriesTime()

    seriesTimeObject.setEndDate(2017, 10, 2);


    // Alternative: Set the end date using ISO 8601 date standard

    seriesTimeObject.setEndDate("2017-11-02");
Office.SeriesTime.setStartDate:
  - >-
    // This example sets the start date of a recurring appointment series to
    November 2, 2017.

    var seriesTimeObject = new SeriesTime()

    seriesTimeObject.setStartDate(2017, 10, 2);


    // Alternative: Set start date using ISO 8601 date standard

    seriesTimeObject.setStartDate("2017-11-02");
Office.SeriesTime.setStartTime:
  - >-
    // This example sets the start time of each instance of a recurring
    appointment series to 1:30 PM.

    var seriesTimeObject = new SeriesTime()

    seriesTimeObject.setStartTime(13, 30);


    // This example sets the start time of each instance of a recurring
    appointment series to 11:30 AM.

    seriesTimeObject.setStartTime(11, 30);


    // Alternative: Set the start time of all instances of a recurring
    appointment series to 11:30 PM.

    seriesTimeObject.setStartTime("T23:30:00");
Office.Time.setAsync:
  - >-
    var startTime = new Date("3/14/2015");

    var options = {
        // Pass information that can be used
        // in the callback
        asyncContext: {verb:"Set"}
    }

    Office.context.mailbox.item.start.setAsync(startTime, options,
    function(result) {
        if (result.error) {
            console.debug(result.error);
        } else {
            // Access the asyncContext that was passed to the setAsync function
            console.debug("Start Time " + result.asyncContext.verb);
        }
    });
Visio.Application.load:
  - |-
    Visio.run(function (ctx) { 
        var application = ctx.document.application;
        application.showToolbars = false;
        application.showBorders = false;
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Comment.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shapeName = "Position Belt.41";
        var shape = activePage.shapes.getItem(shapeName);
        var shapecomments= shape.comments;
        shapecomments.load();
        return ctx.sync().then(function () {
            for(var i=0; i<shapecomments.items.length;i++)
            {
                var comment= shapecomments.items[i];
                console.log("comment Author: " + comment.author);
                console.log("Comment Text: " + comment.text);
                console.log("Date " + comment.date);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.CommentCollection.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shapeName = "Position Belt.41";
        var shape = activePage.shapes.getItem(shapeName);
        var shapecomments= shape.comments;
        shapecomments.load();
        return ctx.sync().then(function () {
            for(var i=0; i<shapecomments.items.length;i++)
            {
                var comment= shapecomments.items[i];
                console.log("comment Author: " + comment.author);
                console.log("Comment Text: " + comment.text);
                console.log("Date " + comment.date);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.DataRefreshCompleteEventArgs.load:
  - |-
    Visio.run(function (ctx) { 
      var document1= ctx.document;
                   var page = document1.getActivePage();
             eventResult1 = document1.onDataRefreshComplete.add(
        function (args){
               console.log("Data Refresh Result: "+args.success);
        });

        return ctx.sync().then(function () {
           console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
        console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Document.getActivePage:
  - |-
    Visio.run(function (ctx) { 
        var document = ctx.document;
        var activePage = document.getActivePage();
        activePage.load();
        return ctx.sync().then(function () {
        console.log("pageName: " +activePage.name);
          });   
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Document.setActivePage:
  - |-
    Visio.run(function (ctx) { 
        var document = ctx.document;
        var pageName = "Page-1";
        document.setActivePage(pageName);
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Document.startDataRefresh:
  - |-
    Visio.run(function (ctx) { 
        var document = ctx.document;
        document.startDataRefresh();
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Document.load:
  - |-
    Visio.run(function (ctx) { 
        var pages = ctx.document.pages;
        var pageCount = pages.getCount();
        return ctx.sync().then(function () {
            console.log("Pages Count: " +pageCount.value);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Visio.run(function (ctx) { 
        var documentView = ctx.document.view;
        documentView.disableHyperlinks();
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Visio.run(function (ctx) { 
        var application = ctx.document.application;
        application.showToolbars = false;
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.DocumentLoadCompleteEventArgs.load:
  - |-
    Visio.run(function (ctx) { 
        var document1 = ctx.document;
        eventResult1 = document1.onDocumentLoadComplete.add(
            function (args){
                console.log("Document Loaded");
            });

        return ctx.sync().then(function () {
            console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Highlight.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        shape.view.highlight = { color: "#E7E7E7", width: 100 };
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Hyperlink.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        var hyperlink = shape.hyperlinks.getItem(0);
        hyperlink.load();
        return ctx.sync().then(function() {
            console.log(hyperlink.description);
            console.log(hyperlink.address);
            console.log(hyperlink.subAddress);
            console.log(hyperlink.extraInfo);
         });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.HyperlinkCollection.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shapeName = "Manager Belt";
        var shape = activePage.shapes.getItem(shapeName);
        var hyperlinks = shape.hyperlinks;
        shapeHyperlinks.load();
            ctx.sync().then(function () {
                for(var i=0; i<shapeHyperlinks.items.length;i++)
                {
                    var hyperlink = shapeHyperlinks.items[i];
                    console.log("Description:"+hyperlink.description +"Address:"+hyperlink.address +"SubAddress:  "+ hyperlink.subAddress);
                }
            });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.PageCollection.getItem:
  - |-
    Visio.run(function (ctx) { 
        var pageName = 'Page-1';
        var page = ctx.document.pages.getItem(pageName);
        page.activate();
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.PageLoadCompleteEventArgs.load:
  - |-
    Visio.run(function (ctx) { 
        var document1= ctx.document;
        var page = document1.getActivePage();
        eventResult1 = document1.onPageLoadComplete.add(
            function (args){
                console.log("Page name: "+args.pageName);
            });

        return ctx.sync().then(function () {
            console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.PageView.centerViewportOnShape:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        activePage.view.centerViewportOnShape(shape.Id);
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.PageView.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        activePage.view.zoom = 300;
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.SelectionChangedEventArgs.load:
  - >-
    var eventResult; //Global Variable to store the EventHandlerResult returned
    on attaching handler.


    function AttachHandler()

    {
        Visio.run(function(ctx)
        {
            var doc = ctx.document;
            eventResult = doc.onSelectionChanged.add(
                function (args) {
                    console.log("Selected Shape Name: "+args.shapeNames[0]);
                });
            return ctx.sync().then(function(){
                console.log("Handler attached");
            });
        }).catch(function(error) {
            console.log("Error: " + error);
            if (error instanceof OfficeExtension.Error) {
                console.log("Debug info: " + JSON.stringify(error.debugInfo));
            }
        });

        function onSelectionChanged(args)
        {
            console.log(Date.now() + "Selection Changes Event" + JSON.stringify(args));
        }
    }


    function RemoveHandler()

    {
        if(!eventResult || !eventResult.context)
        {
            console.log("Handler has not been attached");
            return;
        }

        Visio.run(eventResult.context, function(ctx)
        {
            eventResult.remove();
            return ctx.sync().then(function (){
                eventResult = null;
                console.log("Handler removed");
            });
        }).catch(function(error) {
            console.log("Error: " + error);
            if (error instanceof OfficeExtension.Error) {
                console.log("Debug info: " + JSON.stringify(error.debugInfo));
            }
        });
    }
Visio.Shape.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shapeName = "Sample Name";
        var shape = activePage.shapes.getItem(shapeName);
        shape.load();
        return ctx.sync().then(function () {
            console.log(shape.name );
            console.log(shape.id );
            console.log(shape.Text );
            console.log(shape.Select );
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        shape.view.highlight = { color: "#E7E7E7", width: 100 };
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeCollection.getCount:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var numShapesActivePage = activePage.shapes.getCount();
        return ctx.sync().then(function () {
            console.log("Shapes Count: " + numShapesActivePage.value);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeDataItem.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        var shapeDataItem = shape.shapeDataItems.getItem(0);
        shapeDataItem.load();
            return ctx.sync().then(function() {
                console.log(shapeDataItem.label);
                console.log(shapeDataItem.value);
            });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeDataItemCollection.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        var shapeDataItems = shape.shapeDataItems;
        shapeDataItems.load();
        return ctx.sync().then(function() {
            for (var i = 0; i < shapeDataItems.items.length; i++)
            {
                console.log(shapeDataItems.items[i].label);
                console.log(shapeDataItems.items[i].value);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeMouseEnterEventArgs.load:
  - |-
    Visio.run(function (ctx) { 
        var document1= ctx.document;
        var page = document1.getActivePage();
        eventResult2 = document1.onShapeMouseEnter.add(
        function (args) {            
            console.log(Date.now()+":OnShapeMouseEnter Event"+JSON.stringify(args));
        });
        return ctx.sync().then(function () {
            console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeMouseLeaveEventArgs.load:
  - |-
    Visio.run(function (ctx) { 
        var document1= ctx.document;
        var page = document1.getActivePage();
        eventResult2 = document1.onShapeMouseLeave.add(
            function (args){            
                console.log(Date.now()+":OnShapeMouseLeave Event"+JSON.stringify(args));
            });
        return ctx.sync().then(function () {
            console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeView.load:
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        shape.view.highlight = { color: "#E7E7E7", width: 100 };
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        var overlayId=shape.view.addOverlay(1, "Visio Online", 2, 2, 50, 50);
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Visio.run(function (ctx) { 
        var activePage = ctx.document.getActivePage();
        var shape = activePage.shapes.getItem(0);
        shape.view.removeOverlay(1);
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.clear:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to clear the contents of the body.
        body.clear();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Cleared the body contents.');
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.getHtml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to get the HTML contents of the body.
        var bodyHTML = body.getHtml();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log("Body HTML contents: " + bodyHTML.value);
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.getOoxml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to get the OOXML contents of the body.
        var bodyOOXML = body.getOoxml();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log("Body OOXML contents: " + bodyOOXML.value);
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.insertBreak:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (ctx) {

        // Create a proxy object for the document body.
        var body = ctx.document.body;

        // Queue a commmand to insert a page break at the start of the document body.
        body.insertBreak(Word.BreakType.page, Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return ctx.sync().then(function () {
            console.log('Added a page break at the start of the document body.');
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.insertContentControl:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to wrap the body in a content control.
        body.insertContentControl();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Wrapped the body in a content control.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.insertFileFromBase64:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to insert base64 encoded .docx at the beginning of the content body.
        // You will need to implement getBase64() to pass in a string of a base64 encoded docx file.
        body.insertFileFromBase64(getBase64(), Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Added base64 encoded text to the beginning of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.insertHtml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to insert HTML in to the beginning of the body.
        body.insertHtml('<strong>This is text inserted with body.insertHtml()</strong>', Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('HTML added to the beginning of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.insertInlinePictureFromBase64:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to insert OOXML in to the beginning of the body.
        body.insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('OOXML added to the beginning of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.insertParagraph:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to insert the paragraph at the end of the document body.
        body.insertParagraph('Content of a new paragraph', Word.InsertLocation.end);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Paragraph added at the end of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.insertText:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to insert text in to the beginning of the body.
        body.insertText('This is text inserted with body.insertText()', Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Text added to the beginning of the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.search:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to search the document.
        var searchResults = context.document.body.search('video', {matchCase: false});

        // Queue a commmand to load the results.
        context.load(searchResults, 'text, font');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            var results = 'Found count: ' + searchResults.items.length +
                          '; we highlighted the results.';

            // Queue a command to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
              searchResults.items[i].font.color = '#FF0000'    // Change color to Red
              searchResults.items[i].font.highlightColor = '#FFFF00';
              searchResults.items[i].font.bold = true;
            }

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log(results);
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.select:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to select the document body. The Word UI will
        // move to the selected document body.
        body.select();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Selected the document body.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Body.load:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to load the text in document body.
        context.load(body, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log("Body contents: " + body.text);
        });
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to load font and style information for the document body.
        context.load(body, 'font/size, font/name, font/color, style');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            // Show the results of the load method. Here we show the
            // property values on the body object.
            var results = 'Font size: ' + body.font.size +
                          '; Font name: ' + body.font.name +
                          '; Font color: ' + body.font.color +
                          '; Body style: ' + body.style;

            console.log(results);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.clear:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the content controls collection.
        contentControls.load('text');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            if (contentControls.items.length === 0) {
                console.log("There isn't a content control in this document.");
            } else {
                
                // Queue a command to clear the contents of the first content control.
                contentControls.items[0].clear();
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync().then(function () {
                    console.log('Content control cleared of contents.');
                });      
            }
                
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.delete:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the content controls collection.
        contentControls.load('text');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            if (contentControls.items.length === 0) {
                console.log("There isn't a content control in this document.");
            } else {
                
                // Queue a command to delete the first content control. The
                // contents will remain in the document.
                contentControls.items[0].delete(true);
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync().then(function () {
                    console.log('Content control cleared of contents.');
                });      
            }
                
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.getHtml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection that contains a specific tag.
        var contentControlsWithTag = context.document.contentControls.getByTag('Customer-Address');
        
        // Queue a command to load the tag property for all of content controls. 
        context.load(contentControlsWithTag, 'tag');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControlsWithTag.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to get the HTML contents of the first content control.
                var html = contentControlsWithTag.items[0].getHtml();
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Content control HTML: ' + html.value);
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.getOoxml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to get the OOXML contents of the first content control.
                var ooxml = contentControls.items[0].getOoxml();
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Content control OOXML: ' + ooxml.value);
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.insertBreak:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a commmand to load the id property for all of content controls. 
        context.load(contentControls, 'id');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion. We now will have 
        // access to the content control collection.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to insert a page break after the first content control. 
                contentControls.items[0].insertBreak('page', "After");
                
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion. 
                return context.sync()
                    .then(function () {
                        console.log('Inserted a page break after the first content control.');    
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.insertFileFromBase64:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to put HTML into the contents of the first content control.
                contentControls.items[0].insertHtml('<strong>HTML content inserted into the content control.</strong>', 'Start');
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Inserted HTML in the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.insertInlinePictureFromBase64:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to put OOXML into the contents of the first content control.
                contentControls.items[0].insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", "End");
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Inserted OOXML in the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.insertParagraph:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to insert a paragraph after the first content control. 
                contentControls.items[0].insertParagraph('Text of the inserted paragraph.', 'After');
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Inserted a paragraph after the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.insertText:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to replace text in the first content control. 
                contentControls.items[0].insertText('Replaced text in the first content control.', 'Replace');
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Replaced text in the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.load:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy range object for the current selection.
        var range = context.document.getSelection();
        
        // Queue a commmand to create the content control.
        var myContentControl = range.insertContentControl();
        myContentControl.tag = 'Customer-Address';
        myContentControl.title = ' has t';
        myContentControl.style = 'Heading 2';
        myContentControl.insertText('One Microsoft Way, Redmond, WA 98052', 'replace');
        myContentControl.cannotEdit = true;
        
        // Queue a command to load the id property for the content control you created.
        context.load(myContentControl, 'id');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Created content control with id: ' + myContentControl.id);
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to load the properties on the first content control. 
                contentControls.items[0].load(  'appearance,' +
                                                'cannotDelete,' +
                                                'cannotEdit,' +
                                                'id,' +
                                                'placeHolderText,' +
                                                'removeWhenEdited,' +
                                                'title,' +
                                                'text,' +
                                                'type,' +
                                                'style,' +
                                                'tag,' +
                                                'font/size,' +
                                                'font/name,' +
                                                'font/color');             
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Property values of the first content control:' + 
                            '   ----- appearance: ' + contentControls.items[0].appearance + 
                            '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                            '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                            '   ----- color: ' + contentControls.items[0].color +
                            '   ----- id: ' + contentControls.items[0].id +
                            '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                            '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                            '   ----- title: ' + contentControls.items[0].title +
                            '   ----- text: ' + contentControls.items[0].text +
                            '   ----- type: ' + contentControls.items[0].type +
                            '   ----- style: ' + contentControls.items[0].style +
                            '   ----- tag: ' + contentControls.items[0].tag +
                            '   ----- font size: ' + contentControls.items[0].font.size +
                            '   ----- font name: ' + contentControls.items[0].font.name +
                            '   ----- font color: ' + contentControls.items[0].font.color);
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControl.search:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls. 
        context.load(contentControls, 'id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to select the first content control.
                contentControls.items[0].select();
            
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Selected the first content control.');
                });
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection.getById:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the content control that contains a specific id.
        var contentControl = context.document.contentControls.getById(30086310);

        // Queue a command to load the text property for a content control.
        context.load(contentControl, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The content control with that Id has been found in this document.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the content control that contains a specific id.
        var contentControl = context.document.contentControls.getByIdOrNullObject(30086310);

        // Queue a command to load the text property for a content control.
        context.load(contentControl, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControl.isNullObject) {
                console.log('There is no content control with that ID.')
            } else {
                console.log('The content control with that ID has been found in this document.');
            }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection.getByIdOrNullObject:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the content control that contains a specific id.
        var contentControl = context.document.contentControls.getByIdOrNullObject(30086310);

        // Queue a command to load the text property for a content control.
        context.load(contentControl, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControl.isNullObject) {
                console.log('There is no content control with that ID.')
            } else {
                console.log('The content control with that ID has been found in this document.');
            }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection.getByTag:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the content controls collection that contains a specific tag.
        var contentControlsWithTag = context.document.contentControls.getByTag('Customer-Address');

        // Queue a command to load the text property for all of content controls with a specific tag.
        context.load(contentControlsWithTag, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControlsWithTag.items.length === 0) {
                console.log("There isn't a content control with a tag of Customer-Address in this document.");
            } else {
                console.log('The first content control with the tag of Customer-Address has this text: ' + contentControlsWithTag.items[0].text);
            }

        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection.getByTitle:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the content controls collection that contains a specific title.
        var contentControlsWithTitle = context.document.contentControls.getByTitle('Enter Customer Address Here');

        // Queue a command to load the text property for all of content controls with a specific title.
        context.load(contentControlsWithTitle, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControlsWithTitle.items.length === 0) {
                console.log("There isn't a content control with a title of 'Enter Customer Address Here' in this document.");
            } else {
                console.log("The first content control with the title of 'Enter Customer Address Here' has this text: " + contentControlsWithTitle.items[0].text);
            }

        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection.getFirst:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the first content control in the document.
        var contentControl = context.document.contentControls.getFirstOrNullObject();

        // Queue a command to load the text property for a content control.
        context.load(contentControl, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControl.isNullObject) {
                console.log('There are no content controls in this document.')
            } else {
                console.log('The first content control has been found in this document.');
            }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.ContentControlCollection.load:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;

        // Queue a command to load the id property for all of the content controls.
        context.load(contentControls, 'id');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (contentControls.items.length === 0) {
                console.log('No content control found.');
            }
            else {
                // Queue a command to load the properties on the first content control.
                contentControls.items[0].load(  'appearance,' +
                                                'cannotDelete,' +
                                                'cannotEdit,' +
                                                'id,' +
                                                'placeHolderText,' +
                                                'removeWhenEdited,' +
                                                'title,' +
                                                'text,' +
                                                'type,' +
                                                'style,' +
                                                'tag,' +
                                                'font/size,' +
                                                'font/name,' +
                                                'font/color');

                // Synchronize the document state by executing the queued commands,
                // and return a promise to indicate task completion.
                return context.sync()
                    .then(function () {
                        console.log('Property values of the first content control:' +
                            '   ----- appearance: ' + contentControls.items[0].appearance +
                            '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                            '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                            '   ----- color: ' + contentControls.items[0].color +
                            '   ----- id: ' + contentControls.items[0].id +
                            '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                            '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                            '   ----- title: ' + contentControls.items[0].title +
                            '   ----- text: ' + contentControls.items[0].text +
                            '   ----- type: ' + contentControls.items[0].type +
                            '   ----- style: ' + contentControls.items[0].style +
                            '   ----- tag: ' + contentControls.items[0].tag +
                            '   ----- font size: ' + contentControls.items[0].font.size +
                            '   ----- font name: ' + contentControls.items[0].font.name +
                            '   ----- font color: ' + contentControls.items[0].font.color);
                });
            }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Document.getSelection:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        var textSample = 'This is an example of the insert text method. This is a method ' + 
            'which allows users to insert text into a selection. It can insert text into a ' +
            'relative location or it can overwrite the current selection. Since the ' +
            'getSelection method returns a range object, look up the range object documentation ' +
            'for everything you can do with a selection.';
        
        // Create a range proxy object for the current selection.
        var range = context.document.getSelection();
        
        // Queue a commmand to insert text at the end of the selection.
        range.insertText(textSample, Word.InsertLocation.end);
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Inserted the text at the end of the selection.');
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Document.load:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the document.
        var thisDocument = context.document;
        
        // Queue a command to load content control properties.
        context.load(thisDocument, 'contentControls/id, contentControls/text, contentControls/tag');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (thisDocument.contentControls.items.length !== 0) {
                for (var i = 0; i < thisDocument.contentControls.items.length; i++) {
                    console.log(thisDocument.contentControls.items[i].id);
                    console.log(thisDocument.contentControls.items[i].text);
                    console.log(thisDocument.contentControls.items[i].tag);
                }
            } else {
                console.log('No content controls in this document.');
            }
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Document.save:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the document.
        var thisDocument = context.document;

        // Queue a commmand to load the document save state (on the saved property).
        context.load(thisDocument, 'saved');    
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            if (thisDocument.saved === false) {
                // Queue a command to save this document.
                thisDocument.save();
                
                // Synchronize the document state by executing the queued commands, 
                // and return a promise to indicate task completion.
                return context.sync().then(function () {
                    console.log('Saved the document');
                });
            } else {
                console.log('The document has not changed since the last save.');
            }
        });  
    })
    .catch(function (error) {
        console.log("Error: " + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.OfficeExtension.Error.toString:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the document body.
        var body = context.document.body;

        // Queue a commmand to insert text in to the beginning of the body.
        // This will cause an OfficeExtension.Error.
        body.insertText(0);

        // Synchronize the document state by executing the queued-up commands,
        // and return a promise to indicate task completion.
        return context.sync();
    })
    .catch(function (error) {
        if (error instanceof OfficeExtension.Error) {
            console.log('Error code and message: ' + error.toString());
        }
    });
Word.Font.load:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();

        // Queue a commmand to change the current selection's font name.
        selection.font.name = 'Arial';

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The font name has changed.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();

        // Queue a commmand to change the font color of the current selection.
        selection.font.color = 'blue';

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The font color of the selection has been changed.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();

        // Queue a commmand to change the current selection's font size.
        selection.font.size = 20;

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The font size has changed.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();

        // Queue a commmand to highlight the current selection.
        selection.font.highlightColor = '#FFFF00'; // Yellow

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The selection has been highlighted.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();

        // Queue a commmand to make the current selection bold.
        selection.font.bold = true;

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The selection is now bold.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();

        // Queue a commmand to underline the current selection.
        selection.font.underline = Word.UnderlineType.single;

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The selection now has an underline style.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a range proxy object for the current selection.
        var selection = context.document.getSelection();

        // Queue a commmand to strikethrough the font of the current selection.
        selection.font.strikeThrough = true;

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The selection now has a strikethrough.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.InlinePicture.getNext:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the first inline picture.
        var firstPicture = context.document.body.inlinePictures.getFirstOrNullObject();

        // Queue a command to load the alternative text title of the picture.
        context.load(firstPicture, 'altTextTitle');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (firstPicture.isNullObject) {
                console.log('There are inline pictures in this document.')
            } else {
                console.log(firstPicture.altTextTitle);
            }
        });   
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.InlinePicture.getNextOrNullObject:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy object for the first inline picture.
        var firstPicture = context.document.body.inlinePictures.getFirstOrNullObject();

        // Queue a command to load the alternative text title of the picture.
        context.load(firstPicture, 'altTextTitle');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            if (firstPicture.isNullObject) {
                console.log('There are inline pictures in this document.')
            } else {
                console.log(firstPicture.altTextTitle);
            }
        });   
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.clear:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for all of the paragraphs.
        context.load(paragraphs, 'style');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to clear the contents of the first paragraph.
            paragraphs.items[0].clear();

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Cleared the contents of the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.delete:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the text property for all of the paragraphs.
        context.load(paragraphs, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to delete the first paragraph.
            paragraphs.items[0].delete();

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Deleted the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.getHtml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for all of the paragraphs.
        context.load(paragraphs, 'style');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a a set of commands to get the HTML of the first paragraph.
            var html = paragraphs.items[0].getHtml();

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Paragraph HTML: ' + html.value);
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.getOoxml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for the top 2 paragraphs.
        context.load(paragraphs, {select: 'style', top: 2} );

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a a set of commands to get the OOXML of the first paragraph.
            var ooxml = paragraphs.items[0].getOoxml();

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Paragraph OOXML: ' + ooxml.value);
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.getPreviousOrNullObject:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the text property for all of the paragraphs.
        context.load(paragraphs, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue commands to create a proxy object for the next-to-last paragraph.
            var indexOfLastParagraph = paragraphs.items.length - 1;
            var precedingParagraph = paragraphs.items[indexOfLastParagraph].getPreviousOrNullObject();

            // Queue a command to load the text of the preceding paragraph.
            context.load(precedingParagraph, 'text');

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                if (precedingParagraph.isNullObject) {
                    console.log('There are no paragraphs before the current one.');
                } else {
                    console.log('The preceding paragraph is: ' + precedingParagraph.text);
                }
            });
        });
    }).catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.insertBreak:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];

            // Queue a command to insert a page break after the first paragraph.
            paragraph.insertBreak('page', 'After');

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Inserted a page break after the paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.insertContentControl:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];

            // Queue a command to wrap the first paragraph in a rich text content control.
            paragraph.insertContentControl();

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Wrapped the first paragraph in a content control.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.insertHtml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];

            // Queue a command to insert HTML content at the end of the first paragraph.
            paragraph.insertHtml('<strong>Inserted HTML.</strong>', Word.InsertLocation.end);

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Inserted HTML content at the end of the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.insertInlinePictureFromBase64:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for all of the paragraphs.
        context.load(paragraphs, 'style');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];

            var b64encodedImg = "iVBORw0KGgoAAAANSUhEUgAAAB4AAAANCAIAAAAxEEnAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACFSURBVDhPtY1BEoQwDMP6/0+XgIMTBAeYoTqso9Rkx1zG+tNj1H94jgGzeNSjteO5vtQQuG2seO0av8LzGbe3anzRoJ4ybm/VeKEerAEbAUpW4aWQCmrGFWykRzGBCnYy2ha3oAIq2MloW9yCCqhgJ6NtcQsqoIKdjLbFLaiACnYyf2fODbrjZcXfr2F4AAAAAElFTkSuQmCC";

            // Queue a command to insert a base64 encoded image at the beginning of the first paragraph.
            paragraph.insertInlinePictureFromBase64(b64encodedImg, Word.InsertLocation.start);

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Added an image to the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.insertParagraph:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];

            // Queue a command to insert the paragraph after the current paragraph.
            paragraph.insertParagraph('Content of a new paragraph', Word.InsertLocation.after);

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Inserted a new paragraph at the end of the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.insertText:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        context.load(paragraphs, {select: 'style', top: 2} );

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to get the first paragraph.
            var paragraph = paragraphs.items[0];

            // Queue a command to insert text into the end of the paragraph.
            paragraph.insertText('New text inserted into the paragraph.', Word.InsertLocation.end);

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Inserted text at the end of the first paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Paragraph.select:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the style property for all of the paragraphs.
        context.load(paragraphs, 'style');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a command to get the last paragraph a create a
            // proxy paragraph object.
            var paragraph = paragraphs.items[paragraphs.items.length - 1];

            // Queue a command to select the paragraph. The Word UI will
            // move to the selected paragraph.
            paragraph.select();

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Selected the last paragraph.');
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.clear:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to clear the contents of the proxy range object.
        range.clear();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Cleared the selection (range object)');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.delete:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to delete the range object.
        range.delete();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Deleted the selection (range object)');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.getHtml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to get the HTML of the current selection.
        var html = range.getHtml();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The HTML read from the document was: ' + html.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.getOoxml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to get the OOXML of the current selection.
        var ooxml = range.getOoxml();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('The OOXML read from the document was:  ' + ooxml.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.insertBreak:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to insert a page break after the selected text.
        range.insertBreak('page', 'After');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Inserted a page break after the selected text.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.insertContentControl:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to insert a content control around the selected text,
        // and create a proxy content control object. We'll update the properties
        // on the content control.
        var myContentControl = range.insertContentControl();
        myContentControl.tag = "Customer-Address";
        myContentControl.title = "Enter Customer Address Here:";
        myContentControl.style = "Normal";
        myContentControl.insertText("One Microsoft Way, Redmond, WA 98052", 'replace');
        myContentControl.cannotEdit = true;

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Wrapped a content control around the selected text.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.insertFileFromBase64:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to insert base64 encoded .docx at the beginning of the range.
        // You'll need to implement getBase64() to make this work.
        range.insertFileFromBase64(getBase64(), Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Added base64 encoded text to the beginning of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.insertHtml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to insert HTML in to the beginning of the range.
        range.insertHtml('<strong>This is text inserted with range.insertHtml()</strong>', Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('HTML added to the beginning of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.insertOoxml:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to insert OOXML in to the beginning of the range.
        range.insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('OOXML added to the beginning of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.insertParagraph:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to insert the paragraph after the range.
        range.insertParagraph('Content of a new paragraph', Word.InsertLocation.after);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Paragraph added to the end of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.insertText:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to insert the paragraph at the end of the range.
        range.insertText('New text inserted into the range.', Word.InsertLocation.end);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Text added to the end of the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Range.select:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        var range = context.document.getSelection();

        // Queue a commmand to insert HTML in to the beginning of the range.
        range.insertHtml('<strong>This is text inserted with range.insertHtml()</strong>', Word.InsertLocation.start);

        // Queue a command to select the HTML that was inserted.
        range.select();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Selected the range.');
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.RequestContext.load:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the paragraphs collection.
        var paragraphs = context.document.body.paragraphs;

        // Queue a commmand to load the text property for all of the paragraphs.
        context.load(paragraphs, 'text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            // Queue a a set of commands to get the HTML of the first paragraph.
            var html = paragraphs.items[0].getHtml();

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log('Paragraph HTML: ' + html.value);
            });
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.RequestContext.sync:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Create a proxy object for the content controls collection.
        var contentControls = context.document.contentControls;

        // Queue a command to load the content controls collection.
        contentControls.load('text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {

            if (contentControls.items.length === 0) {
                console.log("There isn't a content control in this document.");
            } else {

                // Queue a command to clear the contents of the first content control.
                contentControls.items[0].clear();
                // Synchronize the document state by executing the queued commands,
                // and return a promise to indicate task completion.
                return context.sync().then(function () {
                    console.log('Content control cleared of contents.');
                });
            }

        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.SearchOptions.load:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Queue a command to search the document and ignore punctuation.
        var searchResults = context.document.body.search('video you', {ignorePunct: true});

        // Queue a command to load the search results and get the font property values.
        context.load(searchResults, 'font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Found count: ' + searchResults.items.length);

            // Queue a set of commands to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
                searchResults.items[i].font.color = 'purple';
                searchResults.items[i].font.highlightColor = '#FFFF00'; //Yellow
                searchResults.items[i].font.bold = true;
            }
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync();
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Queue a command to search the document based on a prefix.
        var searchResults = context.document.body.search('vid', {matchPrefix: true});

        // Queue a command to load the search results and get the font property values.
        context.load(searchResults, 'font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Found count: ' + searchResults.items.length);

            // Queue a set of commands to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
                searchResults.items[i].font.color = 'purple';
                searchResults.items[i].font.highlightColor = '#FFFF00'; //Yellow
                searchResults.items[i].font.bold = true;
            }
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync();
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue a command to search the document for any string of characters after 'ly'.
        var searchResults = context.document.body.search('ly', {matchSuffix: true});

        // Queue a command to load the search results and get the font property values.
        context.load(searchResults, 'font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Found count: ' + searchResults.items.length);

            // Queue a set of commands to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
                searchResults.items[i].font.color = 'orange';
                searchResults.items[i].font.highlightColor = 'black';
                searchResults.items[i].font.bold = true;
            }
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync();
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Queue a command to search the document with a wildcard
        // for any string of characters that starts with 'to' and ends with 'n'.
        var searchResults = context.document.body.search('to*n', {matchWildCards: true});

        // Queue a command to load the search results and get the font property values.
        context.load(searchResults, 'font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log('Found count: ' + searchResults.items.length);

            // Queue a set of commands to change the font for each found item.
            for (var i = 0; i < searchResults.items.length; i++) {
                searchResults.items[i].font.color = 'purple';
                searchResults.items[i].font.highlightColor = 'pink';
                searchResults.items[i].font.bold = true;
            }
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync();
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Section.getFooter:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy sectionsCollection object.
        var mySections = context.document.sections;
        
        // Queue a commmand to load the sections.
        context.load(mySections, 'body/style');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            // Create a proxy object the primary footer of the first section. 
            // Note that the footer is a body object.
            var myFooter = mySections.items[0].getFooter("primary");
            
            // Queue a command to insert text at the end of the footer.
            myFooter.insertText("This is a footer.", Word.InsertLocation.end);
            
            // Queue a command to wrap the header in a content control.
            myFooter.insertContentControl();
                                  
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log("Added a footer to the first section.");
            });                    
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Section.getHeader:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        
        // Create a proxy sectionsCollection object.
        var mySections = context.document.sections;
        
        // Queue a commmand to load the sections.
        context.load(mySections, 'body/style');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            
            // Create a proxy object the primary header of the first section. 
            // Note that the header is a body object.
            var myHeader = mySections.items[0].getHeader("primary");
            
            // Queue a command to insert text at the end of the header.
            myHeader.insertText("This is a header.", Word.InsertLocation.end);
            
            // Queue a command to wrap the header in a content control.
            myHeader.insertContentControl();
                                  
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            return context.sync().then(function () {
                console.log("Added a header to the first section.");
            });                    
        });  
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.Setting.delete:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue commands add a setting.
        var settings = context.document.settings;
        var startMonth = settings.add('startMonth', { month: 'March', year: 1998 });

        // Queue a command to get the count of settings.
        var count = settings.getCount();

        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log(count.value);

            // Queue a command to delete the setting.
            startMonth.delete();

            // Queue a command to get the new count of settings.
            count = settings.getCount();
        })

        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        .then(context.sync)
        .then(function () {
            console.log(count.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.SettingCollection.deleteAll:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue commands add a setting.
        var settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });

        // Queue a command to get the count of settings.
        var count = settings.getCount();

        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log(count.value);

            // Queue a command to delete all settings.
            settings.deleteAll();

            // Queue a command to get the new count of settings.
            count = settings.getCount();
        })

        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        .then(context.sync)
        .then(function () {
            console.log(count.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.SettingCollection.getCount:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue commands add a setting.
        var settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });

        // Queue a command to get the count of settings.
        var count = settings.getCount();

        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log(count.value);

            // Queue a command to delete all settings.
            settings.deleteAll();

            // Queue a command to get the new count of settings.
            count = settings.getCount();
        })

        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        .then(context.sync)
        .then(function () {
            console.log(count.value);
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Word.SettingCollection.getItem:
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue commands add a setting.
        var settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });

        // Queue a command to retrieve a setting.
        var startMonth = settings.getItem('startMonth');

        // Queue a command to load the setting.
        context.load(startMonth);

        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            console.log(JSON.stringify(startMonth.value));
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    // Run a batch operation against the Word object model.
    Word.run(function (context) {

        // Queue commands add a setting.
        var settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
        
        // Queue commands to retrieve settings.
        var startMonth = settings.getItemOrNullObject('startMonth');
        var endMonth = settings.getItemOrNullObject('endMonth');

        // Queue commands to load settings.
        context.load(startMonth);
        context.load(endMonth);

        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
           return context.sync().then(function () {
               if (startMonth.isNullObject) {
                   console.log("No such setting.");
               }
               else {
                   console.log(JSON.stringify(startMonth.value));
               }
                if (endMonth.isNullObject) {
                   console.log("No such setting.");
               }
               else {
                   console.log(JSON.stringify(endMonth.value));
               }
        });
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
Excel.Binding.onDataChanged:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");    
        const salesTable = sheet.tables.getItem("SalesTable");
        const salesByQuarterBinding = context.workbook.bindings.add(salesTable.getRange(), "Table", "SalesByQuarter");
        salesByQuarterBinding.onDataChanged.add(onSalesDataChanged);

        OfficeHelpers.UI.notify("The handler is registered.", "Change the value in one of the data cells and watch this message banner. (Be sure to complete the edit by pressing Enter or clicking in another cell.)");

        await context.sync();
    });
Excel.NamedItemCollection.add:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const headerRange = sheet.getRange("A1:E1");
        sheet.names.add("ExpensesHeader", headerRange);
        const namedItems = sheet.names.load("name, type");

        await context.sync();

        let namedItemsList = `This workbook contains ${namedItems.items.length} named item(s):`;
        for (let i = 0; i < namedItems.items.length; i++) {
            namedItemsList += JSON.stringify(namedItems.items[i]);
        }
        OfficeHelpers.UI.notify(namedItemsList);

        await context.sync();
    });
  - |-
    try {
        await Excel.run(async (context) => {

            await OfficeHelpers.ExcelUtilities.forceCreateSheet(context.workbook, "Sample");

            const sheet = context.workbook.worksheets.getItem("Sample");

            let expensesTable = sheet.tables.add("A1:D1", true);
            expensesTable.name = "ExpensesTable";

            expensesTable.getHeaderRowRange().values = [["DATE", "MERCHANT", "CATEGORY", "AMOUNT"]];

            let newData = transactions.map(item =>
                [item.DATE, item.MERCHANT, item.CATEGORY, item.AMOUNT]);

            expensesTable.rows.add(null, newData);

            sheet.names.add("TotalAmount", "=SUM(ExpensesTable[AMOUNT])");

            sheet.getRange("D11").values = [["=TotalAmount"]];

            if (Office.context.requirements.isSetSupported("ExcelApi", 1.2)) {
                sheet.getUsedRange().format.autofitColumns();
                sheet.getUsedRange().format.autofitRows();
            }

            sheet.activate();

            await context.sync();
        });
    }
    catch (error) {
        OfficeHelpers.UI.notify(error);
        OfficeHelpers.Utilities.log(error);
    }
Excel.NamedItem.delete:
  - |-
    try {
        await Excel.run(async (context) => {

            const sheet = context.workbook.worksheets.getItem("Sample");

            sheet.names.getItem("TotalAmount").delete();

            // Replace the named item (TotalAmount) with the actual formula for TotalAmount to avoid displaying #NAME in the cell.
            sheet.getRange("D11").values = [["=SUM(ExpensesTable[AMOUNT])"]];

            await context.sync();

        });
    }
    catch (error) {
        OfficeHelpers.UI.notify(error);
        OfficeHelpers.Utilities.log(error);
    }
Excel.NamedItem.formula:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        // Get the named item
        const myNamedItem = sheet.names.getItemOrNullObject("MyRange");
        myNamedItem.load("name, formula");

        await context.sync();

        if (myNamedItem.isNullObject) {
            OfficeHelpers.UI.notify(`There is no named item with the name "MyRange".`);
        } else {
            
            // Update named item to point to the second range
            myNamedItem.formula = "=Sample!$B$10:$D$14";

            sheet.getRange("B10:D14").select();

            await context.sync();

            OfficeHelpers.UI.notify(`Just updated the named item "${myNamedItem.name}" -- it's now located here: ${myNamedItem.formula}`);
        }
    });
Excel.SettingCollection.onSettingsChanged:
  - |-
    await Excel.run(async (context) => {
        const settings = context.workbook.settings; 
        settings.onSettingsChanged.add(onChangedSetting);
        OfficeHelpers.UI.notify("Handler registered", "");

        await context.sync();
    });
Excel.SettingCollection.add:
  - |-
    await Excel.run(async (context) => {
        const settings = context.workbook.settings; 
        settings.onSettingsChanged.add(onChangedSetting);
        OfficeHelpers.UI.notify("Handler registered", "");

        await context.sync();
    });
Excel.Setting.delete:
  - |-
    await Excel.run(async (context) => {
        const settings = context.workbook.settings;
        let needsReview = settings.getItem("NeedsReview");
        needsReview.delete();
        needsReview = settings.getItemOrNullObject("NeedsReview");

        await context.sync();

        if (needsReview.isNullObject) {
            OfficeHelpers.UI.notify("The setting has been deleted");
        } else {
            OfficeHelpers.UI.notify("The setting was not deleted");
        }

        await context.sync();
    });
Excel.Setting.getItemOrNullObject:
  - |-
    await Excel.run(async (context) => {
        const settings = context.workbook.settings;
        let needsReview = settings.getItem("NeedsReview");
        needsReview.delete();
        needsReview = settings.getItemOrNullObject("NeedsReview");

        await context.sync();

        if (needsReview.isNullObject) {
            OfficeHelpers.UI.notify("The setting has been deleted");
        } else {
            OfficeHelpers.UI.notify("The setting was not deleted");
        }

        await context.sync();
    });
Excel.Range.getUsedRangeOrNullObject:
  - |-
    await Excel.run(async (context) => {

        const sheet = context.workbook.worksheets.getItem("Sample");    
        const salesTable = sheet.tables.getItem("SalesTable");
        const dataRange = salesTable.getDataBodyRange();

        // Pass true so only cells with values count as used 
        const usedDataRange = dataRange.getUsedRangeOrNullObject(true /* valuesOnly */);

        //Must sync before reading value returned from *OrNullObject method/property.
        await context.sync();

        if (usedDataRange.isNullObject) {
            OfficeHelpers.UI.notify("Need Data to Make Chart", "To create a meaningful chart, add names to the Product column and numbers to some of the other cells. Then press 'Try to create chart' again.");            
        } else {            
            const chart = sheet.charts.add(Excel.ChartType.columnClustered, dataRange, "Columns");
            chart.setPosition("A15", "F30");
            chart.title.text = "Quarterly sales chart";
            chart.legend.position = "Right";
            chart.legend.format.fill.setSolidColor("white");
            chart.dataLabels.format.font.size = 15;
            chart.dataLabels.format.font.color = "black";
        }

        await context.sync();
    });
Excel.Range.getIntersectionOrNullObject:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");    
        const salesTable = sheet.tables.getItem("SalesTable");
        const dataRange = salesTable.getDataBodyRange();

        // We want the most recent quarter that has data, so 
        // exclude quarters without data and get the last of 
        // the remaining columns.
        const usedDataRange = dataRange.getUsedRange(true /* valuesOnly */);
        const currentQuarterRange = usedDataRange.getLastColumn();

        // Asian and European teams have separate contests.
        const asianSalesRange = sheet.getRange("A2:E4");
        const europeanSalesRange = sheet.getRange("A5:E7");

        // The data for each chart is the intersection of 
        // the current quarter column and the rows for the 
        // continent.
        const asianContestRange = asianSalesRange.getIntersectionOrNullObject(currentQuarterRange);
        const europeanContestRange = europeanSalesRange.getIntersectionOrNullObject(currentQuarterRange);

        // Must sync before you can test the output of *OrNullObject 
        // method/property.
        await context.sync();

        if (asianContestRange.isNullObject) {
            // See the declaration of this method for how to 
            // test this code path.
            reportMissingData("Asian");
        } else {
            createContinentChart(sheet, "Asian", asianContestRange, "A9", "F24");
        }

        if (europeanContestRange.isNullObject) {
            // See the declaration of this method for how to 
            // test this code path.
            reportMissingData("European");
        } else {
            createContinentChart(sheet, "European", europeanContestRange, "A25", "F40");
        }

        await context.sync();
    });
Excel.CustomXmlPartCollection.set:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        const range = sheet.getRange("B2:E2");
        range.set({
            format: {
                fill: {
                    color: "#4472C4"
                },
                font: {
                    name: "Verdana",
                    color: "white"
                }
            }
        })
        range.format.autofitColumns();
        await context.sync();
    });
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        const sourceRange = sheet.getRange("B2:E2");
        sourceRange.load("format/fill/color, format/font/name, format/font/color");
        await context.sync();

        // Set properties based on the loaded and synced 
        // source range.
        const targetRange = sheet.getRange("B7:E7");
        targetRange.set(sourceRange); 
        targetRange.format.autofitColumns();
        await context.sync();
    });
Excel.CustomXmlPart.add:
  - |-
    await Excel.run(async (context) => {

        // You must have the xmlns attribute to populate the 
        // CustomXml.namespaceUri property.
        const originalXml = "<Reviewers xmlns='http://schemas.contoso.com/review/1.0'><Reviewer>Juan</Reviewer><Reviewer>Hong</Reviewer><Reviewer>Sally</Reviewer></Reviewers>";
        const customXmlPart = context.workbook.customXmlParts.add(originalXml);
        customXmlPart.load("id");
        const xmlBlob = customXmlPart.getXml();

        await context.sync();

        const readableXml = addLineBreaksToXML(xmlBlob.value);
        $("#display-xml").text(readableXml);

        // Store the XML part's ID in a setting.
        const settings = context.workbook.settings;
        settings.add("ContosoReviewXmlPartId", customXmlPart.id);

        await context.sync();
    });
Excel.CustomXmlPart.getItem:
  - |-
    await Excel.run(async (context) => {
        const settings = context.workbook.settings;
        const xmlPartIDSetting = settings.getItem("ContosoReviewXmlPartId").load("value");

        await context.sync();
        
        const customXmlPart = context.workbook.customXmlParts.getItem(xmlPartIDSetting.value);

        // The setXml method does a whole-for-whole replacement 
        // of the entire XML.
        customXmlPart.setXml("<Reviewers xmlns='http://schemas.contoso.com/review/1.0'><Reviewer>John</Reviewer><Reviewer>Hitomi</Reviewer></Reviewers>");
        const xmlBlob = customXmlPart.getXml();

        await context.sync();

        const readableXml = addLineBreaksToXML(xmlBlob.value);
        $("#display-xml").text(readableXml);

        await context.sync();
    });
Excel.CustomXmlPart.getXml:
  - |-
    await Excel.run(async (context) => {

        // You must have the xmlns attribute to populate the 
        // CustomXml.namespaceUri property.
        const originalXml = "<Reviewers xmlns='http://schemas.contoso.com/review/1.0'><Reviewer>Juan</Reviewer><Reviewer>Hong</Reviewer><Reviewer>Sally</Reviewer></Reviewers>";
        const customXmlPart = context.workbook.customXmlParts.add(originalXml);
        customXmlPart.load("id");
        const xmlBlob = customXmlPart.getXml();

        await context.sync();

        const readableXml = addLineBreaksToXML(xmlBlob.value);
        $("#display-xml").text(readableXml);

        // Store the XML part's ID in a setting.
        const settings = context.workbook.settings;
        settings.add("ContosoReviewXmlPartId", customXmlPart.id);

        await context.sync();
    });
Excel.CustomXmlPart.id:
  - |-
    await Excel.run(async (context) => {

        // You must have the xmlns attribute to populate the 
        // CustomXml.namespaceUri property.
        const originalXml = "<Reviewers xmlns='http://schemas.contoso.com/review/1.0'><Reviewer>Juan</Reviewer><Reviewer>Hong</Reviewer><Reviewer>Sally</Reviewer></Reviewers>";
        const customXmlPart = context.workbook.customXmlParts.add(originalXml);
        customXmlPart.load("id");
        const xmlBlob = customXmlPart.getXml();

        await context.sync();

        const readableXml = addLineBreaksToXML(xmlBlob.value);
        $("#display-xml").text(readableXml);

        // Store the XML part's ID in a setting.
        const settings = context.workbook.settings;
        settings.add("ContosoReviewXmlPartId", customXmlPart.id);

        await context.sync();
    });
Excel.CustomXmlPartCollection.setXml:
  - |-
    await Excel.run(async (context) => {
        const settings = context.workbook.settings;
        const xmlPartIDSetting = settings.getItem("ContosoReviewXmlPartId").load("value");

        await context.sync();
        
        const customXmlPart = context.workbook.customXmlParts.getItem(xmlPartIDSetting.value);

        // The setXml method does a whole-for-whole replacement 
        // of the entire XML.
        customXmlPart.setXml("<Reviewers xmlns='http://schemas.contoso.com/review/1.0'><Reviewer>John</Reviewer><Reviewer>Hitomi</Reviewer></Reviewers>");
        const xmlBlob = customXmlPart.getXml();

        await context.sync();

        const readableXml = addLineBreaksToXML(xmlBlob.value);
        $("#display-xml").text(readableXml);

        await context.sync();
    });
Excel.CustomXmlPartCollection.delete:
  - |-
    await Excel.run(async (context) => {
        const settings = context.workbook.settings;
        const xmlPartIDSetting = settings.getItem("ContosoReviewXmlPartId").load("value");

        await context.sync();
        
        let customXmlPart = context.workbook.customXmlParts.getItem(xmlPartIDSetting.value);
        const xmlBlob = customXmlPart.getXml();
        customXmlPart.delete();
        customXmlPart = context.workbook.customXmlParts.getItemOrNullObject(xmlPartIDSetting.value);

        await context.sync();

        if (customXmlPart.isNullObject) {
            $("#display-xml").text(`The XML part with the id ${xmlPartIDSetting.value} has been deleted.`);

            // Delete the unneeded setting too.
            xmlPartIDSetting.delete();            
        } else {
            const readableXml = addLineBreaksToXML(xmlBlob.value);
            const strangeMessage = `This is strange. The XML part with the id ${xmlPartIDSetting.value} has not been deleted:\n${readableXml}`
            $("#display-xml").text(strangeMessage);
        }

        await context.sync();
    });
Excel.CustomXmlPartScopedCollection.getItemOrNullObject:
  - |-
    await Excel.run(async (context) => {
        const settings = context.workbook.settings;
        const xmlPartIDSetting = settings.getItem("ContosoReviewXmlPartId").load("value");

        await context.sync();
        
        let customXmlPart = context.workbook.customXmlParts.getItem(xmlPartIDSetting.value);
        const xmlBlob = customXmlPart.getXml();
        customXmlPart.delete();
        customXmlPart = context.workbook.customXmlParts.getItemOrNullObject(xmlPartIDSetting.value);

        await context.sync();

        if (customXmlPart.isNullObject) {
            $("#display-xml").text(`The XML part with the id ${xmlPartIDSetting.value} has been deleted.`);

            // Delete the unneeded setting too.
            xmlPartIDSetting.delete();            
        } else {
            const readableXml = addLineBreaksToXML(xmlBlob.value);
            const strangeMessage = `This is strange. The XML part with the id ${xmlPartIDSetting.value} has not been deleted:\n${readableXml}`
            $("#display-xml").text(strangeMessage);
        }

        await context.sync();
    });
Excel.CustomXmlPartScopedCollection.getByNamespace:
  - |-
    await Excel.run(async (context) => {
        $("#display-xml").text("");
        const contosoNamespace = "http://schemas.contoso.com/review/1.0";
        const customXmlParts = context.workbook.customXmlParts;
        const filteredXmlParts = customXmlParts.getByNamespace(contosoNamespace);
        const numberOfPartsInNamespace = filteredXmlParts.getCount();

        await context.sync();

        if (numberOfPartsInNamespace.value == 1) {
            const onlyXmlPartInNamespace = filteredXmlParts.getOnlyItem();
            const xmlBlob = onlyXmlPartInNamespace.getXml();

            await context.sync();

            // Make it a bit more readable.
            const readableXml = xmlBlob.value.replace(/></g, ">\n<");

            $("#display-xml").text(`The only XML part in the namespace ${contosoNamespace} is:
                ${readableXml}`);

        } else {
            OfficeHelpers.UI.notify(`There are ${numberOfPartsInNamespace.value} XML parts with namespace ${contosoNamespace}.
                There should be exactly 1.`);
        }        

        await context.sync();
    });
Excel.Worksheet.getCount:
  - |-
    await Excel.run(async (context) => {
        $("#display-xml").text("");
        const contosoNamespace = "http://schemas.contoso.com/review/1.0";
        const customXmlParts = context.workbook.customXmlParts;
        const filteredXmlParts = customXmlParts.getByNamespace(contosoNamespace);
        const numberOfPartsInNamespace = filteredXmlParts.getCount();

        await context.sync();

        if (numberOfPartsInNamespace.value == 1) {
            const onlyXmlPartInNamespace = filteredXmlParts.getOnlyItem();
            const xmlBlob = onlyXmlPartInNamespace.getXml();

            await context.sync();

            // Make it a bit more readable.
            const readableXml = xmlBlob.value.replace(/></g, ">\n<");

            $("#display-xml").text(`The only XML part in the namespace ${contosoNamespace} is:
                ${readableXml}`);

        } else {
            OfficeHelpers.UI.notify(`There are ${numberOfPartsInNamespace.value} XML parts with namespace ${contosoNamespace}.
                There should be exactly 1.`);
        }        

        await context.sync();
    });
Excel.Worksheet.getOnlyItem:
  - |-
    await Excel.run(async (context) => {
        $("#display-xml").text("");
        const contosoNamespace = "http://schemas.contoso.com/review/1.0";
        const customXmlParts = context.workbook.customXmlParts;
        const filteredXmlParts = customXmlParts.getByNamespace(contosoNamespace);
        const numberOfPartsInNamespace = filteredXmlParts.getCount();

        await context.sync();

        if (numberOfPartsInNamespace.value == 1) {
            const onlyXmlPartInNamespace = filteredXmlParts.getOnlyItem();
            const xmlBlob = onlyXmlPartInNamespace.getXml();

            await context.sync();

            // Make it a bit more readable.
            const readableXml = xmlBlob.value.replace(/></g, ">\n<");

            $("#display-xml").text(`The only XML part in the namespace ${contosoNamespace} is:
                ${readableXml}`);

        } else {
            OfficeHelpers.UI.notify(`There are ${numberOfPartsInNamespace.value} XML parts with namespace ${contosoNamespace}.
                There should be exactly 1.`);
        }        

        await context.sync();
    });
Excel.WorksheetCollection.getPrevious:
  - |-
    await Excel.run(async (context) => {
        const sheets = context.workbook.worksheets;
        const currentSheet = sheets.getActiveWorksheet();
        const previousYearSheet = currentSheet.getPrevious();
        const currentTaxDueRange = currentSheet.getRange("C2");
        const previousTaxDueRange = previousYearSheet.getRange("C2");

        currentSheet.load("name");
        previousYearSheet.load("name");
        currentTaxDueRange.load("text");
        previousTaxDueRange.load("text");

        await context.sync();

        let currentYear = currentSheet.name.substr(5, 4);
        let previousYear = previousYearSheet.name.substr(5, 4);
        OfficeHelpers.UI.notify("Two Year Tax Due Comparison", `Tax due for ${currentYear} was ${currentTaxDueRange.text[0][0]}\nTax due for ${previousYear} was ${previousTaxDueRange.text[0][0]}`)

        await context.sync();
    });
Excel.WorksheetCollection.getNext:
  - |-
    await Excel.run(async (context) => {
        const sheets = context.workbook.worksheets;

        // We don't want to include the default worksheet that was created
        // when the workbook was created, so our "firstSheet" will be the one
        // after the literal first. Note chaining of navigation methods.
        const firstSheet = sheets.getFirst().getNext();
        const lastSheet = sheets.getLast();
        const firstTaxRateRange = firstSheet.getRange("B2");
        const lastTaxRateRange = lastSheet.getRange("B2");

        firstSheet.load("name");
        lastSheet.load("name");
        firstTaxRateRange.load("text");
        lastTaxRateRange.load("text");

        await context.sync();

        let firstYear = firstSheet.name.substr(5, 4);
        let lastYear = lastSheet.name.substr(5, 4);
        OfficeHelpers.UI.notify(`Tax Rate change from ${firstYear} to ${lastYear}`, `Tax rate for ${firstYear}: ${firstTaxRateRange.text[0][0]}\nTax rate for ${lastYear}: ${lastTaxRateRange.text[0][0]}`)

        await context.sync();
    });
Excel.ConditionalFormatCollection.getFirst:
  - |-
    await Excel.run(async (context) => {
        const sheets = context.workbook.worksheets;

        // We don't want to include the default worksheet that was created
        // when the workbook was created, so our "firstSheet" will be the one
        // after the literal first. Note chaining of navigation methods.
        const firstSheet = sheets.getFirst().getNext();
        const lastSheet = sheets.getLast();
        const firstTaxRateRange = firstSheet.getRange("B2");
        const lastTaxRateRange = lastSheet.getRange("B2");

        firstSheet.load("name");
        lastSheet.load("name");
        firstTaxRateRange.load("text");
        lastTaxRateRange.load("text");

        await context.sync();

        let firstYear = firstSheet.name.substr(5, 4);
        let lastYear = lastSheet.name.substr(5, 4);
        OfficeHelpers.UI.notify(`Tax Rate change from ${firstYear} to ${lastYear}`, `Tax rate for ${firstYear}: ${firstTaxRateRange.text[0][0]}\nTax rate for ${lastYear}: ${lastTaxRateRange.text[0][0]}`)

        await context.sync();
    });
Excel.ConditionalFormat.getLast:
  - |-
    await Excel.run(async (context) => {
        const sheets = context.workbook.worksheets;

        // We don't want to include the default worksheet that was created
        // when the workbook was created, so our "firstSheet" will be the one
        // after the literal first. Note chaining of navigation methods.
        const firstSheet = sheets.getFirst().getNext();
        const lastSheet = sheets.getLast();
        const firstTaxRateRange = firstSheet.getRange("B2");
        const lastTaxRateRange = lastSheet.getRange("B2");

        firstSheet.load("name");
        lastSheet.load("name");
        firstTaxRateRange.load("text");
        lastTaxRateRange.load("text");

        await context.sync();

        let firstYear = firstSheet.name.substr(5, 4);
        let lastYear = lastSheet.name.substr(5, 4);
        OfficeHelpers.UI.notify(`Tax Rate change from ${firstYear} to ${lastYear}`, `Tax rate for ${firstYear}: ${firstTaxRateRange.text[0][0]}\nTax rate for ${lastYear}: ${lastTaxRateRange.text[0][0]}`)

        await context.sync();
    });
Excel.ColorScaleConditionalFormat.add:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B2:M5");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.colorScale);
        const criteria = {
            minimum: { formula: null, type: Excel.ConditionalFormatColorCriterionType.lowestValue, color: "blue" },
            midpoint: { formula: "50", type: Excel.ConditionalFormatColorCriterionType.percent, color: "yellow" },
            maximum: { formula: null, type: Excel.ConditionalFormatColorCriterionType.highestValue, color: "red" }
        };
        conditionalFormat.colorScale.criteria = criteria;

        await context.sync();
    });
Excel.ConditionalFormat.colorScale:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B2:M5");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.colorScale);
        const criteria = {
            minimum: { formula: null, type: Excel.ConditionalFormatColorCriterionType.lowestValue, color: "blue" },
            midpoint: { formula: "50", type: Excel.ConditionalFormatColorCriterionType.percent, color: "yellow" },
            maximum: { formula: null, type: Excel.ConditionalFormatColorCriterionType.highestValue, color: "red" }
        };
        conditionalFormat.colorScale.criteria = criteria;

        await context.sync();
    });
Excel.PresetCriteriaConditionalFormat.criteria:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B2:M5");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.colorScale);
        const criteria = {
            minimum: { formula: null, type: Excel.ConditionalFormatColorCriterionType.lowestValue, color: "blue" },
            midpoint: { formula: "50", type: Excel.ConditionalFormatColorCriterionType.percent, color: "yellow" },
            maximum: { formula: null, type: Excel.ConditionalFormatColorCriterionType.highestValue, color: "red" }
        };
        conditionalFormat.colorScale.criteria = criteria;

        await context.sync();
    });
Excel.ConditionalPresetCriteriaRule.preset:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B2:M5");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.presetCriteria);
        conditionalFormat.preset.format.font.color = "white";
        conditionalFormat.preset.rule = { criterion: Excel.ConditionalFormatPresetCriterion.oneStdDevAboveAverage };

        await context.sync();
    });
Excel.ConditionalFormat.rule:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B2:M5");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.presetCriteria);
        conditionalFormat.preset.format.font.color = "white";
        conditionalFormat.preset.rule = { criterion: Excel.ConditionalFormatPresetCriterion.oneStdDevAboveAverage };

        await context.sync();
    });
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats.add(Excel.ConditionalFormatType.custom);
        conditionalFormat.custom.rule.formula = '=IF(B8>INDIRECT("RC[-1]",0),TRUE)';
        conditionalFormat.custom.format.font.color = "green";

        await context.sync();
    });
Excel.DataBarConditionalFormat.criterion:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B2:M5");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.presetCriteria);
        conditionalFormat.preset.format.font.color = "white";
        conditionalFormat.preset.rule = { criterion: Excel.ConditionalFormatPresetCriterion.oneStdDevAboveAverage };

        await context.sync();
    });
Excel.ConditionalFormat.dataBar:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.dataBar);
        conditionalFormat.dataBar.barDirection = Excel.ConditionalDataBarDirection.leftToRight;

        await context.sync();
    });
Excel.IconSetConditionalFormat.barDirection:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.dataBar);
        conditionalFormat.dataBar.barDirection = Excel.ConditionalDataBarDirection.leftToRight;

        await context.sync();
    });
Excel.IconSetConditionalFormat.iconSet:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.iconSet);
        const iconSetCF = conditionalFormat.iconSet;
        iconSetCF.style = Excel.IconSet.threeTriangles;

        /*
            The iconSetCF.criteria array is automatically prepopulated with
            criterion elements whose properties have been given default settings.
            You can't write to each property of a criterion directly. Instead,
            replace the whole criteria object.

            With a "three*" icon set style, such as "threeTriangles", the third
            element in the criteria array (criteria[2]) defines the "top" icon;
            e.g., a green triangle. The second (criteria[1]) defines the "middle"
            icon, The first (criteria[0]) defines the "low" icon, but it
            can often be left empty as this method does below, because every
            cell that does not match the other two criteria always gets the low
            icon.            
        */
        iconSetCF.criteria = [
            {} as any,
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=700"
            },
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=1000",
            }
        ];

        await context.sync();
    });
Excel.ConditionalIconCriterion.style:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.iconSet);
        const iconSetCF = conditionalFormat.iconSet;
        iconSetCF.style = Excel.IconSet.threeTriangles;

        /*
            The iconSetCF.criteria array is automatically prepopulated with
            criterion elements whose properties have been given default settings.
            You can't write to each property of a criterion directly. Instead,
            replace the whole criteria object.

            With a "three*" icon set style, such as "threeTriangles", the third
            element in the criteria array (criteria[2]) defines the "top" icon;
            e.g., a green triangle. The second (criteria[1]) defines the "middle"
            icon, The first (criteria[0]) defines the "low" icon, but it
            can often be left empty as this method does below, because every
            cell that does not match the other two criteria always gets the low
            icon.            
        */
        iconSetCF.criteria = [
            {} as any,
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=700"
            },
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=1000",
            }
        ];

        await context.sync();
    });
Excel.ConditionalIconCriterion.criteria:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.iconSet);
        const iconSetCF = conditionalFormat.iconSet;
        iconSetCF.style = Excel.IconSet.threeTriangles;

        /*
            The iconSetCF.criteria array is automatically prepopulated with
            criterion elements whose properties have been given default settings.
            You can't write to each property of a criterion directly. Instead,
            replace the whole criteria object.

            With a "three*" icon set style, such as "threeTriangles", the third
            element in the criteria array (criteria[2]) defines the "top" icon;
            e.g., a green triangle. The second (criteria[1]) defines the "middle"
            icon, The first (criteria[0]) defines the "low" icon, but it
            can often be left empty as this method does below, because every
            cell that does not match the other two criteria always gets the low
            icon.            
        */
        iconSetCF.criteria = [
            {} as any,
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=700"
            },
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=1000",
            }
        ];

        await context.sync();
    });
Excel.ConditionalIconCriterion.type:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.iconSet);
        const iconSetCF = conditionalFormat.iconSet;
        iconSetCF.style = Excel.IconSet.threeTriangles;

        /*
            The iconSetCF.criteria array is automatically prepopulated with
            criterion elements whose properties have been given default settings.
            You can't write to each property of a criterion directly. Instead,
            replace the whole criteria object.

            With a "three*" icon set style, such as "threeTriangles", the third
            element in the criteria array (criteria[2]) defines the "top" icon;
            e.g., a green triangle. The second (criteria[1]) defines the "middle"
            icon, The first (criteria[0]) defines the "low" icon, but it
            can often be left empty as this method does below, because every
            cell that does not match the other two criteria always gets the low
            icon.            
        */
        iconSetCF.criteria = [
            {} as any,
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=700"
            },
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=1000",
            }
        ];

        await context.sync();
    });
Excel.ConditionalFormat.operator:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.iconSet);
        const iconSetCF = conditionalFormat.iconSet;
        iconSetCF.style = Excel.IconSet.threeTriangles;

        /*
            The iconSetCF.criteria array is automatically prepopulated with
            criterion elements whose properties have been given default settings.
            You can't write to each property of a criterion directly. Instead,
            replace the whole criteria object.

            With a "three*" icon set style, such as "threeTriangles", the third
            element in the criteria array (criteria[2]) defines the "top" icon;
            e.g., a green triangle. The second (criteria[1]) defines the "middle"
            icon, The first (criteria[0]) defines the "low" icon, but it
            can often be left empty as this method does below, because every
            cell that does not match the other two criteria always gets the low
            icon.            
        */
        iconSetCF.criteria = [
            {} as any,
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=700"
            },
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=1000",
            }
        ];

        await context.sync();
    });
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B16:D18");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.containsText);
        conditionalFormat.textComparison.format.font.color = "red";
        conditionalFormat.textComparison.rule = { operator: Excel.ConditionalTextOperator.contains, text: "Delayed" };

        await context.sync();
    });
Excel.TextConditionalFormat.formula:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.iconSet);
        const iconSetCF = conditionalFormat.iconSet;
        iconSetCF.style = Excel.IconSet.threeTriangles;

        /*
            The iconSetCF.criteria array is automatically prepopulated with
            criterion elements whose properties have been given default settings.
            You can't write to each property of a criterion directly. Instead,
            replace the whole criteria object.

            With a "three*" icon set style, such as "threeTriangles", the third
            element in the criteria array (criteria[2]) defines the "top" icon;
            e.g., a green triangle. The second (criteria[1]) defines the "middle"
            icon, The first (criteria[0]) defines the "low" icon, but it
            can often be left empty as this method does below, because every
            cell that does not match the other two criteria always gets the low
            icon.            
        */
        iconSetCF.criteria = [
            {} as any,
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=700"
            },
            {
                type: Excel.ConditionalFormatIconRuleType.number,
                operator: Excel.ConditionalIconCriterionOperator.greaterThanOrEqual,
                formula: "=1000",
            }
        ];

        await context.sync();
    });
Excel.TextConditionalFormat.textComparison:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B16:D18");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.containsText);
        conditionalFormat.textComparison.format.font.color = "red";
        conditionalFormat.textComparison.rule = { operator: Excel.ConditionalTextOperator.contains, text: "Delayed" };

        await context.sync();
    });
Excel.ConditionalTextComparisonRule.format:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B16:D18");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.containsText);
        conditionalFormat.textComparison.format.font.color = "red";
        conditionalFormat.textComparison.rule = { operator: Excel.ConditionalTextOperator.contains, text: "Delayed" };

        await context.sync();
    });
Excel.ConditionalTextComparisonRule.rule:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B16:D18");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.containsText);
        conditionalFormat.textComparison.format.font.color = "red";
        conditionalFormat.textComparison.rule = { operator: Excel.ConditionalTextOperator.contains, text: "Delayed" };

        await context.sync();
    });
Excel.CellValueConditionalFormat.text:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B16:D18");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.containsText);
        conditionalFormat.textComparison.format.font.color = "red";
        conditionalFormat.textComparison.rule = { operator: Excel.ConditionalTextOperator.contains, text: "Delayed" };

        await context.sync();
    });
Excel.CellValueConditionalFormat.cellValue:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B21:E23");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.cellValue);
        conditionalFormat.cellValue.format.font.color = "red";
        conditionalFormat.cellValue.rule = { formula1: "=0", operator: "LessThan" };

        await context.sync();
    });
Excel.ConditionalCellValueRule.format:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B21:E23");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.cellValue);
        conditionalFormat.cellValue.format.font.color = "red";
        conditionalFormat.cellValue.rule = { formula1: "=0", operator: "LessThan" };

        await context.sync();
    });
Excel.ConditionalCellValueRule.rule:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B21:E23");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.cellValue);
        conditionalFormat.cellValue.format.font.color = "red";
        conditionalFormat.cellValue.rule = { formula1: "=0", operator: "LessThan" };

        await context.sync();
    });
Excel.ConditionalFormat.formula1:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B21:E23");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.cellValue);
        conditionalFormat.cellValue.format.font.color = "red";
        conditionalFormat.cellValue.rule = { formula1: "=0", operator: "LessThan" };

        await context.sync();
    });
Excel.CustomConditionalFormat.operator:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B21:E23");
        const conditionalFormat = range.conditionalFormats
            .add(Excel.ConditionalFormatType.cellValue);
        conditionalFormat.cellValue.format.font.color = "red";
        conditionalFormat.cellValue.rule = { formula1: "=0", operator: "LessThan" };

        await context.sync();
    });
Excel.CustomConditionalFormat.custom:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats.add(Excel.ConditionalFormatType.custom);
        conditionalFormat.custom.rule.formula = '=IF(B8>INDIRECT("RC[-1]",0),TRUE)';
        conditionalFormat.custom.format.font.color = "green";

        await context.sync();
    });
Excel.ConditionalFormatRule.format:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats.add(Excel.ConditionalFormatType.custom);
        conditionalFormat.custom.rule.formula = '=IF(B8>INDIRECT("RC[-1]",0),TRUE)';
        conditionalFormat.custom.format.font.color = "green";

        await context.sync();
    });
Excel.ConditionalFormatCollection.formula:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B8:E13");
        const conditionalFormat = range.conditionalFormats.add(Excel.ConditionalFormatType.custom);
        conditionalFormat.custom.rule.formula = '=IF(B8>INDIRECT("RC[-1]",0),TRUE)';
        conditionalFormat.custom.format.font.color = "green";

        await context.sync();
    });
Excel.ConditionalFormat.type:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const worksheetRange = sheet.getRange();
        worksheetRange.conditionalFormats.load("type");

        await context.sync();

        let cfRangePairs: { cf: Excel.ConditionalFormat, range: Excel.Range }[] = [];
        worksheetRange.conditionalFormats.items.forEach(item => {
            cfRangePairs.push({
                cf: item,
                range: item.getRange().load("address")
            });
        });

        await context.sync();

        $("#conditional-formats li").remove();
        if (cfRangePairs.length > 0) {
            cfRangePairs.forEach(item => {
                let $p = $("<p></p>").text(
                    `${item.cf.type}`)
                let $li = $(`<li></li>`);
                $li.append($p);
                $("#conditional-formats").append($li);
                $(".conditional-formats").show()[0].scrollIntoView();
            })
        }
        else {
            OfficeHelpers.UI.notify("None to display", "No conditional formats in workbook", "warning");
        }
    });
Excel.Range.getRange:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const worksheetRange = sheet.getRange();
        worksheetRange.conditionalFormats.load("type");

        await context.sync();

        let cfRangePairs: { cf: Excel.ConditionalFormat, range: Excel.Range }[] = [];
        worksheetRange.conditionalFormats.items.forEach(item => {
            cfRangePairs.push({
                cf: item,
                range: item.getRange().load("address")
            });
        });

        await context.sync();

        $("#conditional-formats li").remove();
        if (cfRangePairs.length > 0) {
            cfRangePairs.forEach(item => {
                let $p = $("<p></p>").text(
                    `${item.cf.type}`)
                let $li = $(`<li></li>`);
                $li.append($p);
                $("#conditional-formats").append($li);
                $(".conditional-formats").show()[0].scrollIntoView();
            })
        }
        else {
            OfficeHelpers.UI.notify("None to display", "No conditional formats in workbook", "warning");
        }
    });
Excel.RangeHyperlink.clearAll:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange();
        range.conditionalFormats.clearAll();

        await context.sync();

        $(".conditional-formats").hide();
    });
Excel.RangeHyperlink.hyperlink:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Orders");

        let productsRange = sheet.getRange("A3:A5");
        productsRange.load("values");

        await context.sync();

        // Create a hyperlink to a URL 
        // for each product name in the first table.
        for (let i = 0; i < productsRange.values.length; i++) {
            let cellRange = productsRange.getCell(i, 0);
            let cellText = productsRange.values[i][0];

            let hyperlink = {
                textToDisplay: cellText,
                screenTip: "Search Bing for '" + cellText + "'",
                address: "https://www.bing.com?q=" + cellText
            }
            cellRange.hyperlink = hyperlink;
        }

        await context.sync();

        OfficeHelpers.UI.notify("Created a hyperlink to a URL for each of the products in the first table.");
    });
Excel.RangeHyperlink.address:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Orders");

        let productsRange = sheet.getRange("A3:A5");
        productsRange.load("values");

        await context.sync();

        // Create a hyperlink to a URL 
        // for each product name in the first table.
        for (let i = 0; i < productsRange.values.length; i++) {
            let cellRange = productsRange.getCell(i, 0);
            let cellText = productsRange.values[i][0];

            let hyperlink = {
                textToDisplay: cellText,
                screenTip: "Search Bing for '" + cellText + "'",
                address: "https://www.bing.com?q=" + cellText
            }
            cellRange.hyperlink = hyperlink;
        }

        await context.sync();

        OfficeHelpers.UI.notify("Created a hyperlink to a URL for each of the products in the first table.");
    });
Excel.RangeHyperlink.screenTip:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Orders");

        let productsRange = sheet.getRange("A3:A5");
        productsRange.load("values");

        await context.sync();

        // Create a hyperlink to a URL 
        // for each product name in the first table.
        for (let i = 0; i < productsRange.values.length; i++) {
            let cellRange = productsRange.getCell(i, 0);
            let cellText = productsRange.values[i][0];

            let hyperlink = {
                textToDisplay: cellText,
                screenTip: "Search Bing for '" + cellText + "'",
                address: "https://www.bing.com?q=" + cellText
            }
            cellRange.hyperlink = hyperlink;
        }

        await context.sync();

        OfficeHelpers.UI.notify("Created a hyperlink to a URL for each of the products in the first table.");
    });
Excel.RangeFormat.textToDisplay:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Orders");

        let productsRange = sheet.getRange("A3:A5");
        productsRange.load("values");

        await context.sync();

        // Create a hyperlink to a URL 
        // for each product name in the first table.
        for (let i = 0; i < productsRange.values.length; i++) {
            let cellRange = productsRange.getCell(i, 0);
            let cellText = productsRange.values[i][0];

            let hyperlink = {
                textToDisplay: cellText,
                screenTip: "Search Bing for '" + cellText + "'",
                address: "https://www.bing.com?q=" + cellText
            }
            cellRange.hyperlink = hyperlink;
        }

        await context.sync();

        OfficeHelpers.UI.notify("Created a hyperlink to a URL for each of the products in the first table.");
    });
Excel.WorksheetFreezePanes.documentReference:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Orders");

        let productsRange = sheet.getRange("A9:A11");
        productsRange.load("values");

        await context.sync();

        // Create a hyperlink to a location within the workbook
        // for each product name in the second table.
        for (let i = 0; i < productsRange.values.length; i++) {
            let cellRange = productsRange.getCell(i, 0);
            let cellText = productsRange.values[i][0];

            let hyperlink = {
                textToDisplay: cellText,
                screenTip: "Navigate to the '" + cellText + "' worksheet",
                documentReference: cellText + "!A1"
            }
            cellRange.hyperlink = hyperlink;
        }

        await context.sync();

        OfficeHelpers.UI.notify("Created a hyperlink to a location in this workbook for each of the products in the second table.");
    });
Excel.WorksheetFreezePanes.textOrientation:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const range = sheet.getRange("B2:E2");

        // Set textOrientation to either an integer between -90 and 90
        // or to 180 for vertically-oriented text.
        range.format.textOrientation = 90;

        await context.sync();
    });
Excel.WorksheetFreezePanes.freezeAt:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        // Freeze the specified range in top-and-left-most pane of the worksheet.
        sheet.freezePanes.freezeAt(sheet.getRange("H2:K5"));

        await context.sync();
    });
Excel.WorksheetFreezePanes.freezeColumns:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        // Freeze the first two columns in the worksheet.
        sheet.freezePanes.freezeColumns(2);

        await context.sync();
    });
Excel.WorksheetFreezePanes.freezeRows:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        // Freeze the top two rows in the worksheet.
        sheet.freezePanes.freezeRows(2);

        await context.sync();
    });
Excel.Worksheet.getLocationOrNullObject:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        const frozenRange = sheet.freezePanes.getLocationOrNullObject();
        frozenRange.load("address");

        await context.sync();

        if (frozenRange.isNullObject) {
            OfficeHelpers.UI.notify(`The worksheet does not contain a frozen pane.`);
        } else {
            OfficeHelpers.UI.notify(`The address of the frozen range (cells that are frozen in the top-and-left-most pane) is "${frozenRange.address}"`);
        }
    });
Excel.Worksheet.unfreeze:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        sheet.freezePanes.unfreeze();

        await context.sync();
    });
Excel.ChartTrendlineCollection.gridlines:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getActiveWorksheet();
        sheet.showGridlines = true;

        await context.sync();
    });
Excel.ChartTrendline.tabColor:
  - |-
    await Excel.run(async (context) => {
        const activeSheet = context.workbook.worksheets.getActiveWorksheet();
        activeSheet.tabColor = "#FF0000";

        await context.sync();
    });
Excel.ChartTrendlineFormat.add:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let seriesCollection = sheet.charts.getItemAt(0).series;

         // Add a trendline.  
        seriesCollection.getItemAt(0).trendlines.add("Linear");

        await context.sync();
    });
Excel.ChartTrendlineFormat.type:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let seriesCollection = sheet.charts.getItemAt(0).series;

        // Get the trendline for series 1 and load its type property.  
        let trendline = seriesCollection.getItemAt(0).trendlines.getItem(0);
        trendline.load("type");

        await context.sync();

        console.log("The trendline type is:" + trendline.type);  
    });
Excel.ChartSeriesCollection.line:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let seriesCollection = sheet.charts.getItemAt(0).series; 

        // Get the color of the chart trendline. 
        // In this example, it's #4472c4 which is blue.
        let trendline = seriesCollection.getItemAt(0).trendlines.getItem(0);
        let line = trendline.format.line;
        line.load("color");

        await context.sync();

        console.log("The trendline color is:" + line.color);
    });
Excel.ChartSeries.line:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let seriesCollection = sheet.charts.getItemAt(0).series; 
        let trendline = seriesCollection.getItemAt(0).trendlines.getItem(0);

        // Set format of the trendline to a solid, red line.
        let line = trendline.format.line;
        line.color = '#FF0000';

        await context.sync();

        console.log("The trendline color has been set to:" + line.color);
    });
Excel.ChartAxis.delete:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let seriesCollection = sheet.charts.getItemAt(0).series;
        let series = seriesCollection.getItemAt(0);

        // Delete the first series.
        series.delete();

        await context.sync();
    });
Excel.ChartAxis.setValues:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let seriesCollection = sheet.charts.getItemAt(0).series;

        // Add new series.
        let series = seriesCollection.add("New Product");
        let values = sheet.getRange("E2:E7");

        // Set the vertical values for the series.
        series.setValues(values);
        seriesCollection.load("count");

        await context.sync();

        OfficeHelpers.UI.notify("Number of series  = " + seriesCollection.count);
    });
Excel.ChartFormatString.displayUnit:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let chart = sheet.charts.getItemAt(0);
        let categoryAxis = chart.axes.categoryAxis;
        let valueAxis = chart.axes.valueAxis;

        // Load to get display unit.
        valueAxis.load("displayUnit");
       
        await context.sync();

        OfficeHelpers.UI.notify("The vertical axis display unit is: " +  valueAxis.displayUnit);
    });
Excel.ChartFill.showDisplayUnitLabel:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let chart = sheet.charts.getItemAt(0);
        let axis = chart.axes.valueAxis;

        // Remove display unit.
        axis.showDisplayUnitLabel = false;

        await context.sync();
    });
Excel.DocumentProperties.font:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let chart = sheet.charts.getItemAt(0);
        chart.legend.visible = true;

        // Format the legend font.
        let font = chart.legend.format.font;
        font.bold = true;
        font.color = "red";
        font.italic = true;
        font.size = 15;
        font.name = "Calibri";
        font.underline = "Single";

        await context.sync();
    });
Excel.Style.setSolidColor:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");

        let pointsCollection = sheet.charts.getItemAt(0).series.getItemAt(0).points;
        let point = pointsCollection.getItemAt(2);

        // Set color for chart point.
        point.format.fill.setSolidColor('red');

        await context.sync();

        OfficeHelpers.UI.notify("Successfully set chart point color to red (for the third item in series 1).");            
    });
Excel.StyleCollection.properties:
  - |-
    await Excel.run(async (context) => {
        let titleValue = "Excel document properties API";
        let subjectValue = "Set and get document properties";
        let keywordsValue = "Set and get operations";
        let commentsValue = "This is an Excel document properties API code sample";
        let categoryValue = "Office Add-ins";
        let managerValue = "John";
        let companyValue = "Microsoft";

        let docProperties = context.workbook.properties;

        // Set the writeable document properties.
        docProperties.title = titleValue;
        docProperties.subject = subjectValue;
        docProperties.keywords = keywordsValue;
        docProperties.comments = commentsValue;
        docProperties.category = categoryValue;
        docProperties.manager = managerValue;
        docProperties.company = companyValue;

        await context.sync();

        OfficeHelpers.UI.notify("Set the following document properties: title, subject, keywords, comments, category, manager, company.");
    });
Excel.StyleCollection.style:
  - |-
    await Excel.run(async (context) => {
        let worksheet = context.workbook.worksheets.getItem("Sample");
        let range = worksheet.getRange("A1:E1");

        // Apply built-in style. 
        // Styles are in the Home tab ribbon.
        range.style = Excel.BuiltInStyle.neutral;
        range.format.horizontalAlignment = "Right";

        await context.sync();
    });
Excel.Style.getItem:
  - |-
    await Excel.run(async (context) => {
        let styles = context.workbook.styles;

        // Add a new style to the style collection.
        // Styles is in the Home tab ribbon.
        styles.add("Diagonal Orientation Style");
              
        let newStyle = styles.getItem("Diagonal Orientation Style");
        
        // The "Diagonal Orientation Style" properties.
        newStyle.textOrientation = 38;
        newStyle.autoIndent = true;
        newStyle.includeProtection = true;
        newStyle.shrinkToFit = true;
        newStyle.locked = false;
        
        await context.sync();

        OfficeHelpers.UI.notify("Successfully added a new style with diagonal orientation to the Home tab ribbon.");
    });
Excel.Style.add:
  - |-
    await Excel.run(async (context) => {
        let styles = context.workbook.styles;

        // Add a new style to the style collection.
        // Styles is in the Home tab ribbon.
        styles.add("Diagonal Orientation Style");
              
        let newStyle = styles.getItem("Diagonal Orientation Style");
        
        // The "Diagonal Orientation Style" properties.
        newStyle.textOrientation = 38;
        newStyle.autoIndent = true;
        newStyle.includeProtection = true;
        newStyle.shrinkToFit = true;
        newStyle.locked = false;
        
        await context.sync();

        OfficeHelpers.UI.notify("Successfully added a new style with diagonal orientation to the Home tab ribbon.");
    });
Excel.Style.font:
  - |-
    await Excel.run(async (context) => {
        let style = context.workbook.styles.getItem("Normal");
        style.font.load("bold, color, italic, name, size");
        style.fill.load("color");

        await context.sync();

        console.log("Bold: " + style.font.bold);
        console.log("Font color: " + style.font.color);
        console.log("Italic: " + style.font.italic);
        console.log("Name: " + style.font.name);
        console.log("Size: " + style.font.size);
        console.log("Fill color: " + style.fill.color);
    });
Excel.Style.delete:
  - |-
    await Excel.run(async (context) => {
        let style = context.workbook.styles.getItem("Diagonal Orientation Style");

        // Delete the diagonal orientation style from the style collection.
        // Styles are in the Home tab ribbon.
        style.delete();

        await context.sync();

        OfficeHelpers.UI.notify("Successfully deleted the diagonal orientation style from the Home tab ribbon.");
    });
Excel.TableDataChangedEvent.horizontalAlignment:
  - |-
    await Excel.run(async (context) => {
        let style = context.workbook.styles.getItem("Diagonal Orientation Style");            
        style.load("textOrientation, horizontalAlignment, autoIndent, readingOrder, wrapText, includeProtection, shrinkToFit, locked");

        await context.sync();

        console.log("Orientation: " + style.textOrientation);
        console.log("Horizontal alignment: " + style.horizontalAlignment);
        console.log("Add indent: " + style.autoIndent);
        console.log("Reading order: " + style.readingOrder);
        console.log("Wrap text: " + style.wrapText);
        console.log("Include protection: " + style.includeProtection);
        console.log("Shrink to fit: " + style.shrinkToFit);
        console.log("Style locked: " + style.locked);
    });
Excel.TableDataChangedEvent.fill:
  - |-
    await Excel.run(async (context) => {
        let worksheet = context.workbook.worksheets.getItem("Sample");
        let range = worksheet.getRange("A1:E1");

        // Apply built-in style. 
        // Styles are in the Home tab ribbon.
        range.style = Excel.BuiltInStyle.neutral;
        range.format.horizontalAlignment = "Right";

        await context.sync();
    });
Excel.TableSelectionChangedEvent.address:
  - |-
    async function onSelectionChange(args) {
        await Excel.run(async (context) => {
            console.log("Handler for table onSelectionChanged event has been triggered.  The new selection is : " + args.address);
        });
    }
Excel.WorksheetAddedEvent.onChanged:
  - |-
    await Excel.run(async (context) => {
        let table = context.workbook.tables.getItemAt(0);
        table.onChanged.add(onChange);

        await context.sync();

        OfficeHelpers.UI.notify("A handler has been registered for the onChanged event",
            "Try changing a cell value in the table, and watch the console output.");
    });
Excel.WorksheetDataChangedEvent.onSelectionChanged:
  - |-
    await Excel.run(async (context) => {
        let table = context.workbook.tables.getItemAt(0);
        table.onSelectionChanged.add(onSelectionChange);

        await context.sync();

        OfficeHelpers.UI.notify("A handler has been registered for table onSelectionChanged event",
            "Try changing a range selection in the table, and watch the console output.");
    });
Excel.WorksheetAddedEvent.onAdded:
  - |-
    await Excel.run(async (context) => {
        let sheet = context.workbook.worksheets;
        sheet.onAdded.add(onWorksheetAdd);

        await context.sync();

        OfficeHelpers.UI.notify("A handler has been registered for the OnAdded event",
            "Try adding a worksheet, and watch the console output.");
    });
Excel.WorksheetDeactivatedEvent.onChanged:
  - |-
    await Excel.run(async (context) => {
        let sheet = context.workbook.worksheets.getItem("Sample");
        sheet.onChanged.add(onChange);

        await context.sync();

        OfficeHelpers.UI.notify("A handler has been registered for the onChanged event.");
    });
Excel.WorksheetActivatedEvent.worksheetId:
  - |-
    async function onWorksheetAdd(event) {
        await Excel.run(async (context) => {
            console.log("Handler for worksheet onAdded event has been triggered.  Newly added worksheet Id : " + event.worksheetId);
        });
    }
Excel.ChartSeries.onDeactivated:
  - |-
    await Excel.run(async (context) => {
        let sheets = context.workbook.worksheets;
        sheets.onDeactivated.add(onDeactivate);

        await context.sync();

        OfficeHelpers.UI.notify("A handler has been registered for the OnDeactivate event",
            "Try selecting a different worksheet, and watch the console output.");   
    });
Excel.ChartSeries.onActivated:
  - |-
    await Excel.run(async (context) => {
        let sheets = context.workbook.worksheets;
        sheets.onActivated.add(onActivate);

        await context.sync();

        OfficeHelpers.UI.notify("A handler has been registered for the OnActivate event",
            "Try selecting a different worksheet, and watch the console output.");   
    });
Excel.ChartSeries.markerStyle:
  - |-
    await Excel.run(async (context) => {
        let sheet = context.workbook.worksheets.getItem("Sample");
        let salesTable = sheet.tables.getItem("SalesTable");
        let dataRange = sheet.getRange("A1:E7");

        // Create an XY scatter chart.
        let chart = sheet.charts.add("XYScatterSmooth", dataRange, "Auto");
        chart.title.text = "Bicycle Parts Quarterly Sales"; 
      
        let series = chart.series;
        let series0 = series.getItemAt(0);
        let series1 = series.getItemAt(1);
        let series2 = series.getItemAt(2);
        let series3 = series.getItemAt(3);

        // Set markers.
        series0.markerStyle = "Dash";
        series0.markerForegroundColor = "black";
        series1.markerStyle = "Star";
        series1.markerForegroundColor = "black";
        series2.markerStyle = "X";
        series2.markerSize = 12;
        series3.markerStyle = "Triangle";
        series3.markerBackgroundColor = "purple";

        await context.sync();
    });
Excel.ChartSeries.markerSize:
  - |-
    await Excel.run(async (context) => {
        let sheet = context.workbook.worksheets.getItem("Sample");
        let salesTable = sheet.tables.getItem("SalesTable");
        let dataRange = sheet.getRange("A1:E7");

        // Create an XY scatter chart.
        let chart = sheet.charts.add("XYScatterSmooth", dataRange, "Auto");
        chart.title.text = "Bicycle Parts Quarterly Sales"; 
      
        let series = chart.series;
        let series0 = series.getItemAt(0);
        let series1 = series.getItemAt(1);
        let series2 = series.getItemAt(2);
        let series3 = series.getItemAt(3);

        // Set markers.
        series0.markerStyle = "Dash";
        series0.markerForegroundColor = "black";
        series1.markerStyle = "Star";
        series1.markerForegroundColor = "black";
        series2.markerStyle = "X";
        series2.markerSize = 12;
        series3.markerStyle = "Triangle";
        series3.markerBackgroundColor = "purple";

        await context.sync();
    });
Excel.TableSelectionChangedEvent.markerForegroundColor:
  - |-
    await Excel.run(async (context) => {
        let sheet = context.workbook.worksheets.getItem("Sample");
        let salesTable = sheet.tables.getItem("SalesTable");
        let dataRange = sheet.getRange("A1:E7");

        // Create an XY scatter chart.
        let chart = sheet.charts.add("XYScatterSmooth", dataRange, "Auto");
        chart.title.text = "Bicycle Parts Quarterly Sales"; 
      
        let series = chart.series;
        let series0 = series.getItemAt(0);
        let series1 = series.getItemAt(1);
        let series2 = series.getItemAt(2);
        let series3 = series.getItemAt(3);

        // Set markers.
        series0.markerStyle = "Dash";
        series0.markerForegroundColor = "black";
        series1.markerStyle = "Star";
        series1.markerForegroundColor = "black";
        series2.markerStyle = "X";
        series2.markerSize = 12;
        series3.markerStyle = "Triangle";
        series3.markerBackgroundColor = "purple";

        await context.sync();
    });
Excel.TableSelectionChangedEvent.markerBackgroundColor:
  - |-
    await Excel.run(async (context) => {
        let sheet = context.workbook.worksheets.getItem("Sample");
        let salesTable = sheet.tables.getItem("SalesTable");
        let dataRange = sheet.getRange("A1:E7");

        // Create an XY scatter chart.
        let chart = sheet.charts.add("XYScatterSmooth", dataRange, "Auto");
        chart.title.text = "Bicycle Parts Quarterly Sales"; 
      
        let series = chart.series;
        let series0 = series.getItemAt(0);
        let series1 = series.getItemAt(1);
        let series2 = series.getItemAt(2);
        let series3 = series.getItemAt(3);

        // Set markers.
        series0.markerStyle = "Dash";
        series0.markerForegroundColor = "black";
        series1.markerStyle = "Star";
        series1.markerForegroundColor = "black";
        series2.markerStyle = "X";
        series2.markerSize = 12;
        series3.markerStyle = "Triangle";
        series3.markerBackgroundColor = "purple";

        await context.sync();
    });
Excel.TableSelectionChangedEvent.onChanged:
  - |-
    await Excel.run(async (context) => {
        let tables = context.workbook.tables;
        tables.onChanged.add(onChange);

        await context.sync();

        OfficeHelpers.UI.notify("A handler has been registered for the table collection onChanged event",
            "Try changing cell values in the tables, and watch the console output.");
    });
Excel.TableSelectionChangedEvent.worksheetId:
  - |-
    async function onChange(event) {
        await Excel.run(async (context) => {
            let table = context.workbook.tables.getItem(event.tableId);
            let worksheet = context.workbook.worksheets.getItem(event.worksheetId);
            worksheet.load("name");

            await context.sync();

            console.log("Handler for table collection onChanged event has been triggered.  Data changed address : " + event.address);
            console.log("Table Id : " + event.tableId);
            console.log("Worksheet Id : " + worksheet.name);
        });
    }
Excel.TableSelectionChangedEvent.tableId:
  - |-
    async function onChange(event) {
        await Excel.run(async (context) => {
            let table = context.workbook.tables.getItem(event.tableId);
            let worksheet = context.workbook.worksheets.getItem(event.worksheetId);
            worksheet.load("name");

            await context.sync();

            console.log("Handler for table collection onChanged event has been triggered.  Data changed address : " + event.address);
            console.log("Table Id : " + event.tableId);
            console.log("Worksheet Id : " + worksheet.name);
        });
    }
Excel.Workbook.getActiveCell:
  - |-
    await Excel.run(async (context) => {

        let myWorkbook = context.workbook;
        let activeCell = myWorkbook.getActiveCell();
        activeCell.load("address");

        await context.sync();
        
        console.log("The active cell is " + activeCell.address);
    });
Excel.Worksheet.copy:
  - |-
    await Excel.run(async (context) => {

        let myWorkbook = context.workbook;
        let sampleSheet = myWorkbook.worksheets.getActiveWorksheet();
        let copiedSheet = sampleSheet.copy("End")

        sampleSheet.load("name");
        copiedSheet.load("name");

        await context.sync();

        console.log("'" + sampleSheet.name + "' was copied to '" + copiedSheet.name + "'")
    });
Excel.Worksheet.protect:
  - |-
    await Excel.run(async (context) => {
        let activeSheet = context.workbook.worksheets.getActiveWorksheet();
        activeSheet.load("protection/protected");

        await context.sync();

        if (!activeSheet.protection.protected) {
            activeSheet.protection.protect();
        }
    });
  - |-
    let password = await passwordHandler();
    passwordHelper(password);
    await Excel.run(async (context) => {
        let activeSheet = context.workbook.worksheets.getActiveWorksheet();
        activeSheet.load("protection/protected");

        await context.sync();

        if (!activeSheet.protection.protected) {
            activeSheet.protection.protect(null, password);
        }
    });
Excel.Worksheet.unprotect:
  - |-
    await Excel.run(async (context) => {
        let activeSheet = context.workbook.worksheets.getActiveWorksheet();
        activeSheet.protection.unprotect();
    });
  - |-
    let password = await passwordHandler();
    passwordHelper(password);
    await Excel.run(async (context) => {
        let activeSheet = context.workbook.worksheets.getActiveWorksheet();
        activeSheet.protection.unprotect(password);
    });
Excel.Workbook.protect:
  - |-
    await Excel.run(async (context) => {
        let workbook = context.workbook;
        workbook.load("protection/protected");

        await context.sync();

        if (!workbook.protection.protected) {
            workbook.protection.protect();
        }
    });
  - |-
    let password = await passwordHandler();
    passwordHelper(password);
    await Excel.run(async (context) => {
        let workbook = context.workbook;
        workbook.load("protection/protected");

        await context.sync();

        if (!workbook.protection.protected) {
            workbook.protection.protect(password);
        }
    });
Excel.Workbook.unprotect:
  - |-
    await Excel.run(async (context) => {
        let workbook = context.workbook;
        workbook.protection.unprotect();
    });
  - |-
    let password = await passwordHandler();
    passwordHelper(password);
    await Excel.run(async (context) => {
        let workbook = context.workbook;
        workbook.protection.unprotect(password);
    });
