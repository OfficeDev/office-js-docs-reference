CustomFunctions.Error:class:
  - |- 
    /**
     * Returns the #NUM! error as part of a 2-dimensional array.
     * @customfunction
     * @param {number} first First parameter.
     * @param {number} second Second parameter.
     * @param {number} third Third parameter.
     * @returns {number[][]} Three results, as a 2-dimensional array.
     */
    function returnInvalidNumberError(first, second, third) {
      // Use the `CustomFunctions.Error` object to retrieve an invalid number error.
      const error = new CustomFunctions.Error(
        CustomFunctions.ErrorCode.invalidNumber, // Corresponds to the #NUM! error in the Excel UI.
      );

      // Enter logic that processes the first, second, and third input parameters.
      // Imagine that the second calculation results in an invalid number error.
      const firstResult = first;
      const secondResult = error;
      const thirdResult = third;

      // Return the results of the first and third parameter calculations
      // and a #NUM! error in place of the second result.
      return [[firstResult], [secondResult], [thirdResult]];
    };
CustomFunctions.ErrorCode:enum:
  - |- 
    /**
     * Returns the #NUM! error as part of a 2-dimensional array.
     * @customfunction
     * @param {number} first First parameter.
     * @param {number} second Second parameter.
     * @param {number} third Third parameter.
     * @returns {number[][]} Three results, as a 2-dimensional array.
     */
    function returnInvalidNumberError(first, second, third) {
      // Use the `CustomFunctions.Error` object to retrieve an invalid number error.
      const error = new CustomFunctions.Error(
        CustomFunctions.ErrorCode.invalidNumber, // Corresponds to the #NUM! error in the Excel UI.
      );

      // Enter logic that processes the first, second, and third input parameters.
      // Imagine that the second calculation results in an invalid number error.
      const firstResult = first;
      const secondResult = error;
      const thirdResult = third;

      // Return the results of the first and third parameter calculations
      // and a #NUM! error in place of the second result.
      return [[firstResult], [secondResult], [thirdResult]];
      };
Excel.createWorkbook:function(1):
  - |-
    const myFile = <HTMLInputElement>document.getElementById("file");
    const reader = new FileReader();

    reader.onload = (event) => {
        Excel.run((context) => {
        // Remove the metadata before the base64-encoded string.
        const startIndex = reader.result.toString().indexOf("base64,");
        const mybase64 = reader.result.toString().substr(startIndex + 7);

        Excel.createWorkbook(mybase64);
        return context.sync();
        });
    };

    // Read in the file as a data URL so we can parse the base64-encoded string.
    reader.readAsDataURL(myFile.files[0]);
Excel.Application#calculate:member(2):
  - |-
    await Excel.run(async (context) => {
        context.workbook.application.calculate('Full');
        await context.sync();
    });
Excel.Application#load:member(2):
  - |-
    await Excel.run(async (context) => {
        const application = context.workbook.application;
        application.load('calculationMode');
        await context.sync();

        console.log(application.calculationMode);
    });
Excel.Binding#getRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const binding = context.workbook.bindings.getItemAt(0);
        const range = binding.getRange();
        range.load('cellCount');
        await context.sync();

        console.log(range.cellCount);
    });
Excel.Binding#getTable:member(1):
  - |-
    await Excel.run(async (context) => { 
        const binding = context.workbook.bindings.getItemAt(0);
        const table = binding.getTable();
        table.load('name');
        await context.sync();

        console.log(table.name);
    });
Excel.Binding#getText:member(1):
  - |-
    await Excel.run(async (context) => { 
        const binding = context.workbook.bindings.getItemAt(0);
        const text = binding.getText();
        binding.load('text');
        await context.sync();

        console.log(text);
    });
Excel.Binding#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const binding = context.workbook.bindings.getItemAt(0);
        binding.load('type');
        await context.sync();

        console.log(binding.type);
    });
Excel.BindingCollection#getItem:member(1):
  - |-        
    async function onBindingDataChanged(eventArgs) {
        await Excel.run(async (context) => { 
            // Highlight the table related to the binding in orange to indicate data has been changed.
            context.workbook.bindings.getItem(eventArgs.binding.id).getTable().getDataBodyRange().format.fill.color = "Orange";
            await context.sync();
            
            console.log("The value in this table got changed!");
        });
    }
Excel.BindingCollection#getItemAt:member(1):
  - |-
    await Excel.run(async (context) => { 
        const lastPosition = context.workbook.bindings.count - 1;
        const binding = context.workbook.bindings.getItemAt(lastPosition);
        binding.load('type')
        await context.sync();

        console.log(binding.type);
    });
Excel.BindingCollection#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const bindings = context.workbook.bindings;
        bindings.load('items');
        await context.sync();

        for (let i = 0; i < bindings.items.length; i++) {
            console.log(bindings.items[i].id);
        }
    });
Excel.Chart#delete:member(1):
  - |-
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.delete();
        await context.sync(); 
    });
Excel.Chart#getImage:member(1):
  - |-
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        const image = chart.getImage();
        await context.sync(); 
    });
Excel.Chart#legend:member:
  - |-
    // Set to show legend of Chart1 and make it on top of the chart.
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.legend.visible = true;
        chart.legend.position = "Top"; 
        chart.legend.overlay = false; 
        await context.sync()
        
        console.log("Legend Shown ");
    });
Excel.Chart#name:member:
  - |-
    // Rename the chart to new name, resize the chart to 200 points in both height and weight.
    // Move Chart1 to 100 points to the top and left.
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.name = "New Name";
        chart.top = 100;
        chart.left = 100;
        chart.height = 200;
        chart.width = 200;
        await context.sync(); 
    });
Excel.Chart#setData:member(1):
  - |-
    // Set the sourceData to be the range at "A1:B4" and seriesBy to be "Columns".
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sheet1");
        const chart = sheet.charts.getItem("Chart1");
        const sourceData = sheet.getRange("A1:B4");
        chart.setData(sourceData, "Columns");
        await context.sync();
    });
Excel.Chart#setPosition:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Charts";
        const rangeSelection = "A1:B4";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeSelection);
        const sourceData = sheetName + "!" + "A1:B4";
        const chart = context.workbook.worksheets.getItem(sheetName).charts.add("pie", range, "auto");
        chart.width = 500;
        chart.height = 300;
        chart.setPosition("C2", null);
        await context.sync(); 
    });
Excel.Chart#load:member(2):
  - |-
    // Get a chart named "Chart1".
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.load('name');
        await context.sync();

        console.log(chart.name);
    });
Excel.ChartAxes#valueAxis:member:
  - |-
    // Set the maximum, minimum, majorUnit, minorUnit of valueAxis.
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.axes.valueAxis.maximum = 5;
        chart.axes.valueAxis.minimum = 0;
        chart.axes.valueAxis.majorUnit = 1;
        chart.axes.valueAxis.minorUnit = 0.2;
        await context.sync();

        console.log("Axis Settings Changed");
    });
Excel.ChartAxis#load:member(2):
  - |-
    // Get the maximum of Chart Axis from Chart1.
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        const axis = chart.axes.valueAxis;
        axis.load('maximum');
        await context.sync();

        console.log(axis.maximum);
    });
Excel.ChartAxisTitle#load:member(2):
  - |-
    // Add "Values" as the title for the value Axis.
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1"); 
        chart.axes.valueAxis.title.text = "Values";
        await context.sync();
        
        console.log("Axis Title Added ");
    });
Excel.ChartAxisTitle#textOrientation:member:
  - >-
    await Excel.run(async (context) => {
      // Get a chart named "Sales Chart" from the "Sample" worksheet.
      const sheet = context.workbook.worksheets.getItem("Sample");
      let chart = sheet.charts.getItem("Sales Chart");

      // Set the value axis title to "Profits".
      chart.axes.valueAxis.title.text = "Profits";

      /* Set the value axis text orientation to 0.
        For charts with a y-axis, this makes the label on the y-axis horizontal, 
        instead of the default look of rotated-vertically.
        */ 
      chart.axes.valueAxis.title.textOrientation = 0;
      await context.sync();
    });
Excel.ChartCollection#add:member(1):
  - |-
    // Add a chart of chartType "ColumnClustered" on worksheet "Charts" 
    // with sourceData from range "A1:B4" and seriesBy set to "auto".
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sheet1");
        const rangeSelection = "A1:B4";
        const range = sheet.getRange(rangeSelection);
        const chart = sheet.charts.add(
        Excel.ChartType.columnClustered, 
        range, 
        Excel.ChartSeriesBy.auto);
        await context.sync();

        console.log("New Chart Added");
    });
Excel.ChartCollection#getItem:member(1):
  - |-
    // Get the number of charts.
    await Excel.run(async (context) => { 
        const charts = context.workbook.worksheets.getItem("Sheet1").charts;
        charts.load('count');
        await context.sync();
        
        console.log("charts: Count= " + charts.count);
    });
Excel.ChartCollection#getItemAt:member(1):
  - |-
    await Excel.run(async (context) => { 
        const lastPosition = context.workbook.worksheets.getItem("Sheet1").charts.count - 1;
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItemAt(lastPosition);
        await context.sync();

        console.log(chart.name);
    });
Excel.ChartCollection#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const charts = context.workbook.worksheets.getItem("Sheet1").charts;
        charts.load('items');
        await context.sync();
        
        for (let i = 0; i < charts.items.length; i++) {
            console.log(charts.items[i].name);
        }
    });
Excel.ChartCollection#onAdded:member:
  - |-
    await Excel.run(async (context) => {
        context.workbook.worksheets.getActiveWorksheet()
            .charts.onAdded.add(function (event) {
            return Excel.run(async (context) => {
                console.log("A chart has been added with ID: " + event.chartId);
                await context.sync();
            });
        });
        await context.sync();
    });
Excel.ChartCollection#onDeleted:member:
  - |-
    await Excel.run(async (context) => {
        context.workbook.worksheets.getActiveWorksheet()
            .charts.onDeleted.add(function (event) {
            return Excel.run(async (context) => {
                console.log("The chart with this ID was deleted: " + event.chartId);
                await context.sync();
            });
        });
        await context.sync();
    });
Excel.ChartDataLabels#load:member(2):
  - |-
    // Show the series name in data labels and set the position of the data labels to "top".
    await Excel.run(async (context) => {
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");
        chart.dataLabels.showValue = true;
        chart.dataLabels.position = Excel.ChartDataLabelPosition.top;
        chart.dataLabels.showSeriesName = true;
        await context.sync();

        console.log("Data labels shown");
    });
Excel.ChartFill#clear:member(1):
  - |-
    // Clear the line format of the major gridlines on the value axis of the chart named "Chart1".
    await Excel.run(async (context) => { 
        const gridlines = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").axes.valueAxis.majorGridlines;
        gridlines.format.line.clear();
        await context.sync();
        
        console.log("Chart Major Gridlines Format Cleared");
    });
Excel.ChartFont:class:
  - |-
    // Set the chart title font to Calibri, size 10, bold, and the color red.
    await Excel.run(async (context) => { 
        const title = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").title;
        title.format.font.name = "Calibri";
        title.format.font.size = 12;
        title.format.font.color = "#FF0000";
        title.format.font.italic =  false;
        title.format.font.bold = true;
        title.format.font.underline = "None";
        await context.sync();
    });
Excel.ChartGridlines#load:member(2):
  - |-
    // Set the value axis of Chart1 to show the major gridlines.
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.axes.valueAxis.majorGridlines.visible = true;
        await context.sync();
        
        console.log("Axis Gridlines Added ");
    });
Excel.ChartLegend#load:member(2):
  - |-
    // Get the position of Chart Legend from Chart1.
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        const legend = chart.legend;
        legend.load('position');
        await context.sync();

        console.log(legend.position);
    });
Excel.ChartLineFormat#clear:member(1):
  - |-
    // Clear the format of the major gridlines on Chart1. 
    await Excel.run(async (context) => { 
        const gridlines = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").axes.valueAxis.majorGridlines;
        gridlines.format.line.clear();
        await context.sync();
        
        console.log("Chart Major Gridlines Format Cleared");
    });
Excel.ChartLineFormat#load:member(2):
  - |-
    // Set chart major gridlines on value axis to be red.
    await Excel.run(async (context) => {
        const gridlines = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").axes.valueAxis.majorGridlines;
        gridlines.format.line.color = "#FF0000";
        await context.sync()
        
        console.log("Chart Gridlines Color Updated");
    });
Excel.ChartPointsCollection#getItemAt:member(1):
  - |-
    // Set the border color for the first points in the points collection.
    await Excel.run(async (context) => { 
        const points = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series.getItemAt(0).points;
        points.getItemAt(0).format.fill.setSolidColor("8FBC8F");
        await context.sync();
        
        console.log("Point Border Color Changed");
    });
Excel.ChartPointsCollection#load:member(2):
  - |-
    // Get the number of points.
    await Excel.run(async (context) => { 
        const pointsCollection = 
            context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series.getItemAt(0).points;
        pointsCollection.load('count');
        await context.sync();
        console.log("points: Count= " + pointsCollection.count);
    });
Excel.ChartSeries#load:member(2):
  - |-
    // Rename the 1st series of Chart1 to "New Series Name".
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        chart.series.getItemAt(0).name = "New Series Name";
        await context.sync();

        console.log("Series1 Renamed");
    });
Excel.ChartSeriesCollection#getItemAt:member(1):
  - |-
    // Get the name of the first series in the series collection.
    await Excel.run(async (context) => { 
        const seriesCollection = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series;
        seriesCollection.load('items');
        await context.sync();
        
        console.log(seriesCollection.items[0].name);
    });
Excel.ChartSeriesCollection#load:member(2):
  - |-
    // Get the number of chart series in the collection.
    await Excel.run(async (context) => { 
        const seriesCollection = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1").series;
        seriesCollection.load('count');
        await context.sync();

        console.log("series: Count= " + seriesCollection.count);
    });
Excel.ChartTitle#load:member(2):
  - |-
    // Set the text of the chart title to "My Chart" and display it as an overlay on the chart.
    await Excel.run(async (context) => { 
        const chart = context.workbook.worksheets.getItem("Sheet1").charts.getItem("Chart1");    
        
        chart.title.text= "My Chart"; 
        chart.title.visible=true;
        chart.title.overlay=true;
        
        await context.sync();
        console.log("Char Title Changed");
    });
Excel.ConditionalFormatCollection#getCount:member(1):
  - |-
    await Excel.run(async (context) => {
        const sheetName = "Sheet1";
        const rangeAddress = "A1:C3";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        const conditionalFormat = range.conditionalFormats.add(Excel.ConditionalFormatType.iconSet);
        conditionalFormat.iconSetOrNullObject.style = Excel.IconSet.fourTrafficLights;
        const cfCount = range.conditionalFormats.getCount(); 

        await context.sync()
        console.log("Count: " + cfCount.value);
    });
Excel.ConditionalFormatCollection#getItem:member(1):
  - |-
    await Excel.run(async (context) => {
        const sheetName = "Sheet1";
        const rangeAddress = "A1:C3";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        const conditionalFormats = range.conditionalFormats;
        const conditionalFormat = conditionalFormats.getItemAt(3);
        await context.sync()

        console.log("Conditional Format at Item 3 Loaded");
    });
Excel.CustomConditionalFormat#rule:member:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getActiveWorksheet();
        const range = sheet.getRange("A1:A5");
        range.values = [[1], [20], [""], [5], ["test"]];
        const cf = range.conditionalFormats.add(Excel.ConditionalFormatType.custom);
        const cfCustom = cf.customOrNullObject;
        cfCustom.rule.formula = "=ISBLANK(A1)";
        cfCustom.format.fill.color = "#00FF00";
        await context.sync()

        console.log("Added new custom conditional format highlighting all blank cells.");
    });
Excel.FilterOn:enum:
  - |-
    // This function adds a custom AutoFilter to the active worksheet 
    // and applies the filter to a column of the used range.
    await Excel.run(async (context) => {
        // Retrieve the active worksheet and the used range on that worksheet.
        const sheet = context.workbook.worksheets.getActiveWorksheet();
        const farmData = sheet.getUsedRange();

        // Add a filter that will only show the rows with values that end with the letter "e" in column 1.
        sheet.autoFilter.apply(farmData, 1, {
            criterion1: "=*e",
            filterOn: Excel.FilterOn.custom
        });

        await context.sync();
    });
Excel.NamedItem#getRange:member(1):
  - |-
    // Returns the Range object that is associated with the name.
    // Returns `null` if the name is not of type Range.
    // Note: This API currently supports only the Workbook scoped items.
    await Excel.run(async (context) => { 
        const names = context.workbook.names;
        const range = names.getItem('MyRange').getRange();
        range.load('address');
        await context.sync();

        console.log(range.address);
    });
Excel.NamedItem#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const names = context.workbook.names;
        const namedItem = names.getItem('MyRange');
        namedItem.load('type');
        await context.sync();
        
        console.log(namedItem.type);
    });
Excel.NamedItemCollection#getItem:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = 'Sheet1';
        const nameditem = context.workbook.names.getItem(sheetName);
        nameditem.load('type');
        await context.sync();
        
        console.log(nameditem.type);
    });
Excel.NamedItemCollection#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const nameditems = context.workbook.names;
        nameditems.load('items');
        await context.sync();

        for (let i = 0; i < nameditems.items.length; i++) {
            console.log(nameditems.items[i].name);
        }
    });
Excel.Query#name:member:
  - |-
    // This function retrieves the query collection in a workbook, 
    // loads the query items in that collection, and then
    // logs the name of each query to the console.
    await Excel.run(async (context) => {
        const queries = context.workbook.queries; 
        queries.load("items"); 
        await context.sync(); 

        console.log("Name of each query: ")
        console.log("  " + queries.items.map((query) => query.name).join("\n  "));
    });
Excel.Query#refreshDate:member:
  - |-
    // This function retrieves the query collection in a workbook, 
    // loads the query items in that collection, and then
    // logs the last refresh date of each query to the console.
    await Excel.run(async (context) => {
        const queries = context.workbook.queries; 
        queries.load("items"); 
        await context.sync(); 

        console.log("Last refresh date of each query: ")
        console.log("  " + queries.items.map((query) => query.refreshDate).join("\n  "));
    });       
Excel.Query#rowsLoadedCount:member:
  - |-
    // This function retrieves the query collection in a workbook, 
    // loads the query items in that collection, and then
    // logs the number of rows loaded in each query.
    await Excel.run(async (context) => {
        const queries = context.workbook.queries; 
        queries.load("items"); 
        await context.sync(); 

        console.log("Rows loaded from each query: ")
        console.log("  " + queries.items.map((query) => query.rowsLoadedCount).join("\n  "));
    });
Excel.QueryCollection#items:member:
  - |-
    // This function retrieves the query collection in a workbook, 
    // loads the query items in that collection, and then
    // logs the name of each query to the console.
    await Excel.run(async (context) => {
        const queries = context.workbook.queries; 
        queries.load("items"); 
        await context.sync(); 

        console.log("Name of each query: ")
        console.log("  " + queries.items.map((query) => query.name).join("\n  "));
    });
Excel.QueryCollection#getCount:member(1):
  - |-
    // This function retrieves the query collection in a workbook and then 
    // logs the number of queries in the collection to the console.
    await Excel.run(async (context) => { 
      const queries = context.workbook.queries; 
      const count = queries.getCount();
      await context.sync();

      console.log("Query count: " + count.value);
    });
Excel.Range:class:
  - |-
    // Get a Range object by its address.
    await Excel.run(async (context) => {
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        const cell = range.getCell(0,0);
        cell.load('address');
        await context.sync();
        
        console.log(cell.address);
    });
Excel.Range#clear:member(1):
  - |-
    // Clear the format and contents of the range.
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "D:F";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.clear();
        await context.sync(); 
    });
Excel.Range#delete:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "D:F";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.delete("Left");
        await context.sync(); 
    });
Excel.Range#getBoundingRect:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "D4:G6";
        let range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range = range.getBoundingRect("G4:H8");
        range.load('address');
        await context.sync();
        
        console.log(range.address); // Prints Sheet1!D4:H8
    });
Excel.Range#getCell:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        const cell = range.getCell(0,0);
        cell.load('address');
        await context.sync();
        
        console.log(cell.address);
    });
Excel.Range#getColumn:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet19";
        const rangeAddress = "A1:F8";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getColumn(1);
        range.load('address');
        await context.sync();

        console.log(range.address); // prints Sheet1!B1:B8
    });
Excel.Range#getEntireColumn:member(1):
  - |-
    // Note: the grid properties of the Range (values, numberFormat, formulas) 
    // contains null since the Range in question is unbounded.
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "D:F";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        const rangeEC = range.getEntireColumn();
        rangeEC.load('address');
        await context.sync();
        
        console.log(rangeEC.address);
    });
Excel.Range#getEntireRow:member(1):
  - |-
    // Gets an object that represents the entire row of the range 
    // (for example, if the current range represents cells "B4:E11", 
    // its GetEntireRow is a range that represents rows "4:11").
    await Excel.run(async (context) => {
        const sheetName = "Sheet1";
        const rangeAddress = "D:F"; 
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        const rangeER = range.getEntireRow();
        rangeER.load('address');
        await context.sync();
        
        console.log(rangeER.address);
    });
Excel.Range#getIntersection:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const range = 
            context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getIntersection("D4:G6");
        range.load('address');
        await context.sync();
        
        console.log(range.address); // prints Sheet1!D4:F6
    });
Excel.Range#getLastCell:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getLastCell();
        range.load('address');
        await context.sync();
        
        console.log(range.address); // prints Sheet1!F8
    });
Excel.Range#getLastColumn:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getLastColumn();
        range.load('address');
        await context.sync();
        
        console.log(range.address); // prints Sheet1!F1:F8
    });
Excel.Range#getLastRow:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getLastRow();
        range.load('address');
        await context.sync();
        
        console.log(range.address); // prints Sheet1!A8:F8
    });
Excel.Range#getOffsetRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "D4:F6";
        const range = 
            context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getOffsetRange(-1,4);
        range.load('address');
        await context.sync();
        
        console.log(range.address); // prints Sheet1!H3:J5
    });
Excel.Range#getRow:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress).getRow(1);
        range.load('address');
        await context.sync();
        
        console.log(range.address); // prints Sheet1!A2:F2
    });
Excel.Range#numberFormat:member:
  - |-
    // Set the text of the chart title to "My Chart" and display it as an overlay on the chart.
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "F5:G7";
        const numberFormat = [[null, "d-mmm"], [null, "d-mmm"], [null, null]]
        const values = [["Today", 42147], ["Tomorrow", "5/24"], ["Difference in days", null]];
        const formulas = [[null,null], [null,null], [null,"=G6-G5"]];
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.numberFormat = numberFormat;
        range.values = values;
        range.formulas= formulas;
        range.load('text');
        await context.sync();
        
        console.log(range.text);
    });
Excel.Range#insert:member(1):
  - |-
    await Excel.run(async (context) => {
        const sheetName = "Sheet1";
        const rangeAddress = "F5:F10";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.insert(Excel.InsertShiftDirection.down);
        await context.sync();
    });
Excel.Range#merge:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:C3";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.merge(true);
        await context.sync(); 
    });
Excel.Range#select:member(1):
  - |-
    await Excel.run(async (context) => {
        const sheetName = "Sheet1";
        const rangeAddress = "F5:F10"; 
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.select();
        await context.sync(); 
    });
Excel.Range#unmerge:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:C3";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.unmerge();
        await context.sync(); 
    });
Excel.Range#untrack:member(1):
  - |-
    await Excel.run(async (context) => {
        const largeRange = context.workbook.getSelectedRange();
        largeRange.load(["rowCount", "columnCount"]);
        await context.sync();

        for (let i = 0; i < largeRange.rowCount; i++) {
            for (let j = 0; j < largeRange.columnCount; j++) {
                const cell = largeRange.getCell(i, j);
                cell.values = [[i *j]];

                // Call untrack() to release the range from memory.
                cell.untrack();
            }
        }

        await context.sync();
    });
Excel.Range#load:member(2):
  - |-
    // Use the range address to get the range object.
    await Excel.run(async (context) => {
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8"; 
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        range.load('cellCount');
        await context.sync();
        
        console.log(range.cellCount);
    });
Excel.RangeBorder#style:member:
  - |-
    // Add grid borders around the range.
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const range = context.workbook.worksheets.getItem(sheetName).getRange(rangeAddress);
        range.format.borders.getItem('InsideHorizontal').style = 'Continuous';
        range.format.borders.getItem('InsideVertical').style = 'Continuous';
        range.format.borders.getItem('EdgeBottom').style = 'Continuous';
        range.format.borders.getItem('EdgeLeft').style = 'Continuous';
        range.format.borders.getItem('EdgeRight').style = 'Continuous';
        range.format.borders.getItem('EdgeTop').style = 'Continuous';
        await context.sync(); 
    });
Excel.RangeBorderCollection#getItem:member(1):
  - |-
    await Excel.run(async (context) => {
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        const border = range.format.borders.getItem(Excel.BorderIndex.edgeTop);
        border.load('style');
        await context.sync();

        console.log(border.style);
    });
Excel.RangeBorderCollection#getItemAt:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        const border = range.format.borders.getItemAt(0);
        border.load('sideIndex');
        await context.sync();
        
        console.log(border.sideIndex);
    });
Excel.RangeBorderCollection#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        const borders = range.format.borders;
        borders.load('items');
        await context.sync();
        
        console.log(borders.count);
        for (let i = 0; i < borders.items.length; i++) {
            console.log(borders.items[i].sideIndex);
        }
    });
Excel.RangeFill#clear:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "F:G";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        const rangeFill = range.format.fill;
        rangeFill.clear();
        await context.sync(); 
    });
Excel.RangeFill#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "F:G";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        const rangeFill = range.format.fill;
        rangeFill.load('color');
        await context.sync();
        console.log(rangeFill.color);
    });
Excel.RangeFont#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "F:G";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        const rangeFont = range.format.font;
        rangeFont.load('name');
        await context.sync();
        console.log(rangeFont.name);
    });
Excel.RangeFont#name:member:
  - |-
    // Change the font of the selected range to "Impact".
    await Excel.run(async (context) => {
      const selection = context.workbook.getSelectedRange();
      selection.format.font.name = "Impact";
      await context.sync();
    });
Excel.RangeFormat#load:member(2):
  - |-
    // Select all of the range's format properties.
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "F:G";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        range.load(["format/*", "format/fill", "format/borders", "format/font"]);
        await context.sync();
        
        console.log(range.format.wrapText);
        console.log(range.format.fill.color);
        console.log(range.format.font.name);
    });
Excel.RequestContext:class:
  - |-
    // *.run methods automatically create an OfficeExtension.ClientRequestContext
    // object to work with the Office file.
    await Excel.run(async (context: Excel.RequestContext) => {
      const workbook = context.workbook;
      // Interact with the Excel workbook...
    });
Excel.Table#convertToRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        table.convertToRange();
        await context.sync(); 
    });
Excel.Table#delete:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        table.delete();
        await context.sync(); 
    });
Excel.Table#getDataBodyRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        const tableDataRange = table.getDataBodyRange();
        tableDataRange.load('address')
        await context.sync();
        
        console.log(tableDataRange.address);
    });
Excel.Table#getHeaderRowRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        const tableHeaderRange = table.getHeaderRowRange();
        tableHeaderRange.load('address');
        await context.sync();

        console.log(tableHeaderRange.address);
    });
Excel.Table#getRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        const tableRange = table.getRange();
        tableRange.load('address');    
        await context.sync();
        
        console.log(tableRange.address);
    });
Excel.Table#getTotalRowRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        const tableTotalsRange = table.getTotalRowRange();
        tableTotalsRange.load('address');    
        await context.sync();
        
        console.log(tableTotalsRange.address);
    });
Excel.Table#load:member(2):
  - |-
    // Get a table by name.
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        table.load('id')
        await context.sync();
        
        console.log(table.id);
    });
Excel.Table#style:member:
  - |-
    // Set table style.
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        table.name = 'Table1-Renamed';
        table.showTotals = false;
        table.style = 'TableStyleMedium2';
        table.load('tableStyle');
        await context.sync();
        
        console.log(table.style);
    });
Excel.TableCollection#add:member(1):
  - |-
    await Excel.run(async (context) => { 
        const table = context.workbook.tables.add('Sheet1!A1:E7', true);
        table.load('name');
        await context.sync();
        
        console.log(table.name);
    });
Excel.TableCollection#getItem:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        table.load('name');
        await context.sync();
        
        console.log(table.name);
    });
Excel.TableCollection#getItemAt:member(1):
  - |-
    await Excel.run(async (context) => { 
        const table = context.workbook.tables.getItemAt(0);
        table.load('name');
        await context.sync();
        
        console.log(table.name);
    });
Excel.TableCollection#load:member(2):
  - |-
    // Get the number of tables.
    await Excel.run(async (context) => { 
        const tables = context.workbook.tables;
        tables.load('count');
        await context.sync();
        
        console.log(tables.count);
    });
Excel.TableColumn#delete:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const column = context.workbook.tables.getItem(tableName).columns.getItemAt(2);
        column.delete();
        await context.sync(); 
    });
Excel.TableColumn#getDataBodyRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const column = context.workbook.tables.getItem(tableName).columns.getItemAt(0);
        const dataBodyRange = column.getDataBodyRange();
        dataBodyRange.load('address');
        await context.sync();
        
        console.log(dataBodyRange.address);
    });
Excel.TableColumn#getHeaderRowRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const columns = context.workbook.tables.getItem(tableName).columns.getItemAt(0);
        const headerRowRange = columns.getHeaderRowRange();
        headerRowRange.load('address');
        await context.sync();
        
        console.log(headerRowRange.address);
    });
Excel.TableColumn#getRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const columns = context.workbook.tables.getItem(tableName).columns.getItemAt(0);
        const columnRange = columns.getRange();
        columnRange.load('address');
        await context.sync();
        
        console.log(columnRange.address);
    });
Excel.TableColumn#getTotalRowRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const columns = context.workbook.tables.getItem(tableName).columns.getItemAt(0);
        const totalRowRange = columns.getTotalRowRange();
        totalRowRange.load('address');
        await context.sync();
        
        console.log(totalRowRange.address);
    });
Excel.TableColumn#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const column = context.workbook.tables.getItem(tableName).columns.getItem(0);
        column.load('index');
        await context.sync();
        
        console.log(column.index);
    });
Excel.TableColumnCollection#add:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tables = context.workbook.tables;
        const values = [["Sample"], ["Values"], ["For"], ["New"], ["Column"]];
        const column = tables.getItem("Table1").columns.add(null, values);
        column.load('name');
        await context.sync();
        
        console.log(column.name);
    });
Excel.TableColumnCollection#getItem:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableColumn = context.workbook.tables.getItem('Table1').columns.getItem(0);
        tableColumn.load('name');
        await context.sync();
        console.log(tableColumn.name);
    });
Excel.TableColumnCollection#getItemAt:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableColumn = context.workbook.tables.getItem['Table1'].columns.getItemAt(0);
        tableColumn.load('name');
        await context.sync();
        console.log(tableColumn.name);
    });
Excel.TableColumnCollection#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const tableColumns = context.workbook.tables.getItem('Table1').columns;
        tableColumns.load('items');
        await context.sync();
        
        console.log("tableColumns Count: " + tableColumns.count);
        for (let i = 0; i < tableColumns.items.length; i++) {
            console.log(tableColumns.items[i].name);
        }
    });
Excel.TableRow#delete:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const row = context.workbook.tables.getItem(tableName).rows.getItemAt(2);
        row.delete();
        await context.sync(); 
    });
Excel.TableRow#getRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const row = context.workbook.tables.getItem(tableName).rows.getItemAt(0);
        const rowRange = row.getRange();
        rowRange.load('address');
        await context.sync();
        
        console.log(rowRange.address);
    });
Excel.TableRow#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const row = context.workbook.tables.getItem(tableName).rows.getItemAt(0);
        row.load('index');
        await context.sync();
        
        console.log(row.index);
    });
Excel.TableRowCollection#add:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tables = context.workbook.tables;
        const values = [["Sample", "Values", "For", "New", "Row"]];
        const row = tables.getItem("Table1").rows.add(null, values);
        row.load('index');
        await context.sync();
        
        console.log(row.index);
    });
Excel.TableRowCollection#getItemAt:member(1):
  - |-
    await Excel.run(async (context) => {
        const tablerow = context.workbook.tables.getItem('Table1').rows.getItemAt(0);
        tablerow.load('values');
        await context.sync();
        console.log(tablerow.values);
    });
Excel.TableRowCollection#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const tablerows = context.workbook.tables.getItem('Table1').rows;
        tablerows.load('items');
        await context.sync();
        
        console.log("tablerows Count: " + tablerows.count);
        for (let i = 0; i < tablerows.items.length; i++) {
            console.log(tablerows.items[i].index);
        }
    });
Excel.TableSort#apply:member(1):
  - |-
    await Excel.run(async (context) => { 
        const tableName = 'Table1';
        const table = context.workbook.tables.getItem(tableName);
        table.sort.apply([ 
                {
                    key: 2,
                    ascending: true
                },
            ], true);
        await context.sync(); 
    });
Excel.Workbook#getSelectedRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const selectedRange = context.workbook.getSelectedRange();
        selectedRange.load('address');
        await context.sync();
        console.log(selectedRange.address);
    });
Excel.Worksheet:class:
  - |-
    // Get a Worksheet object by its name and activate it.
    await Excel.run(async (context) => { 
        const wSheetName = 'Sheet1';
        const worksheet = context.workbook.worksheets.getItem(wSheetName);
        worksheet.activate();
        await context.sync(); 
    });
Excel.Worksheet#activate:member(1):
  - |-
    await Excel.run(async (context) => { 
        const wSheetName = 'Sheet1';
        const worksheet = context.workbook.worksheets.getItem(wSheetName);
        worksheet.activate();
        await context.sync(); 
    });
Excel.Worksheet#delete:member(1):
  - |-
    await Excel.run(async (context) => { 
        const wSheetName = 'Sheet1';
        const worksheet = context.workbook.worksheets.getItem(wSheetName);
        worksheet.delete();
        await context.sync(); 
    });
Excel.Worksheet#getCell:member(1):
  - |-
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const cell = worksheet.getCell(0,0);
        cell.load('address');
        await context.sync();

        console.log(cell.address);
    });
Excel.Worksheet#getRange:member(1):
  - |-
    // Use the range address to get the range object.
    await Excel.run(async (context) => { 
        const sheetName = "Sheet1";
        const rangeAddress = "A1:F8";
        const worksheet = context.workbook.worksheets.getItem(sheetName);
        const range = worksheet.getRange(rangeAddress);
        range.load('cellCount');
        await context.sync();
        
        console.log(range.cellCount);
    });
Excel.Worksheet#getUsedRange:member(1):
  - |-
    await Excel.run(async (context) => { 
        const wSheetName = 'Sheet1';
        const worksheet = context.workbook.worksheets.getItem(wSheetName);
        const usedRange = worksheet.getUsedRange();
        usedRange.load('address');
        await context.sync();
        
        console.log(usedRange.address);
    });
Excel.Worksheet#load:member(2):
  - |-
    // Get worksheet properties based on sheet name.
    await Excel.run(async (context) => { 
        const wSheetName = 'Sheet1';
        const worksheet = context.workbook.worksheets.getItem(wSheetName);
        worksheet.load('position')
        await context.sync();
        
        console.log(worksheet.position);
    });
Excel.Worksheet#onActivated:member:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        sheet.onActivated.add(function (event) {
            return Excel.run(async (context) => {
                console.log("The activated worksheet ID is: " + event.worksheetId);
                await context.sync();
            });
        });
        await context.sync();
    });
Excel.Worksheet#onCalculated:member:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        sheet.onCalculated.add(function (event) {
            return Excel.run(async (context) => {
                console.log("The worksheet has recalculated.");
                await context.sync();
            });
        });
        await context.sync();
    });
Excel.Worksheet#onDeactivated:member:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        sheet.onDeactivated.add(function (event) {
            return Excel.run(async (context) => {
                console.log("The deactivated worksheet is: " + event.worksheetId);
                await context.sync();
            });
        });
        await context.sync();
    });
Excel.Worksheet#onRowHiddenChanged:member:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getActiveWorksheet();
        sheet.onRowHiddenChanged.add(function (event) {
            return Excel.run(async (context) => {
                console.log(`Row ${event.address} is now ${event.changeType}`);
                await context.sync();
            });
        });
        await context.sync();
    });
Excel.Worksheet#onSelectionChanged:member:
  - |-
    await Excel.run(async (context) => {
        const sheet = context.workbook.worksheets.getItem("Sample");
        sheet.onSelectionChanged.add(function (event) {
            return Excel.run(async (context) => {
                console.log("The selected range has changed to: " + event.address);
                await context.sync();
            });
        });
        await context.sync();
    });
Excel.Worksheet#position:member:
  - |-
    // Set worksheet position.
    await Excel.run(async (context) => { 
        const wSheetName = 'Sheet1';
        const worksheet = context.workbook.worksheets.getItem(wSheetName);
        worksheet.position = 2;
        await context.sync(); 
    });
Excel.Worksheet#set:member(1):
  - |-
    // Set the color and name of the current worksheet.
    await Excel.run(async (context) => {
      const activeSheet = context.workbook.worksheets.getActiveWorksheet();
      activeSheet.set({
        tabColor: "yellow",
        name: "MySheet"
      });

      await context.sync();
    });
Excel.WorksheetChangedEventArgs#details:member:
  - |-
    // This function would be used as an event handler for the Worksheet.onChanged event.
    async function onWorksheetChanged(eventArgs) {
        await Excel.run(async (context) => {
            const details = eventArgs.details;
            const address = eventArgs.address;

            // Print the before and after types and values to the console.
            console.log(`Change at ${address}: was ${details.valueBefore}(${details.valueTypeBefore}),`
                + ` now is ${details.valueAfter}(${details.valueTypeAfter})`);
            await context.sync();
        });
    }
Excel.WorksheetCollection#add:member(1):
  - |-
    await Excel.run(async (context) => { 
        const wSheetName = 'Sample Name';
        const worksheet = context.workbook.worksheets.add(wSheetName);
        worksheet.load('name');
        await context.sync();
        
        console.log(worksheet.name);
    });
Excel.WorksheetCollection#getActiveWorksheet:member(1):
  - |-
    await Excel.run(async (context) => {  
        const activeWorksheet = context.workbook.worksheets.getActiveWorksheet();
        activeWorksheet.load('name');
        await context.sync();
        console.log(activeWorksheet.name);
    });
Excel.WorksheetCollection#load:member(2):
  - |-
    await Excel.run(async (context) => { 
        const worksheets = context.workbook.worksheets;
        worksheets.load('items');
        await context.sync();
        
        for (let i = 0; i < worksheets.items.length; i++) {
            console.log(worksheets.items[i].name);
        }
    });
Excel.Worksheet#protection:member:
  - |-
    // Unprotecting a worksheet with unprotect() will remove all 
    // WorksheetProtectionOptions options applied to a worksheet.
    // To remove only a subset of WorksheetProtectionOptions use the 
    // protect() method and set the options you wish to remove to true.
    await Excel.run(async (context) => {
      const sheet = context.workbook.worksheets.getItem("Sheet1");
      sheet.protection.protect({
        allowInsertRows: false, // Protect row insertion
        allowDeleteRows: true // Unprotect row deletion
      });
    });

Office.Actions#areShortcutsInUse:member(1):
  - |-
    // Checks if a specific keyboard shortcut is in use.
    const shortcuts = ["Ctrl+Shift+1", "Ctrl+Shift+2"];
    Office.actions.areShortcutsInUse(shortcuts)
        .then((shortcutsInUse) => {
            const availableShortcuts = shortcutsInUse.filter((shortcut) => { return !shortcut.inUse; });
            console.log(`Available keyboard shortcuts: ${availableShortcuts}`);
            const usedShortcuts = shortcutsInUse.filter((shortcut) => { return shortcut.inUse; });
            console.log(`Shortcuts in use: ${usedShortcuts}`);
    });
Office.Actions#associate:member(1):
  - |-
    // Maps the action ID to the showTaskPane function.
    Office.actions.associate("ShowTaskpane", showTaskPane);

    // Displays the add-in's task pane.
    function showTaskPane() {
        return Office.addin.showAsTaskpane()
            .then(() => { console.log("Task pane is visible."); })
            .catch((error) => {
                console.log(error.code);
            });
    }
Office.Actions#getShortcuts:member(1):
  - |-
    // Gets the list of keyboard shortcuts for an add-in.
    Office.actions.getShortcuts()
        .then((shortcuts) => {
            for (const action in shortcuts) {
                let shortcut = shortcuts[action];
                console.log(`${action}: ${shortcut}`);
            }
    });
Office.Actions#replaceShortcuts:member(1):
  - |-
    // Replaces the keyboard shortcuts of an add-in.
    const customShortcuts = {
        ShowTaskpane:"Ctrl+Shift+1",
        HideTaskpane:"Ctrl+Shift+2"
    };
    Office.actions.replaceShortcuts(customShortcuts)
        .then(() => { console.log("Keyboard shortcuts successfully registered."); })
        .catch((error) => {
            if (error.code == "InvalidOperation") {
                console.log("ActionId does not exist or shortcut combination is invalid.");
            }
    });
Office.ActiveView:enum:
  - |-
    // Get whether the current view is edit or read.
    Office.context.document.getActiveViewAsync(function (asyncResult) {
        if (asyncResult.status == "failed") {
            showMessage("Action failed with error: " + asyncResult.error.message);
        } else {
            const activeView : Office.ActiveView = asyncResult.value;
            showMessage("The current view is " + activeView);
        }
    });
Office.Addin#onVisibilityModeChanged:member(1):
  - |-
    Office.onReady(() => {
        Office.addin.onVisibilityModeChanged((args) => {
            if (args.visibilityMode === Office.VisibilityMode.taskpane) {
                // Do something when the task pane is visible.
            }
        });

        // Other startup tasks.
    });
Office.Addin#setStartupBehavior:member(1):
  - |-
    // Configure your add-in to load and start running when the document is opened.
    Office.addin.setStartupBehavior(Office.StartupBehavior.load);
Office.AddinCommands.Event#completed:member(1):
  - |-
    // For the following example, the processItem function is
    // defined in the FunctionFile referenced from the add-in manifest,
    // and maps to the FunctionName of the action in the associated button control.
    function processItem(event) {
        // Do some processing.

        event.completed();
    }
  - |-
    // In this example, the checkMessage function was registered as an event handler for ItemSend.
    function checkMessage(event) {
        // Get the item being sent.
        const outgoingMsg = Office.context.mailbox.item;

        // Check if subject contains "BLOCK".
        outgoingMsg.subject.getAsync(function (result) {
            // Subject is in `result.value`.
            // If search term "BLOCK" is found, don't send the message.
            const notFound = -1;
            const allowEvent = (result.value.indexOf('BLOCK') === notFound);
            event.completed({ allowEvent: allowEvent });
        });
    }
Office.AddinCommands.Event#source:member:
  - |-
    // In this example, consider a button defined in an add-in manifest.
    // The following is the XML manifest definition. Below it is the Teams 
    // manifest (preview) definition.
    //
    //<Control xsi:type="Button" id="eventTestButton">
    //    <Label resid="eventButtonLabel" />
    //    <Tooltip resid="eventButtonTooltip" />
    //    <Supertip>
    //        <Title resid="eventSuperTipTitle" />
    //        <Description resid="eventSuperTipDescription" />
    //    </Supertip>
    //    <Icon>
    //        <bt:Image size="16" resid="blue-icon-16" />
    //        <bt:Image size="32" resid="blue-icon-32" />
    //        <bt:Image size="80" resid="blue-icon-80" />
    //    </Icon>
    //    <Action xsi:type="ExecuteFunction">
    //        <FunctionName>testEventObject</FunctionName>
    //    </Action>
    //</Control>
    //
    // The Teams manifest (preview) definition is the following.
    // Ellipses("...") indicate omitted properties.
    //
    //     "extensions": [
    //         {
    //             ...
    //             "runtimes": [
    //                 {
    //                  "id": "CommandsRuntime",
    //                  "type": "general",
    //                  "code": {
    //                      "page": "https://localhost:3000/commands.html",
    //                      "script": "https://localhost:3000/commands.js"
    //                  },
    //                  "lifetime": "short",
    //                  "actions": [
    //                      {
    //                          "id": "testEventObject",
    //                          "type": "executeFunction",
    //                          "displayName": "testEventObject"
    //                      }
    //                  ]
    //              }
    //             ],
    //             "ribbons": [
    //                 {
    //                     ...
    //                     "tabs": [
    //                         ...
    //                         "groups": [
    //                             ...
    //                             "controls": [
    //                                 {
    //                                      "id": "eventTestButton",
    //                                      "type": "button",
    //                                      "label": "Perform an action",
    //                                      "icons": [
    //                                          {
    //                                              "size": 16,
    //                                              "file": "https://localhost:3000/assets/blue-icon-16.png"
    //                                          },
    //                                          {
    //                                              "size": 32,
    //                                              "file": "https://localhost:3000/assets/blue-icon-32.png"
    //                                          },
    //                                          {
    //                                              "size": 80,
    //                                              "file": "https://localhost:3000/assets/blue-icon-80.png"
    //                                          }
    //                                      ],
    //                                      "supertip": {
    //                                          "title": "Perform an action",
    //                                          "description": "Perform an action when clicked."
    //                                      },
    //                                      "actionId": "testEventObject"
    //                                  }
    //                             ]
    //                         ]
    //                     ]                           
    //                 }
    //             ]
    //         }
    //     ]



    // The button has an id set to "eventTestButton", and will invoke
    // the testEventObject function defined in the add-in.
    // That function looks like this:
    function testEventObject(event) {
        // The event object implements the Event interface.

        // This value will be "eventTestButton".
        const buttonId = event.source.id;

        // Signal to the host app that processing is complete.
        event.completed();
    }
  - |-
    // Function is used by two buttons:
    // button1 and button2
    function multiButton (event) {
        // Check which button was clicked.
        const buttonId = event.source.id;

        if (buttonId === 'button1') {
            doButton1Action();
        } else {
            doButton2Action();
        }

        event.completed();
    }
Office.AddinCommands.EventCompletedOptions#allowEvent:member:
  - |-
    // In this example, the checkMessage function was registered as an event handler for ItemSend.
    function checkMessage(event) {
        // Get the item being sent.
        const outgoingMsg = Office.context.mailbox.item;

        // Check if subject contains "BLOCK".
        outgoingMsg.subject.getAsync(function (result) {
            // Subject is in `result.value`.
            // If search term "BLOCK" is found, don't send the message.
            const notFound = -1;
            const allowEvent = (result.value.indexOf('BLOCK') === notFound);
            event.completed({ allowEvent: allowEvent });
        });
    }
Office.AddinCommands.Source#id:member:
  - |-
    // In this example, consider a button defined in an add-in manifest.
    // The following is the XML manifest definition. Below it is the Teams 
    // manifest (preview) definition.
    //
    //<Control xsi:type="Button" id="eventTestButton">
    //    <Label resid="eventButtonLabel" />
    //    <Tooltip resid="eventButtonTooltip" />
    //    <Supertip>
    //        <Title resid="eventSuperTipTitle" />
    //        <Description resid="eventSuperTipDescription" />
    //    </Supertip>
    //    <Icon>
    //        <bt:Image size="16" resid="blue-icon-16" />
    //        <bt:Image size="32" resid="blue-icon-32" />
    //        <bt:Image size="80" resid="blue-icon-80" />
    //    </Icon>
    //    <Action xsi:type="ExecuteFunction">
    //        <FunctionName>testEventObject</FunctionName>
    //    </Action>
    //</Control>
    //
    // The Teams manifest (preview) definition is the following.
    // Ellipses("...") indicate omitted properties.
    //
    //     "extensions": [
    //         {
    //             ...
    //             "runtimes": [
    //                 {
    //                  "id": "CommandsRuntime",
    //                  "type": "general",
    //                  "code": {
    //                      "page": "https://localhost:3000/commands.html",
    //                      "script": "https://localhost:3000/commands.js"
    //                  },
    //                  "lifetime": "short",
    //                  "actions": [
    //                      {
    //                          "id": "testEventObject",
    //                          "type": "executeFunction",
    //                          "displayName": "testEventObject"
    //                      }
    //                  ]
    //              }
    //             ],
    //             "ribbons": [
    //                 {
    //                     ...
    //                     "tabs": [
    //                         ...
    //                         "groups": [
    //                             ...
    //                             "controls": [
    //                                 {
    //                                      "id": "eventTestButton",
    //                                      "type": "button",
    //                                      "label": "Perform an action",
    //                                      "icons": [
    //                                          {
    //                                              "size": 16,
    //                                              "file": "https://localhost:3000/assets/blue-icon-16.png"
    //                                          },
    //                                          {
    //                                              "size": 32,
    //                                              "file": "https://localhost:3000/assets/blue-icon-32.png"
    //                                          },
    //                                          {
    //                                              "size": 80,
    //                                              "file": "https://localhost:3000/assets/blue-icon-80.png"
    //                                          }
    //                                      ],
    //                                      "supertip": {
    //                                          "title": "Perform an action",
    //                                          "description": "Perform an action when clicked."
    //                                      },
    //                                      "actionId": "testEventObject"
    //                                  }
    //                             ]
    //                         ]
    //                     ]                           
    //                 }
    //             ]
    //         }
    //     ]
    
    
    // The button has an id set to "eventTestButton", and will invoke
    // the testEventObject function defined in the add-in.
    // That function looks like this:
    function testEventObject(event) {
        // The event object implements the Event interface.

        // This value will be "eventTestButton".
        const buttonId = event.source.id;

        // Signal to the host app that processing is complete.
        event.completed();
    }
  - |-
    // Function is used by two buttons:
    // button1 and button2
    function multiButton (event) {
        // Check which button was clicked.
        const buttonId = event.source.id;

        if (buttonId === 'button1') {
            doButton1Action();
        } else {
            doButton2Action();
        }

        event.completed();
    }
Office.AsyncContextOptions:interface:
  - |-
    // The following example gets the attachment contents of the
    // current mail item being composed in Outlook.
    function getAttachmentContentCompose() {
        const item = Office.context.mailbox.item;
        const options: Office.AsyncContextOptions = { asyncContext: { currentItem: item } };
        item.getAttachmentsAsync(options, callback);

        function callback(result) {
            if (result.status === Office.AsyncResultStatus.Failed) {
                console.log(result.error.message);
                return;
            }

            if (result.value.length <= 0) {
                console.log("Mail item has no attachments.");
                return;
            }

            const currentItem = result.asyncContext.currentItem;
            for (let i = 0; i < result.value.length; i++) {
                currentItem.getAttachmentContentAsync(result.value[i].id, (asyncResult) => {
                    if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                        console.log(asyncResult.error.message);
                        return;
                    }

                    console.log(asyncResult.value.content);
                });
            }
        }
    }
Office.AsyncResult:interface:
  - |-
    // The following is an example applicable to content and task pane add-ins.
    // The example shows a call to the getSelectedDataAsync method of the Document object.
    Office.context.document.getSelectedDataAsync(
        Office.CoercionType.Text,
        {
            valueFormat: Office.ValueFormat.Unformatted,
            filterType: Office.FilterType.All
        },
        (result) => {
            if (result.status === Office.AsyncResultStatus.Succeeded) {
                const dataValue = result.value; // Get selected data.
                console.log('Selected data is ' + dataValue);
            } else {
                const err = result.error;
                console.log(err.name + ": " + err.message);
            }
        }
    );
    // The anonymous function passed as the callback argument ((result) => {...}) has a single 
    // parameter named result that provides access to an AsyncResult object when the function executes.
    // When the call to the getSelectedDataAsync method completes, the callback function executes, 
    // and the following line of code accesses the value property of the AsyncResult object to 
    // return the data selected in the document:
    // const dataValue = result.value;
    // Note that other lines of code in the function use the result parameter of the callback function 
    // to access the status and error properties of the AsyncResult object.
Office.AsyncResult#asyncContext:member:
  - |-
    function getDataWithContext() {
        const format = "Your data: ";
        Office.context.document.getSelectedDataAsync(
            Office.CoercionType.Text, 
            { asyncContext: format }, 
            showDataWithContext);
    }

    function showDataWithContext(asyncResult) {
        write(asyncResult.asyncContext + asyncResult.value);
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.AsyncResult#error:member:
  - |-
    function getData() {
        Office.context.document.getSelectedDataAsync(Office.CoercionType.Table, function(asyncResult) {
            if (asyncResult.status == Office.AsyncResultStatus.Failed) {
                write(asyncResult.error.message);
            }
            else {
                write(asyncResult.value);
            }
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.AsyncResult#status:member:
  - |-
    function getData() {
        Office.context.document.getSelectedDataAsync(Office.CoercionType.Table, function(asyncResult) {
            if (asyncResult.status == Office.AsyncResultStatus.Failed) {
                write(asyncResult.error.message);
            }
            else {
                write(asyncResult.value);
            }
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.AsyncResult#value:member:
  - |-
    function getData() {
        Office.context.document.getSelectedDataAsync(Office.CoercionType.Table, function(asyncResult) {
            if (asyncResult.status == Office.AsyncResultStatus.Failed) {
                write(asyncResult.error.message);
            }
            else {
                write(asyncResult.value);
            }
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.AsyncResultStatus:enum:
  - |-
    // The following example logs selected text in a document to the console.
    Office.context.document.getSelectedDataAsync(
        Office.CoercionType.Text,
        {
            valueFormat: Office.ValueFormat.Unformatted,
            filterType: Office.FilterType.All
        },
        (result) => {
            if (result.status === Office.AsyncResultStatus.Failed) {
                console.log(result.error.message);
                return;
            }

            console.log(`Selected data: ${result.value}`);
        }
    );
Office.Auth:interface:
  - |-
    // Get the auth context object and use it to get an
    // access token.
    const authContext = Office.context.auth;
    authContext.getAccessTokenAsync(function(result) {
        if (result.status === Office.AsyncResultStatus.Succeeded) {
            const token = result.value;
            console.log(token);
        } else {
            console.log("Error obtaining token", result.error);
        }
    });
Office.Auth#getAuthContext:member(1):
  - |-
    try{
        const authContext = await Office.auth.getAuthContext();
        console.log(authContext.userPrincipalName);
    } catch (error) {
        console.log("Error obtaining token", error);
    }
Office.Auth#getAccessToken:member(1):
  - |-
    try{
        const accessToken = await Office.auth.getAccessToken({
            allowSignInPrompt: true,
            allowConsentPrompt: true,
            forMSGraphAccess: true,
        });
    } catch (error) {
        console.log("Error obtaining token", error);
    }
Office.Auth#getAccessTokenAsync:member(1):
  - |-
    Office.context.auth.getAccessTokenAsync(function(result) {
        if (result.status === Office.AsyncResultStatus.Succeeded) {
            const token = result.value;
            // ...
        } else {
            console.log("Error obtaining token", result.error);
        }
    });
Office.BeforeDocumentCloseNotification:interface:
  - |-
    // Enable the before document close modal notification dialog. 
    async function enableNotification() {
        await Office.addin.beforeDocumentCloseNotification.enable(); 
    }

    // Add an event handler to detect when the document close operation is cancelled.
    Office.addin.beforeDocumentCloseNotification.onCloseActionCancelled(async function () {
        // When the document close attempt is cancelled, write a message to the active range in the worksheet.
        await Excel.run(async (context) => {
            const range = context.workbook.getSelectedRange();
            range.values = [["Detected onCloseActionCancelled event."]];
            await context.sync();
        });
    });    
Office.Binding#addHandlerAsync:member(2):
  - |-
    // The following code sample calls the select function of the Office object to access the binding
    // with ID "MyBinding", and then calls the addHandlerAsync method to add a handler function 
    // for the bindingDataChanged event of that binding.
    function addEventHandlerToBinding() {
        Office.select("bindings#MyBinding").addHandlerAsync(
            Office.EventType.BindingDataChanged, onBindingDataChanged);
    }

    function onBindingDataChanged(eventArgs) {
        write("Data has changed in binding: " + eventArgs.binding.id);
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
  - |-
    // To add an event handler for the BindingSelectionChanged event of a binding, 
    // use the addHandlerAsync method of the Binding object.
    // The event handler receives an argument of type BindingSelectionChangedEventArgs.
    function addEventHandlerToBinding() {
        Office.select("bindings#MyBinding").addHandlerAsync(
            Office.EventType.BindingSelectionChanged, onBindingSelectionChanged);
    }

    function onBindingSelectionChanged(eventArgs) {
        write(eventArgs.binding.id + " has been selected.");
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.BindingSelectionChangedEventArgs#columnCount:member:
  - |-
    // The following example adds an event handler for the SelectionChanged event to the binding with an id of myTable.
    // When the user changes the selection, the handler displays the coordinates of the first cell in the selection,
    // and the number of row and columns selected.
    function addSelectionHandler() {
        Office.context.document.bindings.getByIdAsync("myTable", function (result) {
            result.value.addHandlerAsync("bindingSelectionChanged", myHandler);
        });
    }

    // Display selection start coordinates and row/column count.
    function myHandler(bArgs) {
        write("Selection start row/col: " + bArgs.startRow + "," + bArgs.startColumn);
        write("Selection row count: " + bArgs.rowCount);
        write("Selection col count: " + bArgs.columnCount);
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.BindingSelectionChangedEventArgs#rowCount:member:
  - |-
    // The following example adds an event handler for the SelectionChanged event to the binding with an id of myTable.
    // When the user changes the selection, the handler displays the coordinates of the first cell in the selection,
    // and the number of row and columns selected.
    function addSelectionHandler() {
        Office.context.document.bindings.getByIdAsync("myTable", function (result) {
            result.value.addHandlerAsync("bindingSelectionChanged", myHandler);
        });
    }

    // Display selection start coordinates and row/column count.
    function myHandler(bArgs) {
        write("Selection start row/col: " + bArgs.startRow + "," + bArgs.startColumn);
        write("Selection row count: " + bArgs.rowCount);
        write("Selection col count: " + bArgs.columnCount);
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.BindingSelectionChangedEventArgs#startColumn:member:
  - |-
    // The following example adds an event handler for the SelectionChanged event to the binding with an id of myTable.
    // When the user changes the selection, the handler displays the coordinates of the first cell in the selection,
    // and the number of row and columns selected.
    function addSelectionHandler() {
        Office.context.document.bindings.getByIdAsync("myTable", function (result) {
            result.value.addHandlerAsync("bindingSelectionChanged", myHandler);
        });
    }

    // Display selection start coordinates and row/column count.
    function myHandler(bArgs) {
        write("Selection start row/col: " + bArgs.startRow + "," + bArgs.startColumn);
        write("Selection row count: " + bArgs.rowCount);
        write("Selection col count: " + bArgs.columnCount);
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.BindingSelectionChangedEventArgs#startRow:member:
  - |-
    // The following example adds an event handler for the SelectionChanged event to the binding with an id of myTable.
    // When the user changes the selection, the handler displays the coordinates of the first cell in the selection,
    // and the number of row and columns selected.
    function addSelectionHandler() {
        Office.context.document.bindings.getByIdAsync("myTable", function (result) {
            result.value.addHandlerAsync("bindingSelectionChanged", myHandler);
        });
    }

    // Display selection start coordinates and row/column count.
    function myHandler(bArgs) {
        write("Selection start row/col: " + bArgs.startRow + "," + bArgs.startColumn);
        write("Selection row count: " + bArgs.rowCount);
        write("Selection col count: " + bArgs.columnCount);
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Binding#document:member:
  - |-
    Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
        write(asyncResult.value.document.url);
    });

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Binding#getDataAsync:member(2):
  - |-
    function showBindingData() {
        Office.select("bindings#MyBinding").getDataAsync(function (asyncResult) {
            write(asyncResult.value)
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }

    // There is an important difference in behavior between using the "table" and "matrix" coercionType with the
    // Binding.getDataAsync method, with respect to data formatted with header rows, as shown in the following
    // two examples. These code examples show event handler functions for the Binding.SelectionChanged event.

    // If you specify the "table" coercionType, the TableData.rows property ( result.value.rows in the following
    // code example) returns an array that contains only the body rows of the table. So, its 0th row will be the
    // first non-header row in the table.
    function selectionChanged(evtArgs) { 
        Office.select("bindings#TableTranslate").getDataAsync(
            { coercionType: 'table', 
              startRow: evtArgs.startRow, 
              startCol: 0, 
              rowCount: 1, 
              columnCount: 1 },  
            function (result) { 
                if (result.status == 'succeeded') { 
                    write("Image to find: " + result.value.rows[0][0]); 
                } 
                else 
                    write(result.error.message); 
        }); 
    }     
    // Function that writes to a div with id='message' on the page. 
    function write(message){ 
        document.getElementById('message').innerText += message; 
    }

    // However, if you specify the "matrix" coercionType, result.value in the following code example returns an array
    // that contains the table header in the 0th row. If the table header contains multiple rows, then these are all
    // included in the result.value matrix as separate rows before the table body rows are included.
    function selectionChanged(evtArgs) { 
        Office.select("bindings#TableTranslate").getDataAsync(
            { coercionType: 'matrix', 
              startRow: evtArgs.startRow, 
              startCol: 0, 
              rowCount: 1, 
              columnCount: 1 },  
            function (result) { 
                if (result.status == 'succeeded') { 
                    write("Image to find: " + result.value[1][0]); 
                } 
                else 
                    write(result.error.message); 
        }); 
    }     
    // Function that writes to a div with id='message' on the page. 
    function write(message){ 
        document.getElementById('message').innerText += message; 
    }
Office.Binding#id:member:
  - |-
    Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
        write(asyncResult.value.id);
    });

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Binding#removeHandlerAsync:member(2):
  - |-
    function removeEventHandlerFromBinding() {
        Office.select("bindings#MyBinding").removeHandlerAsync(
            Office.EventType.BindingDataChanged, {handler:onBindingDataChanged});
    }
Office.Binding#setDataAsync:member(2):
  - |-
    function setBindingData() {
        Office.select("bindings#MyBinding").setDataAsync('Hello World!', function (asyncResult) { });
    }

    // Specifying the optional coercionType parameter lets you specify the kind of data you want to write to a binding.
    // For example, in Word if you want to write HTML to a text binding, you can specify the coercionType parameter 
    // as "html" as shown in the following example, which uses HTML <b> tags to make "Hello" bold.
    function writeHtmlData() {
        Office.select("bindings#myBinding").setDataAsync(
            "<b>Hello</b> World!", {coercionType: "html"}, function (asyncResult) {
            if (asyncResult.status == "failed") {
                write('Error: ' + asyncResult.error.message);
            }
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }

    // In this example, the call to setDataAsync passes the data parameter as an array of arrays
    // (to create a single column of three rows), and specifies the data structure with the 
    // coercionType parameter as a "matrix".
    function writeBoundDataMatrix() {
        Office.select("bindings#myBinding").setDataAsync(
            [['Berlin'],['Munich'],['Duisburg']],{ coercionType: "matrix" }, function (asyncResult) {
            if (asyncResult.status == "failed") {
                write('Error: ' + asyncResult.error.message);
            } else {
                write('Bound data: ' + asyncResult.value);
            }
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }

    // In the writeBoundDataTable function in this example, the call to setDataAsync passes the data parameter 
    // as a TableData object (to write three columns and three rows), and specifies the data structure
    // with the coercionType parameter as a "table".

    // In the updateTableData function, the call to setDataAsync again passes the data parameter as a TableData object,
    // but as a single column with a new header and three rows, to update the values in the last column 
    // of the table created with the writeBoundDataTable function. The optional zero-based startColumn parameter 
    // is specified as 2 to replace the values in the third column of the table.
    function writeBoundDataTable() {
        // Create a TableData object.
        const myTable = new Office.TableData();
        myTable.headers = ['First Name', 'Last Name', 'Grade'];
        myTable.rows = [['Kim', 'Abercrombie', 'A'], ['Junmin','Hao', 'C'],['Toni','Poe','B']];

        // Set myTable in the binding.
        Office.select("bindings#myBinding").setDataAsync(myTable, { coercionType: "table" }, 
            function (asyncResult) {
                if (asyncResult.status == Office.AsyncResultStatus.Failed) {
                    write('Error: '+ asyncResult.error.message);
            } else {
                write('Bound data: ' + asyncResult.value);
            }
        });
    }

    // Replace last column with different data.
    function updateTableData() {
        const newTable = new Office.TableData();
        newTable.headers = ["Gender"];
        newTable.rows = [["M"],["M"],["F"]];
        Office.select("bindings#myBinding").setDataAsync(newTable, { coercionType: "table", startColumn:2 }, 
            function (asyncResult) {
                if (asyncResult.status == Office.AsyncResultStatus.Failed) {
                    write('Error: '+ asyncResult.error.message);
            } else {
                write('Bound data: ' + asyncResult.value);
            }     
        });   
    }

    // In this example, the following call passes two formatting groups to cellFormat.
    Office.select("bindings#myBinding").setDataAsync([['Berlin'],['Munich'],['Duisburg']],
      {cellFormat:[{cells: {row: 1}, format: {fontColor: "yellow"}}, 
          {cells: {row: 3, column: 4}, format: {borderColor: "white", fontStyle: "bold"}}]}, 
      function (asyncResult){});
Office.Binding#type:member:
  - |-
    Office.context.document.bindings.getByIdAsync("MyBinding", function (asyncResult) { 
        write(asyncResult.value.type); 
    }) 

    // Function that writes to a div with id='message' on the page. 
    function write(message){ 
        document.getElementById('message').innerText += message;  
    }
Office.Bindings#addFromNamedItemAsync:member(1):
  - |-
    // The following example adds a binding to the myRange named item in Excel as a "matrix" binding,
    // and assigns the binding's id as myMatrix.
    function bindNamedItem() {
        Office.context.document.bindings.addFromNamedItemAsync(
            "myRange", "matrix", {id:'myMatrix'}, function (result) {
            if (result.status == 'succeeded'){
                write('Added new binding with type: ' + result.value.type + ' and id: ' + result.value.id);
                }
            else
                write('Error: ' + result.error.message);
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
    
    // The following example adds a binding to the Table1 named item in Excel as a "table" binding,
    // and assigns the binding's id as myTable.
    function bindNamedItem() {
        Office.context.document.bindings.addFromNamedItemAsync(
            "Table1", "table", {id:'myTable'}, function (result) {
            if (result.status == 'succeeded'){
                write('Added new binding with type: ' + result.value.type + ' and id: ' + result.value.id);
                }
            else
                write('Error: ' + result.error.message);
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
    
    // The following example creates a text binding in Word to a rich text content control named "FirstName",
    // assigns the id "firstName", and then displays that information.
    function bindContentControl() {
        Office.context.document.bindings.addFromNamedItemAsync('FirstName', 
            Office.BindingType.Text, {id:'firstName'},
            function (result) {
                if (result.status === Office.AsyncResultStatus.Succeeded) {
                    write('Control bound. Binding.id: '
                        + result.value.id + ' Binding.type: ' + result.value.type);
                } else {
                    write('Error:', result.error.message);
                }
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Bindings#addFromPromptAsync:member(1):
  - |-
    function addBindingFromPrompt() {
        Office.context.document.bindings.addFromPromptAsync(
            Office.BindingType.Text, 
            { id: 'MyBinding', promptText: 'Select text to bind to.' },
            function (asyncResult) {
                write('Added new binding with type: ' + asyncResult.value.type + ' and id: ' + asyncResult.value.id);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Bindings#addFromSelectionAsync:member(1):
  - |-
    function addBindingFromSelection() {
        Office.context.document.bindings.addFromSelectionAsync(Office.BindingType.Text, { id: 'MyBinding' }, 
            function (asyncResult) {
            write('Added new binding with type: ' + asyncResult.value.type + ' and id: ' + asyncResult.value.id);
            }
        );
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Bindings#getAllAsync:member(2):
  - |-
    function displayAllBindingNames() {
        Office.context.document.bindings.getAllAsync(function (asyncResult) {
            let bindingString = '';
            for (let i in asyncResult.value) {
                bindingString += asyncResult.value[i].id + '\n';
            }
            write('Existing bindings: ' + bindingString);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Bindings#getByIdAsync:member(2):
  - |-
    function displayBindingType() {
        Office.context.document.bindings.getByIdAsync('MyBinding', function (asyncResult) {
            write('Retrieved binding with type: ' + asyncResult.value.type + ' and id: ' + asyncResult.value.id);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Bindings#releaseByIdAsync:member(2):
  - |-
    Office.context.document.bindings.releaseByIdAsync("MyBinding", function (asyncResult) { 
        write("Released MyBinding!"); 
    }); 
    // Function that writes to a div with id='message' on the page. 
    function write(message){ 
        document.getElementById('message').innerText += message;  
    }
Office.CoercionType:enum:
  - |-
    // This function displays the currently selected text in the console.
    // It uses the Common APIs.
    function run() {
        Office.context.document.getSelectedDataAsync(Office.CoercionType.Text, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.error(asyncResult.error.message);
            } else {
                console.log(`The selected data is "${asyncResult.value}".`);
            }
        });
    }
Office.Context#contentLanguage:member:
  - |-
    function sayHelloWithContentLanguage() {
        const myContentLanguage = Office.context.contentLanguage;
        switch (myContentLanguage) {
            case 'en-US':
                write('Hello!');
                break;
            case 'en-NZ':
                write('G\'day mate!');
                break;
        }
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Context#commerceAllowed:member:
  - |-
    // Check if the add-in is running on an iPad.
    const allowCommerce = Office.context.commerceAllowed;
    const isTouchEnabled = Office.context.touchEnabled;
    if (!allowCommerce && isTouchEnabled) {
        // Add-in is running on an iPad.
        // Do something.
    }
Office.Context#diagnostics:member:
  - |-
    const contextInfo = Office.context.diagnostics;
    console.log("Office application: " + contextInfo.host);
    console.log("Office version: " + contextInfo.version);
    console.log("Platform: " + contextInfo.platform);
Office.Context#displayLanguage:member:
  - |-
    function sayHelloWithDisplayLanguage() {
        const myDisplayLanguage = Office.context.displayLanguage;
        switch (myDisplayLanguage) {
            case 'en-US':
                write('Hello!');
                break;
            case 'en-NZ':
                write('G\'day mate!');
                break;
        }
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Context#document:member:
  - |-
    // Extension initialization code.
    let _document;

    // The initialize function is required for all add-ins.
    Office.initialize = function () {
        // Checks for the DOM to load using the jQuery ready method.
        $(document).ready(function () {
        // After the DOM is loaded, code specific to the add-in can run.
        // Initialize instance variables to access API objects.
        _document = Office.context.document;
        });
    }
Office.Context#host:member:
  - |-
    const host = Office.context.host;
    if (host === Office.HostType.Excel || host === Office.HostType.PowerPoint || host === Office.HostType.Word) {
        // Do something.
    } else if (host === Office.HostType.Outlook) {
        // Do something.
    }
Office.Context#license:member:
  - |-
    const license = Office.context.license;
    console.log(`Office license: ${license}`);
Office.Context#mailbox:member:
  - |-
    // The following line of code access the item object of the JavaScript API for Office.
    const item = Office.context.mailbox.item;
Office.Context#officeTheme:member:
  - |-
    function applyOfficeTheme() {
        // Identify the current Office theme in use.
        const currentOfficeTheme = Office.context.officeTheme.themeId;

        if (currentOfficeTheme === Office.ThemeId.Colorful || currentOfficeTheme === Office.ThemeId.White) {
            console.log("No changes required.");
        }

        // Get the colors of the current Office theme.
        const bodyBackgroundColor = Office.context.officeTheme.bodyBackgroundColor;
        const bodyForegroundColor = Office.context.officeTheme.bodyForegroundColor;
        const controlBackgroundColor = Office.context.officeTheme.controlBackgroundColor;
        const controlForegroundColor = Office.context.officeTheme.controlForegroundColor;

        // Apply theme colors to a CSS class.
        $("body").css("background-color", bodyBackgroundColor);

        if (Office.context.officeTheme.isDarkTheme()) {
            $("h1").css("color", controlForegroundColor);
        }
    }
Office.Context#partitionKey:member:
  - |-
    // Store the value "Hello" in local storage with the key "myKey1".
    setInLocalStorage("myKey1", "Hello");

    // ... 

    // Retrieve the value stored in local storage under the key "myKey1".
    const message = getFromLocalStorage("myKey1");
    console.log(message);

    // ...

    function setInLocalStorage(key: string, value: string) {
        const myPartitionKey = Office.context.partitionKey;

        // Check if local storage is partitioned. 
        // If so, use the partition to ensure the data is only accessible by your add-in.
        if (myPartitionKey) {
            localStorage.setItem(myPartitionKey + key, value);
        } else {
            localStorage.setItem(key, value);
        }
    }

    function getFromLocalStorage(key: string) {
        const myPartitionKey = Office.context.partitionKey;

        // Check if local storage is partitioned.
        if (myPartitionKey) {
            return localStorage.getItem(myPartitionKey + key);
        } else {
            return localStorage.getItem(key);
        }
    }
Office.Context#platform:member:
- |-
    // Request permission from a user to access their devices from Office on the web.
    if (Office.context.platform === Office.PlatformType.OfficeOnline) {
        const deviceCapabilities = [
            Office.DevicePermissionType.camera,
            Office.DevicePermissionType.microphone
        ];
        Office.devicePermission
            .requestPermissions(deviceCapabilities)
            .then((isGranted) => {
                if (isGranted) {
                    // Do something with device capabilities.
                }
            })
            .catch((error) => {
                console.log("Permission denied.");
                console.error(error);
            });
    }
Office.Context#requirements:member:
  - |-
    // To use the setCellProperties API, check if ExcelApi 1.9 is supported.
    if (Office.context.requirements.isSetSupported("ExcelApi", "1.9")) {
        const cellProperties: Excel.SettableCellProperties[][] =
        colors2D.map(row =>
            row.map(color =>
                ({
                    format: {
                        fill: {
                            color: color
                        }
                    }
                })
            )
        );
        sheet.getRangeByIndexes(1, 1, originalSize, originalSize).setCellProperties(cellProperties);
    }
    ...
Office.Context#roamingSettings:member:
  - |-
    // Get the current value of the 'myKey' setting.
    const value = Office.context.roamingSettings.get('myKey');
    // Update the value of the 'myKey' setting.
    Office.context.roamingSettings.set('myKey', 'Hello World!');
    // Persist the change.
    Office.context.roamingSettings.saveAsync();
Office.Context#sensitivityLabelsCatalog:member:
  - |-
    // Check if the catalog of sensitivity labels is enabled on the current mailbox.
    Office.context.sensitivityLabelsCatalog.getIsEnabledAsync((asyncResult) => {
        // If the catalog is enabled, get all available sensitivity labels.
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded && asyncResult.value == true) {
            Office.context.sensitivityLabelsCatalog.getAsync((asyncResult) => {
                if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
                    const catalog = asyncResult.value;
                    console.log("Sensitivity Labels Catalog:");
                    console.log(JSON.stringify(catalog));
                } else {
                    console.log("Action failed with error: " + asyncResult.error.message);
                }
            });
        } else {
            console.log("Action failed with error: " + asyncResult.error.message);
        }
    });
Office.Context#touchEnabled:member:
  - |-
    // Check if the add-in is running on an iPad.
    const allowCommerce = Office.context.commerceAllowed;
    const isTouchEnabled = Office.context.touchEnabled;
    if (!allowCommerce && isTouchEnabled) {
        // Add-in is running on an iPad.
        // Do something.
    }
Office.Context#ui:member:
  - |-
    // Open a dialog and register an event handler.
    Office.context.ui.displayDialogAsync(
        "https://www.contoso.com/myDialog.html",
        { height: 30, width: 20 },
        (asyncResult) => {
            const dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );
Office.Context#urls:member:
  - |-
    // Get the value of the first parameter of the JavaScript runtime URL.
    // For example, if the URL is https://wwww.contoso.com/training?key1=value1&key2=value2,
    // the following function logs "First parameter value: value1" to the console.
    const url = Office.context.urls.javascriptRuntimeUrl;
    const regex = /=([^&]+)/;
    console.log(`First parameter value: ${url.match(regex)[1]}`);
Office.ContextInformation#host:member:
  - |-
    const contextInfo = Office.context.diagnostics;
    console.log("Office application: " + contextInfo.host);
Office.ContextInformation#platform:member:
  - |-
    const contextInfo = Office.context.diagnostics;
    console.log("Platform: " + contextInfo.platform);
Office.ContextInformation#version:member:
  - |-
    const contextInfo = Office.context.diagnostics;
    console.log("Office version: " + contextInfo.version);
Office.CustomXmlNode#baseName:member:
  - |-
    function showXmlNodeBaseNames() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*/*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    write(node.baseName);
                }
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlNode#getNodesAsync:member(2):
  - |-
    function showXmlChildNodes() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    node.getNodesAsync('*', function (nodeResults) {
                        write(nodeResults.value.length + " childNodes");
                    });
                }
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlNode#getNodeValueAsync:member(2):
  - |-
    function showXmlNodeValues() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*/*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    node.getNodeValueAsync(function (asyncResult) {
                        write(asyncResult.value);
                    });
                }
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlNode#getTextAsync:member(1):
  - |-
    // Get the built-in core properties XML part by using its ID. This results in a call to Word.
    Office.context.document.customXmlParts.getByIdAsync(
        "{6C3C8BC8-F283-45AE-878A-BAB7291924A1}", function (getByIdAsyncResult) {
        
        // Access the XML part.
        const xmlPart = getByIdAsyncResult.value;
        
        // Add namespaces to the namespace manager. These two calls result in two calls to Word.
        xmlPart.namespaceManager.addNamespaceAsync(
            'cp',
            'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
            function () {
            xmlPart.namespaceManager.addNamespaceAsync(
                'dc', 
                'http://purl.org/dc/elements/1.1/', 
                function () {

                // Get XML nodes by using an Xpath expression. This results in a call to Word.
                xmlPart.getNodesAsync("/cp:coreProperties/dc:title", function (getNodesAsyncResult) {
                    
                    // Get the first node returned by using the Xpath expression. 
                    const node = getNodesAsyncResult.value[0];
                    
                    // Get the text value of the node and use the asyncContext. This results in a call to Word. 
                    // The results are logged to the browser console.
                    node.getTextAsync({asyncContext: "StateNormal"}, function (getTextAsyncResult) {
                      console.log("Text of the title element = " + getTextAsyncResult.value;
                      console.log("The asyncContext value = " + getTextAsyncResult.asyncContext;
                    });
                });
            });
        });
    });
Office.CustomXmlNode#getXmlAsync:member(2):
  - |-
    function showXmlNodeInnerXml() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    node.getXmlAsync(function (asyncResult) {
                        write(asyncResult.value);
                    });
                }
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlNode#namespaceUri:member:
  - |-
    function showXmlNamespaceUri() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*/*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    write(node.namespaceUri);
                }
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlNode#nodeType:member:
  - |-
    function showXmlNodeType() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*/*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    write(node.nodeType);
                }
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlNode#setNodeValueAsync:member(2):
  - |-
    function setXmlNodeValue() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*/*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    write(node);
                    node.setNodeValueAsync("item number" + i, function (result) { });
                }
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlNode#setTextAsync:member(1):
  - |-
    // Learn how to set the text value of a node in a custom XML part from the following example.

    // Get the built-in core properties XML part by using its ID. This results in a call to Word.
    Office.context.document.customXmlParts.getByIdAsync(
        "{6C3C8BC8-F283-45AE-878A-BAB7291924A1}",
        function (getByIdAsyncResult) {
        
        // Access the XML part.
        const xmlPart = getByIdAsyncResult.value;
        
        // Add namespaces to the namespace manager. These two calls result in two calls to Word.
        xmlPart.namespaceManager.addNamespaceAsync(
            'cp', 
            'http://schemas.openxmlformats.org/package/2006/metadata/core-properties', 
            function () {
            xmlPart.namespaceManager.addNamespaceAsync(
                'dc', 
                'http://purl.org/dc/elements/1.1/', 
                function () {

                // Get XML nodes by using an Xpath expression. This results in a call to the host.
                xmlPart.getNodesAsync("/cp:coreProperties/dc:subject", function (getNodesAsyncResult) {
                    
                    // Get the first node returned by using the Xpath expression.
                    // This will be the subject element in this example.
                    const subjectNode = getNodesAsyncResult.value[0];
                    
                    // Set the text value of the subject node and use the asyncContext. 
                    // This results in a call to the host.  The results are logged to the browser console.
                    subjectNode.setTextAsync(
                        "newSubject", 
                        {asyncContext: "StateNormal"}, 
                        function (setTextAsyncResult) {
                            console.log("The status of the call: " + setTextAsyncResult.status);
                            console.log("The asyncContext value = " + setTextAsyncResult.asyncContext);
                    });
                });
            });
        });
    });
Office.CustomXmlNode#setXmlAsync:member(1):
  - |-
    function setXmlNodeInnerXml() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    node.setXmlAsync("<childNode>" + i + "</childNode>");
                }
            });
        });
    }
Office.CustomXmlPart#addHandlerAsync:member(2):
  - |-
    // To add an event handler for the NodeDeleted event, use the addHandlerAsync method of the CustomXmlPart object.
    function addNodeDeletedEvent() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.addHandlerAsync(Office.EventType.NodeDeleted, function (eventArgs) {
                write("A node has been deleted.");
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message;
    }
  - |-
    // To add an event handler for the NodeInserted event, use the addHandlerAsync method of the CustomXmlPart object.
    function addNodeInsertedEvent() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.addHandlerAsync(Office.EventType.NodeInserted, function (eventArgs) {
                write("A node has been inserted.");
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message;
    }
  - |-
    // To add an event handler for the NodeReplaced event, use the addHandlerAsync method of the CustomXmlPart object.
    function addNodeReplacedEvent() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.addHandlerAsync(Office.EventType.NodeReplaced, function (eventArgs) {
                write("A node has been replaced.");
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message;
    }
Office.CustomXmlPart#builtIn:member:
  - |-
    function showXMLPartBuiltIn() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            write(xmlPart.builtIn);
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlPart#deleteAsync:member(2):
  - |-
    function deleteXMLPart() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.deleteAsync(function (eventArgs) {
                write("The XML Part has been deleted.");
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlPart#getNodesAsync:member(2):
  - |-
    function showXmlNodeType() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getNodesAsync('*/*', function (nodeResults) {
                for (let i = 0; i < nodeResults.value.length; i++) {
                    const node = nodeResults.value[i];
                    write(node.nodeType);
                }
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlPart#getXmlAsync:member(2):
  - |-
    function showXMLPartInnerXML() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getXmlAsync(function (eventArgs) {
                write(eventArgs.value);
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlPart#id:member:
  - |-
    function showXMLPartBuiltId() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            write(xmlPart.id);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlPart#namespaceManager:member:
  - |-
    function setXMLPartNamespaceManagerNamespace() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.namespaceManager.addNamespaceAsync("myPrefix", "myNamespace");
        });
    }
Office.CustomXmlPart#removeHandlerAsync:member(2):
  - |-
    function removeNodeInsertedEventHandler() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}",
            function (result) {
                const xmlPart = result.value;
                xmlPart.removeHandlerAsync(Office.EventType.DataNodeInserted, {handler:myHandler});
        });
    }
Office.CustomXmlParts#addAsync:member(2):
  - |-
    function addXMLPart() {
        Office.context.document.customXmlParts.addAsync(
            '<root categoryId="1" xmlns="http://tempuri.org"><item name="Cheap Item" price="$193.95"/><item name="Expensive Item" price="$931.88"/></root>',
            function (result) {});
    }

    function addXMLPartandHandler() {
        Office.context.document.customXmlParts.addAsync(
            "<testns:book xmlns:testns='http://testns.com'><testns:page number='1'>Hello</testns:page><testns:page number='2'>world!</testns:page></testns:book>",
            function(r) { r.value.addHandlerAsync(Office.EventType.DataNodeDeleted,
                function(a) {write(a.type)
                },
                    function(s) {write(s.status)
                    });
            });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message;
    }
Office.CustomXmlParts#getByIdAsync:member(1):
  - |-
    function showXMLPartInnerXML() {
        Office.context.document.customXmlParts.getByIdAsync(
            "{3BC85265-09D6-4205-B665-8EB239A8B9A1}", function (result) {
            const xmlPart = result.value;
            xmlPart.getXmlAsync({}, function (eventArgs) {
                write(eventArgs.value);
            });
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.CustomXmlParts#getByNamespaceAsync:member(2):
  - |-
    function showXMLPartsInNamespace() {
        Office.context.document.customXmlParts.getByNamespaceAsync(
            "http://tempuri.org", 
            function (eventArgs) {
                write("Found " + eventArgs.value.length + " parts with this namespace");
        }); 
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.DevicePermission#requestPermissions:member(1):
  - |-
    // Request permission from a user to access their camera and microphone.
    if (Office.context.platform === Office.PlatformType.OfficeOnline) {
        const deviceCapabilities = [
            Office.DevicePermissionType.camera,
            Office.DevicePermissionType.microphone
        ];
        Office.devicePermission
            .requestPermissions(deviceCapabilities)
            .then((isGranted) => {
                if (isGranted) {
                    console.log("Permission granted.");
                    // Reload your add-in before you run code that uses the device capabilities.
                    location.reload();
                } else {
                    console.log("Permission has been previously granted and is already set in the iframe.");

                    // Since permission has been previously granted, you don't need to reload your add-in.

                    // Do something with the device capabilities.
                }
            })
            .catch((error) => {
                console.log("Permission denied.");
                console.error(error);

                // Do something when permission is denied.
            });
    }
Office.DevicePermission#requestPermissionsAsync:member(2):
  - |-
    // Request permission from a user to access their camera, geolocation, and microphone.
    if (Office.context.mailbox.diagnostics.hostName === "OutlookWebApp") {
        const deviceCapabilities = [
            Office.DevicePermissionType.camera,
            Office.DevicePermissionType.geolocation,
            Office.DevicePermissionType.microphone
        ];

        Office.devicePermission.requestPermissionsAsync(deviceCapabilities, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log("Permission denied.");

                // Do something when permission is denied.
            } else {
                if (asyncResult.value) {
                    console.log("Permission granted.");
                    // Reload your add-in before you run code that uses the device capabilities.
                    location.reload();
                } else {
                    console.log("Permission has been previously granted and is already set in the iframe.");
                    
                    // Since permission has been previously granted, you don't need to reload your add-in.

                    // Do something with the device capabilities.
                }
            }
        });
    }
Office.DevicePermissionType:enum:
  - |-
    // Request permission from a user to access their device capabilities.
    const host = Office.context.host;
    if (host === Office.HostType.Excel || host === Office.HostType.PowerPoint || host === Office.HostType.Word) {
        if (Office.context.platform === Office.PlatformType.OfficeOnline) {
            const deviceCapabilities = [
                Office.DevicePermissionType.camera,
                Office.DevicePermissionType.microphone
            ];
            Office.devicePermission
                .requestPermissions(deviceCapabilities)
                .then((isGranted) => {
                    if (isGranted) {
                        console.log("Permission granted.");
                        // Reload your add-in before you run code that uses the device capabilities.
                        location.reload();
                    } else {
                        console.log("Permission has been previously granted and is already set in the iframe.");

                        // Since permission has been previously granted, you don't need to reload your add-in.

                        // Do something with the device capabilities.
                    }
                })
                .catch((error) => {
                    console.log("Permission denied.");
                    console.error(error);

                    // Do something when permission is denied.
                });
        }
    } else if (host === Office.HostType.Outlook) {
        if (Office.context.mailbox.diagnostics.hostName === "OutlookWebApp") {
            const deviceCapabilities = [
                Office.DevicePermissionType.camera,
                Office.DevicePermissionType.geolocation,
                Office.DevicePermissionType.microphone
            ];

            Office.devicePermission.requestPermissionsAsync(deviceCapabilities, (asyncResult) => {
                if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                    console.log("Permission denied.");

                    // Do something when permission is denied.
                } else {
                    if (asyncResult.value) {
                        console.log("Permission granted.");
                        // Reload your add-in before you run code that uses the device capabilities.
                        location.reload();
                    } else {
                        console.log("Permission has been previously granted and is already set in the iframe.");
                        
                        // Since permission has been previously granted, you don't need to reload your add-in.

                        // Do something with the device capabilities.
                    }
                }
            });
        }
    } else {
        console.log("The add-in isn't running in Excel, Outlook, PowerPoint, or Word.");
    }
Office.Dialog#addEventHandler:member(1):
  - |-
    // The following example shows how to open a dialog with a specified size. It also shows
    // how to register a function to handle the message when Office.UI.messageParent() is called
    // in the dialog and how to use that handler to close the dialog. The implementation of the processMessage() function is omitted.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult) => {
            const dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );

    // The following example does the same thing in TypeScript.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult: Office.AsyncResult) => {
            const dialog: Office.Dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg: string) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );
Office.Dialog#close:member(1):
  - |-
    // The following example shows how to open a dialog with a specified size. It also shows
    // how to register a function to handle the message when Office.UI.messageParent() is called
    // in the dialog and how to use that handler to close the dialog. The implementation of the processMessage() function is omitted.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult) => {
            const dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );

    // The following example does the same thing in TypeScript.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult: Office.AsyncResult) => {
            const dialog: Office.Dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg: string) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );
Office.Dialog#messageChild:member(1):
  - |-
    // The following example shows how to send information about the current active worksheet to the dialog.
    await Excel.run(async (context) => {
        const worksheet = context.workbook.worksheets.getActiveWorksheet();
        worksheet.load();
        await context.sync();
        worksheetPropertiesChanged(worksheet);
    });

    ...

    function worksheetPropertiesChanged(currentWorksheet) {
        const messageToDialog = JSON.stringify(currentWorksheet);
        dialog.messageChild(messageToDialog);
    }
Office.DialogOptions#height:member:
  - |-
    // The following example shows how to open a dialog with a specified size. It also shows
    // how to register a function to handle the message when Office.UI.messageParent() is called
    // in the dialog and how to use that handler to close the dialog. The implementation of the processMessage() function is omitted.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult) => {
            const dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );

    // The following example does the same thing in TypeScript.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult: Office.AsyncResult) => {
            const dialog: Office.Dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg: string) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );
Office.DialogOptions#width:member:
  - |-
    // The following example shows how to open a dialog with a specified size. It also shows
    // how to register a function to handle the message when Office.UI.messageParent() is called
    // in the dialog and how to use that handler to close the dialog. The implementation of the processMessage() function is omitted.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult) => {
            const dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );

    // The following example does the same thing in TypeScript.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult: Office.AsyncResult) => {
            const dialog: Office.Dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg: string) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );
Office.Document:interface:
  - |-
    // Get the Document object with the Common APIs.
    const document : Office.Document = Office.context.document;
Office.Document#addHandlerAsync:member(2):
  - |-
    // The following example adds an event handler for the SelectionChanged event of a document
    function addSelectionChangedEventHandler() {
        Office.context.document.addHandlerAsync(Office.EventType.DocumentSelectionChanged, MyHandler);
    }

    function MyHandler(eventArgs) {
        write('Event raised: ' + eventArgs.type);
        doSomethingWithDocument(eventArgs.document);
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
  - |-
    // The following code example adds a handler for the ResourceSelectionChanged event.
    // When the resource selection changes in the document, it gets the GUID of the selected resource.
    // The example assumes your add-in has a reference to the jQuery library and that the
    // following page control is defined in the content div in the page body:
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                Office.context.document.addHandlerAsync(
                    Office.EventType.ResourceSelectionChanged,
                    getResourceGuid);
            });
        };

        // Get the GUID of the selected resource and display it in the add-in.
        function getResourceGuid() {
            Office.context.document.getSelectedResourceAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        $('#message').html(result.value);
                    }
                }
            );
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();

    // For a complete code sample that shows how to use a ResourceSelectionChanged
    // event handler in a Project add-in, see "Create your first task pane add-in for Microsoft Project".
    // https://learn.microsoft.com/office/dev/add-ins/project/create-your-first-task-pane-add-in-for-project-by-using-a-text-editor
  - |-
    // The following code example adds a handler for the TaskSelectionChanged event.
    // When the task selection changes in the document, it gets the GUID of the
    // selected task.
    // The example assumes your add-in has a reference to the jQuery library and that
    // the following page control is defined in the content div in the page body:
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                Office.context.document.addHandlerAsync(
                    Office.EventType.TaskSelectionChanged,
                    getTaskGuid);
                getTaskGuid();
            });
        };

        // Get the GUID of the selected task and display it in the add-in.
        function getTaskGuid() {
            Office.context.document.getSelectedTaskAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        $('#message').html(result.value);
                    }
                }
            );
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
  - |-
    // The following code example adds a handler for the ViewSelectionChanged
    // event. When the active view changes, it gets the name and type of the active view.
    // The example assumes your add-in has a reference to the jQuery library and that
    // the following page control is defined in the content div in the page body:
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                Office.context.document.addHandlerAsync(
                    Office.EventType.ViewSelectionChanged,
                    getActiveView);
                getActiveView();
            });
        };

        // Get the name and type of the active view and display it in the add-in.
        function getActiveView() {
            Office.context.document.getSelectedViewAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        const output = String.format(
                            'View name: {0}<br/>View type: {1}',
                            result.value.viewName, result.value.viewType);
                        $('#message').html(output);
                    }
                }
            );
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();

    // For an example that shows how to use a ViewSelectionChanged event handler in a
    // Project add-in, see "Create your first task pane add-in for Microsoft Project".
    // https://learn.microsoft.com/office/dev/add-ins/project/create-your-first-task-pane-add-in-for-project-by-using-a-text-editor
  - |-
    // The following code example uses addHandlerAsync to add an event handler for the ViewSelectionChanged event.
    // When the active view changes, the handler checks the view type. It enables a button if the view is a resource
    // view and disables the button if it isn't a resource view. Choosing the button gets the GUID of the selected
    // resource and displays it in the add-in.
    // The example assumes that your add-in has a reference to the jQuery library and that the following page controls
    // are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" disabled="disabled" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                // Add a ViewSelectionChanged event handler.
                Office.context.document.addHandlerAsync(
                    Office.EventType.ViewSelectionChanged,
                    getActiveView);
                $('#get-info').on("click", getResourceGuid);

                // This example calls the handler on page load to get the active view
                // of the default page.
                getActiveView();
            });
        };

        // Activate the button based on the active view type of the document.
        // This is the ViewSelectionChanged event handler.
        function getActiveView() {
            Office.context.document.getSelectedViewAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        const viewType = result.value.viewType;
                        if (viewType == 6 ||   // ResourceForm
                            viewType == 7 ||   // ResourceSheet
                            viewType == 8 ||   // ResourceGraph
                            viewType == 15) {  // ResourceUsage
                            $('#get-info').removeAttr('disabled');
                        }
                        else {
                            $('#get-info').attr('disabled', 'disabled');
                        }
                        const output = String.format(
                            'View name: {0}<br/>View type: {1}',
                            result.value.viewName, viewType);
                        $('#message').html(output);
                    }
                }
            );
        }

        // Get the GUID of the currently selected resource and display it in the add-in.
        function getResourceGuid() {
            Office.context.document.getSelectedResourceAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        $('#message').html('Resource GUID: ' + result.value);
                    }
                }
            );
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();

    // For a complete code sample that shows how to use a ViewSelectionChanged event handler in a Project add-in,
    // see "Create your first task pane add-in for Project by using a text editor."
    // https://learn.microsoft.com/office/dev/add-ins/project/create-your-first-task-pane-add-in-for-project-by-using-a-text-editor
Office.Document#bindings:member:
  - |-
    function displayAllBindings() {
        Office.context.document.bindings.getAllAsync(function (asyncResult) {
            let bindingString = '';
            for (let i in asyncResult.value) {
                bindingString += asyncResult.value[i].id + '\n';
            }
            write('Existing bindings: ' + bindingString);
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Document#customXmlParts:member:
  - |-
    function getCustomXmlParts(){
        Office.context.document.customXmlParts.getByNamespaceAsync('http://tempuri.org', function (asyncResult) {
            write('Retrieved ' + asyncResult.value.length + ' custom XML parts');
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Document#getActiveViewAsync:member(2):
  - |-
    function getFileView() {
        // Get whether the current view is edit or read.
        Office.context.document.getActiveViewAsync(function (asyncResult) {
            if (asyncResult.status == "failed") {
                showMessage("Action failed with error: " + asyncResult.error.message);
            }
            else {
                showMessage(asyncResult.value);
            }
        });
    }
Office.Document#getFileAsync:member(1):
  - |-
    // The following example gets the document in Office Open XML ("compressed") format in 65536 bytes (64 KB) slices.
    // Note: The implementation of app.showNotification in this example is from the Visual Studio template for Office Add-ins.
    function getDocumentAsCompressed() {
        Office.context.document.getFileAsync(Office.FileType.Compressed, { sliceSize: 65536 /*64 KB*/ }, 
            function (result) {
                if (result.status == "succeeded") {
                    // If the getFileAsync call succeeded, then
                    // result.value will return a valid File Object.
                    const myFile = result.value;
                    const sliceCount = myFile.sliceCount;
                    const docDataSlices = [];
                    let slicesReceived = 0, gotAllSlices = true;
                    app.showNotification("File size:" + myFile.size + " #Slices: " + sliceCount);

                    // Get the file slices.
                    getSliceAsync(myFile, 0, sliceCount, gotAllSlices, docDataSlices, slicesReceived);
                } else {
                    app.showNotification("Error:", result.error.message);
                }
        });
    }

    function getSliceAsync(file, nextSlice, sliceCount, gotAllSlices, docDataSlices, slicesReceived) {
        file.getSliceAsync(nextSlice, function (sliceResult) {
            if (sliceResult.status == "succeeded") {
                if (!gotAllSlices) { /* Failed to get all slices, no need to continue. */
                    return;
                }

                // Got one slice, store it in a temporary array.
                // (Or you can do something else, such as
                // send it to a third-party server.)
                docDataSlices[sliceResult.value.index] = sliceResult.value.data;
                if (++slicesReceived == sliceCount) {
                  // All slices have been received.
                  file.closeAsync();
                  onGotAllSlices(docDataSlices);
                }
                else {
                    getSliceAsync(file, ++nextSlice, sliceCount, gotAllSlices, docDataSlices, slicesReceived);
                }
            }
                else {
                    gotAllSlices = false;
                    file.closeAsync();
                    app.showNotification("getSliceAsync Error:", sliceResult.error.message);
                }
        });
    }

    function onGotAllSlices(docDataSlices) {
        let docData = [];
        for (let i = 0; i < docDataSlices.length; i++) {
            docData = docData.concat(docDataSlices[i]);
        }

        let fileContent = new String();
        for (let j = 0; j < docData.length; j++) {
            fileContent += String.fromCharCode(docData[j]);
        }

        // Now all the file content is stored in 'fileContent' variable,
        // you can do something with it, such as print, fax...
    }

    // The following example gets the document in PDF format.
    Office.context.document.getFileAsync(Office.FileType.Pdf,
        function(result) {
            if (result.status == "succeeded") {
                const myFile = result.value;
                const sliceCount = myFile.sliceCount;
                app.showNotification("File size:" + myFile.size + " #Slices: " + sliceCount);

                // Get the file slices.
                const docDataSlices = [];
                let slicesReceived = 0, gotAllSlices = true;
                getSliceAsync(myFile, 0, sliceCount, gotAllSlices, docDataSlices, slicesReceived);
                
                myFile.closeAsync();
            }
            else {
                app.showNotification("Error:", result.error.message);
            }
        }
    );
Office.Document#getFilePropertiesAsync:member(2):
  - |-
    // To read the URL of the current file, you need to write a callback function that returns the URL.
    // The following example shows how to:
    // 1. Pass an anonymous callback function that returns the value of the file's URL
    //    to the callback parameter of the getFilePropertiesAsync method.
    // 2. Display the value on the add-in's page.
    function getFileUrl() {
        // Get the URL of the current file.
        Office.context.document.getFilePropertiesAsync(function (asyncResult) {
            const fileUrl = asyncResult.value.url;
            if (fileUrl == "") {
                showMessage("The file hasn't been saved yet. Save the file and try again");
            }
            else {
                showMessage(fileUrl);
            }
        });
    }
Office.Document#getSelectedDataAsync:member(1):
  - |-
    // The following example uses the getSelectedDataAsync method of the Document object to retrieve the
    // user's current selection as text, and then display it in the add-in's page.

    // Displays the user's current selection.
    function showSelection() {
        Office.context.document.getSelectedDataAsync(
            Office.CoercionType.Text,
            {
                valueFormat: Office.ValueFormat.Unformatted,
                filterType: Office.FilterType.All
            },
            (result) => {
                const dataValue = result.value;
                write('Selected data is: ' + dataValue);
            }
        );
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
  - |-
    // To read the value of the current selection, you need to write a callback function that reads the selection.
    // The following example shows how to:
    // 1. Pass an anonymous callback function that reads the value of the current selection
    //    to the callback parameter of the getSelectedDataAsync method.
    // 2. Read the selection as text, unformatted, and not filtered.
    // 3. Display the value on the add-in's page.
    function getText() {
        Office.context.document.getSelectedDataAsync(
            Office.CoercionType.Text,
            {
                valueFormat: Office.ValueFormat.Unformatted,
                filterType: Office.FilterType.All
            },
            (asyncResult) => {
                const error = asyncResult.error;
                if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                    write(error.name + ": " + error.message);
                } 
                else {
                    // Get selected data.
                    const dataValue = asyncResult.value; 
                    write('Selected data is ' + dataValue);
                }
            }
        );
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
  - |-
    // The following code example gets the values of the selected cells. It uses the optional
    // asyncContext parameter to pass some text to the callback function.
    // The example assumes your add-in has a reference to the jQuery library and that the
    // following page controls are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    // The onReady function must be run each time a new page is loaded.
    Office.onReady(() => {
        $(document).ready(() => {
            // After the DOM is loaded, add-in-specific code can run.
            $('#get-info').on("click", getSelectedText);
        });
    });

    // Gets the text from the selected cells in the document, and displays it in the add-in.
    function getSelectedText() {
        Office.context.document.getSelectedDataAsync(
            Office.CoercionType.Text,
            { asyncContext: "Some related info" },
            (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    onError(result.error);
                }
                else {
                    const output = String.format(
                        'Selected text: {0}<br/>Passed info: {1}',
                        result.value, result.asyncContext);
                    $('#message').html(output);
                }
            }
        );
    }

    function onError(error) {
        $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
    }
Office.Document#goToByIdAsync:member(2):
  - |-
    // Go to a binding by id (Word and Excel)
    // The following example shows how to:
    // 1. Create a table binding using the addFromSelectionAsync method as a sample binding to work with.
    // 2. Specify that binding as the binding to go to.
    // 3. Pass an anonymous callback function that returns the status of the operation
    //    to the callback parameter of the goToByIdAsync method.
    // 4. Display the value on the add-in's page.
    function gotoBinding() {
        // Create a new table binding for the selected table.
        Office.context.document.bindings.addFromSelectionAsync("table",{ id: "MyTableBinding" }, function (asyncResult) {
        if (asyncResult.status == "failed") {
                  showMessage("Action failed with error: " + asyncResult.error.message);
              }
              else {
                  showMessage("Added new binding with type: " + asyncResult.value.type +" and id: " + asyncResult.value.id);
              }
        });

        // Go to binding by id.
        Office.context.document.goToByIdAsync("MyTableBinding", Office.GoToType.Binding, function (asyncResult) {
            if (asyncResult.status == "failed") {
                showMessage("Action failed with error: " + asyncResult.error.message);
            }
            else {
                showMessage("Navigation successful");
            }
        });
    }

    // Go to a table in a spreadsheet (Excel)
    // The following example shows how to:
    // 1. Specify a table by name as the table to go to.
    // 2. Pass an anonymous callback function that returns the status of the operation
    //    to the callback parameter of the goToByIdAsync method.
    // 3. Display the value on the add-in's page.
    function goToTable() {
        Office.context.document.goToByIdAsync("Table1", Office.GoToType.NamedItem, function (asyncResult) {
            if (asyncResult.status == "failed") {
                showMessage("Action failed with error: " + asyncResult.error.message);
            }
            else {
                showMessage("Navigation successful");
            }
        });
    }

    // Go to the currently selected slide by id (PowerPoint)
    // The following example shows how to:
    // 1. Get the id of the currently selected slides using the getSelectedDataAsync method.
    // 2. Specify the returned id as the slide to go to.
    // 3. Pass an anonymous callback function that returns the status of the operation
    //    to the callback parameter of the goToByIdAsync method.
    // 4. Display the value of the stringified JSON object returned by asyncResult.value,
    //    which contains information about the selected slides, on the add-in's page.
    let firstSlideId = 0;
    function gotoSelectedSlide() {
        //Get currently selected slide's id
        Office.context.document.getSelectedDataAsync(Office.CoercionType.SlideRange, function (asyncResult) {
            if (asyncResult.status == "failed") {
                app.showNotification("Action failed with error: " + asyncResult.error.message);
            }
            else {
                firstSlideId = asyncResult.value.slides[0].id;
                app.showNotification(JSON.stringify(asyncResult.value));
            }
        });
        //Go to slide by id.
        Office.context.document.goToByIdAsync(firstSlideId, Office.GoToType.Slide, function (asyncResult) {
            if (asyncResult.status == "failed") {
                app.showNotification("Action failed with error: " + asyncResult.error.message);
            }
            else {
                app.showNotification("Navigation successful");
            }
        });
    }

    // Go to slide by index (PowerPoint)
    // The following example shows how to:
    // 1. Specify the index of the first, last, previous, or next slide to go to.
    // 2. Pass an anonymous callback function that returns the status of the operation
    //    to the callback parameter of the goToByIdAsync method.
    // 3. Display the value on the add-in's page.
    function goToSlideByIndex() {
        const goToFirst = Office.Index.First;
        const goToLast = Office.Index.Last;
        const goToPrevious = Office.Index.Previous;
        const goToNext = Office.Index.Next;

        Office.context.document.goToByIdAsync(goToNext, Office.GoToType.Index, function (asyncResult) {
            if (asyncResult.status == "failed") {
                showMessage("Action failed with error: " + asyncResult.error.message);
            }
            else {
                showMessage("Navigation successful");
            }
        });
    }
Office.Document#mode:member:
  - |-
    function displayDocumentMode() {
        write(Office.context.document.mode);
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
  - |-
    // The following example initializes the add-in and then gets properties of the
    // Document object that are available in the context of a Project document.
    // A Project document is the opened, active project. To access members of the
    // ProjectDocument object, use the Office.context.document object as shown in
    // the code examples for ProjectDocument methods and events.
    // The example assumes your add-in has a reference to the jQuery library and
    // that the following page control is defined in the content div in the page body:
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // Get information about the document.
                showDocumentProperties();
            });
        };

        // Get the document mode and the URL of the active project.
        function showDocumentProperties() {
            const output = String.format(
                'The document mode is {0}.<br/>The URL of the active project is {1}.',
                Office.context.document.mode,
                Office.context.document.url);
            $('#message').html(output);
        }
    })();
Office.Document#removeHandlerAsync:member(2):
  - |-
    // The following example removes the event handler named 'MyHandler'.
    function removeSelectionChangedEventHandler() {
        Office.context.document.removeHandlerAsync(Office.EventType.DocumentSelectionChanged, {handler:MyHandler});
    }

    function MyHandler(eventArgs) {
        doSomethingWithDocument(eventArgs.document);
    }
  - |-
    // The following code example uses addHandlerAsync to add an event handler for the
    // ResourceSelectionChanged event and removeHandlerAsync to remove the handler.
    // When a resource is selected in a resource view, the handler displays the
    // resource GUID. When the handler is removed, the GUID is not displayed.
    // The example assumes that your add-in has a reference to the jQuery library and
    // that the following page control is defined in the content div in the page body:
    // <input id="remove-handler" type="button" value="Remove handler" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                Office.context.document.addHandlerAsync(
                    Office.EventType.ResourceSelectionChanged,
                    getResourceGuid);
                $('#remove-handler').on("click", removeEventHandler);
            });
        };

        // Remove the event handler.
        function removeEventHandler() {
            Office.context.document.removeHandlerAsync(
                Office.EventType.ResourceSelectionChanged,
                {handler:getResourceGuid,
                asyncContext:'The handler is removed.'},
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        $('#remove-handler').attr('disabled', 'disabled');
                        $('#message').html(result.asyncContext);
                    }
                }
            );
        }

        // Get the GUID of the currently selected resource and display it in the add-in.
        function getResourceGuid() {
            Office.context.document.getSelectedResourceAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        $('#message').html('Resource GUID: ' + result.value);
                    }
                }
            );
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#setSelectedDataAsync:member(1):
  - |-
    // The following example sets the selected text or cell to "Hello World!", 
    // and if that fails, displays the value of the error.message property.
    function writeText() {
        Office.context.document.setSelectedDataAsync("Hello World!",
            function (asyncResult) {
                const error = asyncResult.error;
                if (asyncResult.status === Office.AsyncResultStatus.Failed){
                    write(error.name + ": " + error.message);
                }
            });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }

    // Specifying the optional coercionType parameter lets you specify the kind of data you want to write
    // to a selection. The following example writes data as an array of three rows of two columns, 
    // specifying the coercionType as `Matrix` for that data structure, and if that fails, 
    // displays the value of the error.message property.
    function writeMatrix() {
        Office.context.document.setSelectedDataAsync(
            [["Red", "Rojo"], ["Green", "Verde"], ["Blue", "Azul"]],
            {coercionType: Office.CoercionType.Matrix}
            function (asyncResult) {
                const error = asyncResult.error;
                if (asyncResult.status === Office.AsyncResultStatus.Failed){
                    write(error.name + ": " + error.message);
                }
            });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }

    // The following example writes data as a one column table with a header and four rows, 
    // specifying the coercionType as `Table` for that data structure, and if that fails, 
    // displays the value of the error.message property.
    function writeTable() {
        // Build table.
        const myTable = new Office.TableData();
        myTable.headers = [["Cities"]];
        myTable.rows = [['Berlin'], ['Roma'], ['Tokyo'], ['Seattle']];

        // Write table.
        Office.context.document.setSelectedDataAsync(myTable, {coercionType: Office.CoercionType.Table},
            function (result) {
                const error = result.error
                if (result.status === Office.AsyncResultStatus.Failed) {
                    write(error.name + ": " + error.message);
                }
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }

    // In Word if you want to write HTML to the selection, you can specify the coercionType parameter as `Html`
    // as shown in the following example, which uses HTML <b> tags to make "Hello" bold.
    function writeHtmlData() {
        Office.context.document.setSelectedDataAsync(
            "<b>Hello</b> World!", {coercionType: Office.CoercionType.Html}, function (asyncResult) {
                if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                    write('Error: ' + asyncResult.error.message);
                }
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }

    // In Word, PowerPoint, or Excel, if you want to write an image to the selection, you can specify the coercionType
    // parameter as `Image` as shown in the following example. Note that imageLeft and imageTop are ignored by Word.
    function insertPictureAtSelection(base64EncodedImageStr) {

        Office.context.document.setSelectedDataAsync(base64EncodedImageStr, {
            coercionType: Office.CoercionType.Image,
            imageLeft: 50,
            imageTop: 50,
            imageWidth: 100,
            imageHeight: 100
        },
        function (asyncResult) {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log("Action failed with error: " + asyncResult.error.message);
            }
        });
    }

    // In Word, PowerPoint, or Excel, if you want to write an scalable vector graphic (SVG) to the selection, you can specify the 
    // coercionType parameter as `XmlSvg` as shown in the following example. Note that imageLeft and imageTop are ignored by Word.
    function insertSvgAtSelection(base64EncodedImageStr) {
        Office.context.document.setSelectedDataAsync(getImageAsBase64String(), {
            coercionType: Office.CoercionType.XmlSvg,
            imageLeft: 50,
            imageTop: 50,
            imageWidth: 400
        },
            function (asyncResult) {
                if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                    console.log(asyncResult.error.message);
                }
            });
    }
Office.Document#url:member:
  - |-
    function displayDocumentUrl() {
        write(Office.context.document.url);
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Error#code:member:
  - |-
    // To cause an error to be thrown, select a table or a matrix, and then call the setText function.
    function setText() {
        Office.context.document.setSelectedDataAsync("Hello World!",
            function (asyncResult) {
                if (asyncResult.status === "failed")
                    const error = asyncResult.error;
                write(error.name + ": " + error.code + " - " + error.message);
            });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Error#message:member:
  - |-
    // To cause an error to be thrown, select a table or a matrix, and then call the setText function.
    function setText() {
        Office.context.document.setSelectedDataAsync("Hello World!",
            function (asyncResult) {
                if (asyncResult.status === "failed")
                    const error = asyncResult.error;
                write(error.name + ": " + error.message);
            });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Error#name:member:
  - |-
    // To cause an error to be thrown, select a table or a matrix, and then call the setText function.
    function setText() {
        Office.context.document.setSelectedDataAsync("Hello World!",
            function (asyncResult) {
                if (asyncResult.status === "failed")
                    const error = asyncResult.error;
                write(error.name + ": " + error.message);
            });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.FileType:enum:
  - |-
    // The following example gets the document in Office Open XML ("compressed") format in 65536 bytes (64 KB) slices.
    // Note: The implementation of app.showNotification in this example is from the Visual Studio template for Office Add-ins.
    function getDocumentAsCompressed() {
        Office.context.document.getFileAsync(Office.FileType.Compressed, { sliceSize: 65536 /*64 KB*/ }, 
            function (result) {
                if (result.status == "succeeded") {
                    // If the getFileAsync call succeeded, then
                    // result.value will return a valid File Object.
                    const myFile = result.value;
                    const sliceCount = myFile.sliceCount;
                    const docDataSlices = [];
                    let slicesReceived = 0, gotAllSlices = true;
                    app.showNotification("File size:" + myFile.size + " #Slices: " + sliceCount);

                    // Get the file slices.
                    getSliceAsync(myFile, 0, sliceCount, gotAllSlices, docDataSlices, slicesReceived);
                } else {
                    app.showNotification("Error:", result.error.message);
                }
        });
    }

    function getSliceAsync(file, nextSlice, sliceCount, gotAllSlices, docDataSlices, slicesReceived) {
        file.getSliceAsync(nextSlice, function (sliceResult) {
            if (sliceResult.status == "succeeded") {
                if (!gotAllSlices) { /* Failed to get all slices, no need to continue. */
                    return;
                }

                // Got one slice, store it in a temporary array.
                // (Or you can do something else, such as
                // send it to a third-party server.)
                docDataSlices[sliceResult.value.index] = sliceResult.value.data;
                if (++slicesReceived == sliceCount) {
                  // All slices have been received.
                  file.closeAsync();
                  onGotAllSlices(docDataSlices);
                }
                else {
                    getSliceAsync(file, ++nextSlice, sliceCount, gotAllSlices, docDataSlices, slicesReceived);
                }
            }
                else {
                    gotAllSlices = false;
                    file.closeAsync();
                    app.showNotification("getSliceAsync Error:", sliceResult.error.message);
                }
        });
    }

    function onGotAllSlices(docDataSlices) {
        let docData = [];
        for (let i = 0; i < docDataSlices.length; i++) {
            docData = docData.concat(docDataSlices[i]);
        }

        let fileContent = new String();
        for (let j = 0; j < docData.length; j++) {
            fileContent += String.fromCharCode(docData[j]);
        }

        // Now all the file content is stored in 'fileContent' variable,
        // you can do something with it, such as print, fax...
    }
Office.initialize:function(1):
  - |-
    // You can use the value of the InitializationEnumeration to implement different logic for
    // when the add-in is first inserted versus when it is already part of the document.
    // The following example shows some simple logic that uses the value of the reason parameter
    // to display how the task pane or content add-in was initialized.
    Office.initialize = function (reason) {
        // Checks for the DOM to load using the jQuery ready method.
        $(document).ready(function () {
        // After the DOM is loaded, code specific to the add-in can run.
        // Display initialization reason.
        if (reason == "inserted")
        write("The add-in was just inserted.");

        if (reason == "documentOpened")
        write("The add-in is already part of the document.");
        });
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.MatrixBinding#columnCount:member:
  - |-
    function showBindingColumnCount() {
        Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
            write("Column: " + asyncResult.value.columnCount);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.MatrixBinding#rowCount:member:
  - |-
    function showBindingRowCount() {
        Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
            write("Rows: " + asyncResult.value.rowCount);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.OfficeTheme:interface:
  - |-
    function applyOfficeTheme() {
        // Identify the current Office theme in use.
        const currentOfficeTheme = Office.context.officeTheme.themeId;

        if (currentOfficeTheme === Office.ThemeId.Colorful || currentOfficeTheme === Office.ThemeId.White) {
            console.log("No changes required.");
        }

        // Get the colors of the current Office theme.
        const bodyBackgroundColor = Office.context.officeTheme.bodyBackgroundColor;
        const bodyForegroundColor = Office.context.officeTheme.bodyForegroundColor;
        const controlBackgroundColor = Office.context.officeTheme.controlBackgroundColor;
        const controlForegroundColor = Office.context.officeTheme.controlForegroundColor;

        // Apply theme colors to a CSS class.
        $("body").css("background-color", bodyBackgroundColor);

        if (Office.context.officeTheme.isDarkTheme()) {
            $("h1").css("color", controlForegroundColor);
        }
    }
Office.Document#getMaxResourceIndexAsync:member(2):
  - |-
    // The following code example calls getResourceTaskIndexAsync to get the maximum index of the collection 
    // of resources in the current project. Then it uses the returned value and the getResourceByIndexAsync
    // method to get each resource GUID. The example assumes that your add-in has a reference to the 
    // jQuery library and that the following page controls are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";
        const resourceGuids = [];

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                app.initialize();
                $('#get-info').on("click", getResourceInfo);
            });
        };

        // Get the maximum resource index, and then get the resource GUIDs.
        function getResourceInfo() {
            getMaxResourceIndex().then(
                function (data) {
                    getResourceGuids(data);
                }
            );
        }

        // Get the maximum index of the resources for the current project.
        function getMaxResourceIndex() {
            const defer = $.Deferred();
            Office.context.document.getMaxResourceIndexAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get each resource GUID, and then display the GUIDs in the add-in.
        // There is no 0 index for resources, so start with index 1.
        function getResourceGuids(maxResourceIndex) {
            const defer = $.Deferred();
            for (let i = 1; i <= maxResourceIndex; i++) {
                getResourceGuid(i);
            }
            return defer.promise();
            function getResourceGuid(index) {
                Office.context.document.getResourceByIndexAsync(index,
                    function (result) {
                        if (result.status === Office.AsyncResultStatus.Succeeded) {
                            resourceGuids.push(result.value);
                            if (index == maxResourceIndex) {
                                defer.resolve();
                                $('#message').html(resourceGuids.toString());
                            }
                        }
                        else {
                            onError(result.error);
                        }
                    }
                );
            }
        }
        function onError(error) {
            app.showNotification(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getMaxTaskIndexAsync:member(2):
  - |-
    // The following code example calls getMaxTaskIndexAsync to get the maximum index
    // of the collection of tasks in the current project. Then it uses the returned value
    // with the getTaskByIndexAsync method to get each task GUID.
    // The example assumes your add-in has a reference to the jQuery library and that the
    // following page controls are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";
        const taskGuids = [];

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                app.initialize();
                $('#get-info').on("click", getTaskInfo);
            });
        };

        // Get the maximum task index, and then get the task GUIDs.
        function getTaskInfo() {
            getMaxTaskIndex().then(
                function (data) {
                    getTaskGuids(data);
                }
            );
        }

        // Get the maximum index of the tasks for the current project.
        function getMaxTaskIndex() {
            const defer = $.Deferred();
            Office.context.document.getMaxTaskIndexAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get each task GUID, and then display the GUIDs in the add-in.
        function getTaskGuids(maxTaskIndex) {
            const defer = $.Deferred();
            for (let i = 0; i <= maxTaskIndex; i++) {
                getTaskGuid(i);
            }
            return defer.promise();
            function getTaskGuid(index) {
                Office.context.document.getTaskByIndexAsync(index,
                    function (result) {
                        if (result.status === Office.AsyncResultStatus.Succeeded) {
                            taskGuids.push(result.value);
                            if (index == maxTaskIndex) {
                                defer.resolve();
                                $('#message').html(taskGuids.toString());
                            }
                        }
                        else {
                            onError(result.error);
                        }
                    }
                );
            }
        }
        function onError(error) {
            app.showNotification(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getProjectFieldAsync:member(2):
  - |-
    // The following code example gets the values of three specified fields for the active project, 
    // and then displays the values in the add-in.
    // The example calls getProjectFieldAsync recursively, after the previous call returns successfully.
    // It also tracks the calls to determine when all calls are sent.
    // The example assumes your add-in has a reference to the jQuery library and that the 
    // following page control is defined in the content div in the page body:
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // Get information for the active project.
                getProjectInformation();
            });
        };

        // Get the specified fields for the active project.
        function getProjectInformation() {
            const fields =
                [Office.ProjectProjectFields.Start, 
                 Office.ProjectProjectFields.Finish, 
                 Office.ProjectProjectFields.GUID];
            const fieldValues = ['Start: ', 'Finish: ', 'GUID: '];
            let index = 0; 
            getField();

            // Get each field, and then display the field values in the add-in.
            function getField() {
                if (index == fields.length) {
                    let output = '';
                    for (let i = 0; i < fieldValues.length; i++) {
                        output += fieldValues[i] + '<br />';
                    }
                    $('#message').html(output);
                }
                else {
                    Office.context.document.getProjectFieldAsync(
                        fields[index],
                        function (result) {

                            // If the call is successful, get the field value and then get the next field.
                            if (result.status === Office.AsyncResultStatus.Succeeded) {
                                fieldValues[index] += result.value.fieldValue;
                                getField(index++);
                            }
                            else {
                                onError(result.error);
                            }
                        }
                    );
                }
            }
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getResourceByIndexAsync:member(2):
  - |-
    // The following code example calls getMaxResourceIndexAsync to get the maximum index in the project's resource
    // collection, and then calls getResourceByIndexAsync to get the GUID for each resource.
    // The example assumes that your add-in has a reference to the jQuery library and that the following 
    // page controls are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";
        const resourceGuids = [];

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                app.initialize();
                $('#get-info').on("click", getResourceInfo);
            });
        };

        // Get the maximum resource index, and then get the resource GUIDs.
        function getResourceInfo() {
            getMaxResourceIndex().then(
                function (data) {
                    getResourceGuids(data);
                }
            );
        }

        // Get the maximum index of the resources for the current project.
        function getMaxResourceIndex() {
            const defer = $.Deferred();
            Office.context.document.getMaxResourceIndexAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get each resource GUID, and then display the GUIDs in the add-in.
        // There is no 0 index for resources, so start with index 1.
        function getResourceGuids(maxResourceIndex) {
            const defer = $.Deferred();
            for (let i = 1; i <= maxResourceIndex; i++) {
                getResourceGuid(i);
            }
            return defer.promise();
            function getResourceGuid(index) {
                Office.context.document.getResourceByIndexAsync(index,
                    function (result) {
                        if (result.status === Office.AsyncResultStatus.Succeeded) {
                            resourceGuids.push(result.value);
                            if (index == maxResourceIndex) {
                                defer.resolve();
                                $('#message').html(resourceGuids.toString());
                            }
                        }
                        else {
                            onError(result.error);
                        }
                    }
                );
            }
        }
        function onError(error) {
            app.showNotification(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getResourceFieldAsync:member(2):
  - |-
    // The following code example calls getSelectedResourceAsync to get the GUID of the resource
    // that's currently selected in a resource view. Then it gets three resource field values by calling 
    // getResourceFieldAsync recursively.
    // The example assumes your add-in has a reference to the jQuery library and that the following 
    // page controls are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                $('#get-info').on("click", getResourceInfo);
            });
        };

        // Get the GUID of the resource and then get the resource fields.
        function getResourceInfo() {
            getResourceGuid().then(
                function (data) {
                    getResourceFields(data);
                }
            );
        }

        // Get the GUID of the selected resource.
        function getResourceGuid() {
            const defer = $.Deferred();
            Office.context.document.getSelectedResourceAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get the specified fields for the selected resource.
        function getResourceFields(resourceGuid) {
            const targetFields =
                [Office.ProjectResourceFields.Name,
                 Office.ProjectResourceFields.Units, 
                 Office.ProjectResourceFields.BaseCalendar];
            const fieldValues = ['Name: ', 'Units: ', 'Base calendar: '];
            let index = 0; 
            getField();

            // Get each field, and then display the field values in the add-in.
            function getField() {
                if (index == targetFields.length) {
                    let output = '';
                    for (let i = 0; i < fieldValues.length; i++) {
                        output += fieldValues[i] + '<br />';
                    }
                    $('#message').html(output);
                }

                // If the call is successful, get the field value and then get the next field.
                else {
                    Office.context.document.getResourceFieldAsync(
                        resourceGuid,
                        targetFields[index],
                        function (result) {
                            if (result.status === Office.AsyncResultStatus.Succeeded) {
                                fieldValues[index] += result.value.fieldValue;
                                getField(index++);
                            }
                            else {
                                onError(result.error);
                            }
                        }
                    );
                }
            }
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getSelectedResourceAsync:member(2):
  - |-
    // The following code example calls getSelectedResourceAsync to get the GUID of the resource that's 
    // currently selected in a resource view. Then it gets three resource field values by calling 
    // getResourceFieldAsync recursively.
    // The example assumes your add-in has a reference to the jQuery library and that the following page controls are
    // defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                $('#get-info').on("click", getResourceInfo);
            });
        };

        // Get the GUID of the resource and then get the resource fields.
        function getResourceInfo() {
            getResourceGuid().then(
                function (data) {
                    getResourceFields(data);
                }
            );
        }

        // Get the GUID of the selected resource.
        function getResourceGuid() {
            const defer = $.Deferred();
            Office.context.document.getSelectedResourceAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get the specified fields for the selected resource.
        function getResourceFields(resourceGuid) {
            const targetFields =
                [Office.ProjectResourceFields.Name,
                 Office.ProjectResourceFields.Units, 
                 Office.ProjectResourceFields.BaseCalendar];
            const fieldValues = ['Name: ', 'Units: ', 'Base calendar: '];
            let index = 0; 
            getField();

            // Get each field, and then display the field values in the add-in.
            function getField() {
                if (index == targetFields.length) {
                    let output = '';
                    for (let i = 0; i < fieldValues.length; i++) {
                        output += fieldValues[i] + '<br />';
                    }
                    $('#message').html(output);
                }

                // If the call is successful, get the field value and then get the next field.
                else {
                    Office.context.document.getResourceFieldAsync(
                        resourceGuid,
                        targetFields[index],
                        function (result) {
                            if (result.status === Office.AsyncResultStatus.Succeeded) {
                                fieldValues[index] += result.value.fieldValue;
                                getField(index++);
                            }
                            else {
                                onError(result.error);
                            }
                        }
                    );
                }
            }
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getSelectedTaskAsync:member(2):
  - |-
    // The following code example calls getSelectedTaskAsync to get the GUID of the task that's currently
    // selected in a task view. Then it gets task properties by calling getTaskAsync.
    // The example assumes your add-in has a reference to the jQuery library and that the following page
    // controls are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                $('#get-info').on("click", getTaskInfo);
            });
        };

        // // Get the GUID of the task, and then get local task properties.
        function getTaskInfo() {
            getTaskGuid().then(
                function (data) {
                    getTaskProperties(data);
                }
            );
        }

        // Get the GUID of the selected task.
        function getTaskGuid() {
            const defer = $.Deferred();
            Office.context.document.getSelectedTaskAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get local properties for the selected task, and then display it in the add-in.
        function getTaskProperties(taskGuid) {
            Office.context.document.getTaskAsync(
                taskGuid,
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        const taskInfo = result.value;
                        const output = String.format(
                            'Name: {0}<br/>GUID: {1}<br/>SharePoint task ID: {2}<br/>Resource names: {3}',
                            taskInfo.taskName, taskGuid, taskInfo.wssTaskId, taskInfo.resourceNames);
                        $('#message').html(output);
                    }
                }
            );
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getSelectedViewAsync:member(2):
  - |-
    // The following code example calls adds a ViewSelectionChanged event handler that
    // calls getSelectedViewAsync to get the name and type of the active view in the document.
    // The example assumes your add-in has a reference to the jQuery library and that
    // the following page control is defined in the content div in the page body:
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                Office.context.document.addHandlerAsync(
                    Office.EventType.ViewSelectionChanged,
                    getActiveView);
                getActiveView();
            });
        };

        // Get the active view's name and type.
        function getActiveView() {
            Office.context.document.getSelectedViewAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        const output = String.format(
                            'View name: {0}<br/>View type: {1}',
                            result.value.viewName, viewType);
                        $('#message').html(output);
                    }
                }
            );
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getTaskAsync:member(2):
  - |-
    // The following code example calls getSelectedTaskAsync to get the task GUID of the currently
    // selected task. Then it calls getTaskAsync to get the properties for the task that are
    // available from the JavaScript API for Office.
    // The example assumes your add-in has a reference to the jQuery library and that the
    // following page controls are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                $('#get-info').on("click", getTaskInfo);
            });
        };

        // Get the GUID of the task, and then get local task properties.
        function getTaskInfo() {
            getTaskGuid().then(
                function (data) {
                    getTaskProperties(data);
                }
            );
        }

        // Get the GUID of the selected task.
        function getTaskGuid() {
            const defer = $.Deferred();
            Office.context.document.getSelectedTaskAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get local properties for the selected task, and then display it in the add-in.
        function getTaskProperties(taskGuid) {
            Office.context.document.getTaskAsync(
                taskGuid,
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        const taskInfo = result.value;
                        const output = String.format(
                            'Name: {0}<br/>GUID: {1}<br/>SharePoint task ID: {2}<br/>Resource names: {3}',
                            taskInfo.taskName, taskGuid, taskInfo.wssTaskId, taskInfo.resourceNames);
                        $('#message').html(output);
                    }
                }
            );
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getTaskByIndexAsync:member(2):
  - |-
    // The following code example calls getMaxTaskIndexAsync to get the
    // maximum index in the project's task collection, and then
    // calls getTaskByIndexAsync to get the GUID for each task.
    // The example assumes that your add-in has a reference to the
    // jQuery library and that the following page controls are defined
    // in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";
        const taskGuids = [];

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                app.initialize();
                $('#get-info').on("click", getTaskInfo);
            });
        };

        // Get the maximum task index, and then get the task GUIDs.
        function getTaskInfo() {
            getMaxTaskIndex().then(
                function (data) {
                    getTaskGuids(data);
                }
            );
        }

        // Get the maximum index of the tasks for the current project.
        function getMaxTaskIndex() {
            const defer = $.Deferred();
            Office.context.document.getMaxTaskIndexAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get each task GUID, and then display the GUIDs in the add-in.
        function getTaskGuids(maxTaskIndex) {
            const defer = $.Deferred();
            for (let i = 0; i <= maxTaskIndex; i++) {
                getTaskGuid(i);
            }
            return defer.promise();
            function getTaskGuid(index) {
                Office.context.document.getTaskByIndexAsync(index,
                    function (result) {
                        if (result.status === Office.AsyncResultStatus.Succeeded) {
                            taskGuids.push(result.value);
                            if (index == maxTaskIndex) {
                                defer.resolve();
                                $('#message').html(taskGuids.toString());
                            }
                        }
                        else {
                            onError(result.error);
                        }
                    }
                );
            }
        }
        function onError(error) {
            app.showNotification(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#getTaskFieldAsync:member(2):
  - |-
    // The following code example calls getSelectedTaskAsync to get the GUID of the task that's currently
    // selected in a task view. Then it gets two task field values by calling getTaskFieldAsync recursively.
    // The example assumes your add-in has a reference to the jQuery library and that the following page
    // controls are defined in the content div in the page body:
    // <input id="get-info" type="button" value="Get info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {
                
                // After the DOM is loaded, add-in-specific code can run.
                $('#get-info').on("click", getTaskInfo);
            });
        };

        // Get the GUID of the task, and then get the task fields.
        function getTaskInfo() {
            getTaskGuid().then(
                function (data) {
                    getTaskFields(data);
                }
            );
        }

        // Get the GUID of the selected task.
        function getTaskGuid() {
            const defer = $.Deferred();
            Office.context.document.getSelectedTaskAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Get the specified fields for the selected task.
        function getTaskFields(taskGuid) {
            let output = '';
            const targetFields = [Office.ProjectTaskFields.Priority, Office.ProjectTaskFields.PercentComplete];
            const fieldValues = ['Priority: ', '% Complete: '];
            let index = 0;
            getField();

            // Get each field, and then display the field values in the add-in.
            function getField() {
                if (index == targetFields.length) {
                    for (let i = 0; i < fieldValues.length; i++) {
                        output += fieldValues[i] + '<br />';
                    }
                    $('#message').html(output);
                }

                // Get the field value. If the call is successful, then get the next field.
                else {
                    Office.context.document.getTaskFieldAsync(
                        taskGuid,
                        targetFields[index],
                        function (result) {
                            if (result.status === Office.AsyncResultStatus.Succeeded) {
                                fieldValues[index] += result.value.fieldValue;
                                getField(index++);
                            }
                            else {
                                onError(result.error);
                            }
                        }
                    );
                }
            }
        }

        function onError(error) {
            $('#message').html(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#setResourceFieldAsync:member(2):
  - |-
    // The following code example calls getSelectedResourceAsync to get the GUID of the resource that's
    // currently selected in a resource view. Then it sets two resource field values by calling
    // setResourceFieldAsync recursively.
    // The getSelectedTaskAsync method used in the example requires that a task view
    // (for example, Task Usage) is the active view and that a task is selected. See the addHandlerAsync
    // method for an example that activates a button based on the active view type.
    // The example assumes your add-in has a reference to the jQuery library and that the
    // following page controls are defined in the content div in the page body:
    // <input id="set-info" type="button" value="Set info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {

                // After the DOM is loaded, add-in-specific code can run.
                app.initialize();
                $('#set-info').on("click", setResourceInfo);
            });
        };

        // Get the GUID of the resource, and then get the resource fields.
        function setResourceInfo() {
            getResourceGuid().then(
                function (data) {
                    setResourceFields(data);
                }
            );
        }

        // Get the GUID of the selected resource.
        function getResourceGuid() {
            const defer = $.Deferred();
            Office.context.document.getSelectedResourceAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Set the specified fields for the selected resource.
        function setResourceFields(resourceGuid) {
            const targetFields = [Office.ProjectResourceFields.StandardRate, Office.ProjectResourceFields.Notes];
            const fieldValues = [.28, 'Notes for the resource.'];

            // Set the field value. If the call is successful, set the next field.
            for (let i = 0; i < targetFields.length; i++) {
                Office.context.document.setResourceFieldAsync(
                    resourceGuid,
                    targetFields[i],
                    fieldValues[i],
                    function (result) {
                        if (result.status === Office.AsyncResultStatus.Succeeded) {
                            i++;
                        }
                        else {
                            onError(result.error);
                        }
                    }
                );
            }
            $('#message').html('Field values set');
        }

        function onError(error) {
            app.showNotification(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.Document#setTaskFieldAsync:member(2):
  - |-
    // The following code example calls getSelectedTaskAsync to get the GUID of the task that's
    // currently selected in a task view. Then it sets two task field values by calling
    // setTaskFieldAsync recursively.
    // The getSelectedTaskAsync method used in the example requires that a task view
    // (for example, Task Usage) is the active view and that a task is selected. See the
    // addHandlerAsync method for an example that activates a button based on the active view type.
    // The example assumes your add-in has a reference to the jQuery library and that the
    // following page controls are defined in the content div in the page body:
    // <input id="set-info" type="button" value="Set info" /><br />
    // <span id="message"></span>

    (function () {
        "use strict";

        // The initialize function must be run each time a new page is loaded.
        Office.initialize = function (reason) {
            $(document).ready(function () {
                
                // After the DOM is loaded, add-in-specific code can run.
                app.initialize();
                $('#set-info').on("click", setTaskInfo);
            });
        };

        // Get the GUID of the task, and then get the task fields.
        function setTaskInfo() {
            getTaskGuid().then(
                function (data) {
                    setTaskFields(data);
                }
            );
        }

        // Get the GUID of the selected task.
        function getTaskGuid() {
            const defer = $.Deferred();
            Office.context.document.getSelectedTaskAsync(
                function (result) {
                    if (result.status === Office.AsyncResultStatus.Failed) {
                        onError(result.error);
                    }
                    else {
                        defer.resolve(result.value);
                    }
                }
            );
            return defer.promise();
        }

        // Set the specified fields for the selected task.
        function setTaskFields(taskGuid) {
            const targetFields = [Office.ProjectTaskFields.Active, Office.ProjectTaskFields.Notes];
            const fieldValues = [true, 'Notes for the task.'];

            // Set the field value. If the call is successful, set the next field.
            for (let i = 0; i < targetFields.length; i++) {
                Office.context.document.setTaskFieldAsync(
                    taskGuid,
                    targetFields[i],
                    fieldValues[i],
                    function (result) {
                        if (result.status === Office.AsyncResultStatus.Succeeded) {
                            i++;
                        }
                        else {
                            onError(result.error);
                        }
                    }
                );
            }
            $('#message').html('Field values set');
        }

        function onError(error) {
            app.showNotification(error.name + ' ' + error.code + ': ' + error.message);
        }
    })();
Office.DocumentMode:enum:
  - |-
    const mode : Office.DocumentMode = Office.context.document.mode;
    console.log("Document mode: " + mode);
Office.EventType:enum:
  - |-
    // This sample shows how to register an event handler in Outlook.
    Office.onReady(() => {
        // Registers an event handler to identify when messages are selected.
        Office.context.mailbox.addHandlerAsync(Office.EventType.SelectedItemsChanged, getMessageProperties, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(asyncResult.error.message);
                return;
            }

            console.log("Event handler added for the SelectedItemsChanged event.");
        });
    });

    function getMessageProperties() {
        // Retrieves the selected messages' properties and logs them to the console.
        Office.context.mailbox.getSelectedItemsAsync((asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(asyncResult.error.message);
                return;
            }

            asyncResult.value.forEach((message) => {
                console.log(`Item ID: ${message.itemId}`);
                console.log(`Subject: ${message.subject}`);
                console.log(`Item type: ${message.itemType}`);
                console.log(`Item mode: ${message.itemMode}`);
            });
        });
    }
Office.File#getSliceAsync:member(1):
  - |-
    // This sample shows how to get all the slices of a file. 
    // The asynchronous operation returns a Promise so it can be awaited.
    private getAllSlices(file: any): Promise<any> {
        const self = this;
        let isError = false;

        return new Promise(async (resolve, reject) => {
            let documentFileData = [];
            for (let sliceIndex = 0; (sliceIndex < file.sliceCount) && !isError; sliceIndex++) {
                const sliceReadPromise = new Promise((sliceResolve, sliceReject) => {
                    file.getSliceAsync(sliceIndex, (asyncResult) => {
                        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
                            documentFileData = documentFileData.concat(asyncResult.value.data);
                            sliceResolve({
                                IsSuccess: true,
                                Data: documentFileData
                            });
                        } else {
                            file.closeAsync();
                            sliceReject({
                                IsSuccess: false,
                                ErrorMessage: `Error in reading the slice: ${sliceIndex} of the document`
                            });
                        }
                    });
                });
                await sliceReadPromise.catch((error) => {
                    isError = true;
                });
            }

            if (isError || !documentFileData.length) {
                reject('Error while reading document. Please try it again.');
                return;
            }

            file.closeAsync();

            resolve({
                IsSuccess: true,
                Data: documentFileData
            });
        });
    }
Office.HostType:enum:
  - |-
    const contextInfo = Office.context.diagnostics;
    const hostType: Office.HostType = contextInfo.host;
    console.log("Office application: " + hostType);
Office.PlatformType:enum:
  - |-
    const contextInfo = Office.context.diagnostics;
    const platformType: Office.PlatformType = contextInfo.platform;
    console.log("Platform: " + platformType);
Office.RequirementSetSupport:interface:
  - |-
    const requirements : Office.RequirementSetSupport = Office.context.requirements; 
    if (requirements.isSetSupported('Mailbox', '1.14')) {
        // Code that uses APIs from the 'Mailbox 1.14' requirement set.
    } else {
        // An alternate path (such as a message to the user) when the requirement set isn't supported.
    }
Office.Ribbon#requestCreateControls:member(1):
  - |-
    // Registers a custom contextual tab with Office.
    Office.onReady(async () => {
        const contextualTabJSON = ` ... `; // Assign the JSON string.
        const contextualTab = JSON.parse(contextualTabJSON);
        await Office.ribbon.requestCreateControls(contextualTab);
    });
Office.Ribbon#requestUpdate:member(1):
  - |-
    // Office.Tab objects are properties of ribbon updater objects that are passed to the 
    // Office.ribbon.requestUpdate method. The following shows how to set the visibility of 
    // a custom contextual tab.

    async function showDataTab() {
        await Office.ribbon.requestUpdate({
            tabs: [
                {
                    id: "CtxTab1",
                    visible: true
                }
            ]});
    }

    // The following does the same thing in TypeScript.

    const showDataTab = async () => {
        const myContextualTab: Office.Tab = { id: "CtxTab1", visible: true };
        const ribbonUpdater: Office.RibbonUpdaterData = { tabs: [ myContextualTab ] };
        await Office.ribbon.requestUpdate(ribbonUpdater);
    }
Office.RibbonUpdaterData#tabs:member:
  - |-
    // Office.Tab objects are properties of ribbon updater objects that are passed to the 
    // Office.ribbon.requestUpdate method. The following shows how to set the visibility of 
    // a custom contextual tab.

    async function showDataTab() {
        await Office.ribbon.requestUpdate({
            tabs: [
                {
                    id: "CtxTab1",
                    visible: true
                }
            ]});
    }

    // The following does the same thing in TypeScript.

    const showDataTab = async () => {
        const myContextualTab: Office.Tab = { id: "CtxTab1", visible: true };
        const ribbonUpdater: Office.RibbonUpdaterData = { tabs: [ myContextualTab ] };
        await Office.ribbon.requestUpdate(ribbonUpdater);
    }
Office.select:function(1):
  - |-
    // The following code example uses the select function to retrieve a binding with the id "cities" from
    // the Bindings collection, and then calls the addHandlerAsync method to add an event handler for the
    // dataChanged event of the binding.
    function addBindingDataChangedEventHandler() {
        Office.select("bindings#cities", function onError(){}).addHandlerAsync(Office.EventType.BindingDataChanged,
        function (eventArgs) {
            doSomethingWithBinding(eventArgs.binding);
        });
    }
Office.Settings#addHandlerAsync:member(2):
  - |-
    function addSelectionChangedEventHandler() {
        Office.context.document.settings.addHandlerAsync(Office.EventType.SettingsChanged, MyHandler);
    }

    function MyHandler(eventArgs) {
        write('Event raised: ' + eventArgs.type);
        doSomethingWithSettings(eventArgs.settings);
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Settings#get:member(1):
  - |-
    function displayMySetting() {
        write('Current value for mySetting: ' + Office.context.document.settings.get('mySetting'));
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Settings#refreshAsync:member(1):
  - |-
    function refreshSettings() {
        Office.context.document.settings.refreshAsync(function (asyncResult) {
            write('Settings refreshed with status: ' + asyncResult.status);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Settings#remove:member(1):
  - |-
    function removeMySetting() {
        Office.context.document.settings.remove('mySetting');
    }
Office.Settings#removeHandlerAsync:member(2):
  - |-
    function removeSettingsChangedEventHandler() {
        Office.context.document.settings.removeHandlerAsync(Office.EventType.SettingsChanged, MyHandler);
    }

    function MyHandler(eventArgs) {
        write('Event raised: ' + eventArgs.type);
        doSomethingWithSettings(eventArgs.settings);
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.Settings#saveAsync:member(2):
  - |-
    function persistSettings() {
        Office.context.document.settings.saveAsync(function (asyncResult) {
            write('Settings saved with status: ' + asyncResult.status);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.StartupBehavior:enum:
  - |-
    // Configure your add-in to load and start running when the document is opened.
    Office.addin.setStartupBehavior(Office.StartupBehavior.load);
Office.Tab:interface:
  - |-
    // Create an Office.Tab object (a contextual tab), set its visibility
    // and add it to the ribbon.
    async function showDataTab() {
        // Create the Office.Tab object.
        const myContextualTab = { id: "CtxTab1", visible: true };
        const ribbonUpdater = { tabs: [ myContextualTab ] };
        await Office.ribbon.requestUpdate(ribbonUpdater);
    }
Office.Tab#id:member:
  - |-
    // Office.Tab objects are properties of ribbon updater objects that are passed to the 
    // Office.ribbon.requestUpdate method. The following shows how to set the visibility of 
    // a custom contextual tab.

    async function showDataTab() {
        await Office.ribbon.requestUpdate({
            tabs: [
                {
                    id: "CtxTab1",
                    visible: true
                }
            ]});
    }

    // The the following does the same thing in TypeScript.

    const showDataTab = async () => {
        const myContextualTab: Office.Tab = { id: "CtxTab1", visible: true };
        const ribbonUpdater: Office.RibbonUpdaterData = { tabs: [ myContextualTab ] };
        await Office.ribbon.requestUpdate(ribbonUpdater);
    }
Office.Tab#visible:member:
  - |-
    // Office.Tab objects are properties of ribbon updater objects that are passed to the 
    // Office.ribbon.requestUpdate method. The following shows how to set the visibility of 
    // a custom contextual tab.

    async function showDataTab() {
        await Office.ribbon.requestUpdate({
            tabs: [
                {
                    id: "CtxTab1",
                    visible: true
                }
            ]});
    }

    // The following does the same thing in TypeScript.

    const showDataTab = async () => {
        const myContextualTab: Office.Tab = { id: "CtxTab1", visible: true };
        const ribbonUpdater: Office.RibbonUpdaterData = { tabs: [ myContextualTab ] };
        await Office.ribbon.requestUpdate(ribbonUpdater);
    }
Office.Settings#set:member(1):
  - |-
    function setMySetting() {
        Office.context.document.settings.set('mySetting', 'mySetting value');
    }
Office.TableBinding#addColumnsAsync:member(1):
  - |-
    // The following example adds a single column with three rows to a bound table with the id "myTable"
    // by passing a TableData object as the data argument of the addColumnsAsync method. To succeed,
    // the table being updated must have three rows.

    // Add a column to a binding of type table by passing a TableData object.
    function addColumns() {
        const myTable = new Office.TableData();
        myTable.headers = [["Cities"]];
        myTable.rows = [["Berlin"], ["Roma"], ["Tokyo"]];

        Office.context.document.bindings.getByIdAsync("myTable", function (result) {
            result.value.addColumnsAsync(myTable);
        });
    }

    // The following example adds a single column with three rows to a bound table with the id myTable
    // by passing an array of arrays ("matrix") as the data argument of the addColumnsAsync method.
    // To succeed, the table being updated must have three rows.

    // Add a column to a binding of type table by passing an array of arrays.
    function addColumns() {
        const myTable = [["Berlin"], ["Roma"], ["Tokyo"]];

        Office.context.document.bindings.getByIdAsync("myTable", function (result) {
            result.value.addColumnsAsync(myTable);
        });
    }
Office.TableBinding#addRowsAsync:member(1):
  - |-
    function addRowsToTable() {
        Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
            const binding = asyncResult.value;
            binding.addRowsAsync([["6", "k"], ["7", "j"]]);
        });
    }
Office.TableBinding#clearFormatsAsync:member(1):
  - |-
    // The following example shows how to clear the formatting of the bound table with an ID of "myBinding":
    Office.select("bindings#myBinding").clearFormatsAsync();
Office.TableBinding#columnCount:member:
  - |-
    function showBindingColumnCount() {
        Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
            write("Column: " + asyncResult.value.columnCount);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.TableBinding#deleteAllDataValuesAsync:member(1):
  - |-
    function deleteAllRowsFromTable() {
        Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
            const binding = asyncResult.value;
            binding.deleteAllDataValuesAsync();
        });
    }
Office.TableBinding#hasHeaders:member:
  - |-
    function showBindingHasHeaders() {
        Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
            write("Binding has headers: " + asyncResult.value.hasHeaders);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.TableBinding#rowCount:member:
  - |-
    function showBindingRowCount() {
        Office.context.document.bindings.getByIdAsync("myBinding", function (asyncResult) {
            write("Rows: " + asyncResult.value.rowCount);
        });
    }
    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.TableBinding#setTableOptionsAsync:member(1):
  - |-
    // The following example shows how to:
    // 1. Create an object literal that specifies the table formatting options to update on the bound table.
    // 2. Call setTableOptions on a previously bound table (with an id of myBinding) passing the object
    //    with formatting setting as the tableOptions parameter.
    function updateTableFormatting(){
        const tableOptions = {bandedRows: true, filterButton: false, style: "TableStyleMedium3"}; 

        Office.select("bindings#myBinding").setTableOptionsAsync(tableOptions, function(asyncResult){});
    }
Office.TableBinding#setFormatsAsync:member(1):
  - |-
    // Specifying a single target
    // The following example shows a cellFormat value that sets the font color of the header row to red.
    Office.select("bindings#myBinding").setFormatsAsync(
        [{cells: Office.Table.Headers, format: {fontColor: "red"}}], 
        function (asyncResult){});
    
    // Specifying multiple targets
    // The setFormatsAsync method can support formatting multiple targets within the bound table in a 
    // single function call. To do that, you pass a list of objects in the cellFormat array 
    // for each target that you want to format.
    // For example, the following line of code will set the font color of the first row yellow, 
    // and the fourth cell in the third row to have a white border and bold text.
    Office.select("bindings#myBinding").setFormatsAsync(
        [{cells: {row: 1}, format: {fontColor: "yellow"}}, 
            {cells: {row: 3, column: 4}, format: {borderColor: "white", fontStyle: "bold"}}], 
        function (asyncResult){});
    
    // Additional remarks for Excel Online
    // The number of formatting groups passed to the cellFormat parameter can't exceed 100. 
    // A single formatting group consists of a set of formatting applied to a specified range of cells. 
    // For example, the following call passes two formatting groups to cellFormat.
    Office.select("bindings#myBinding").setFormatsAsync(
        [{cells: {row: 1}, format: {fontColor: "yellow"}}, 
            {cells: {row: 3, column: 4}, format: {borderColor: "white", fontStyle: "bold"}}], 
        function (asyncResult){});
Office.TableData#headers:member:
  - |-
    // The following example creates a single-column table with a header and three rows.
    function createTableData() {
        const tableData = new Office.TableData();
        tableData.headers = [['header1']];
        tableData.rows = [['row1'], ['row2'], ['row3']];
        return tableData;
    }
Office.TableData#rows:member:
  - |-
    // The following example creates a single-column table with a header and three rows.
    function createTableData() {
        const tableData = new Office.TableData();
        tableData.headers = [['header1']];
        tableData.rows = [['row1'], ['row2'], ['row3']];
        return tableData;
    }
Office.ThemeId:enum:
  - |-
    // The following example sets the color of a heading based on the current Office theme.
    function setHeadingColor() {
        // Identify the current Office theme in use.
        const currentOfficeTheme = Office.context.officeTheme.themeId;

        if (currentOfficeTheme === Office.ThemeId.Colorful) {
            $("h1").css("color", "#1849ff");
        }

        ...
    }
Office.UI:interface:
  - |-
    // Get an Office.UI object and use it to open a dialog with a specified size. 
    const uiContext = Office.context.ui;
    uiContext.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 });
Office.UI#addHandlerAsync:member(2):
  - |-
    // The following example shows how to add an event handler for the DialogParentMessageReceived event.
    Office.onReady(() => {
        Office.context.ui.addHandlerAsync(
            Office.EventType.DialogParentMessageReceived,
            onMessageFromParent,
            onRegisterMessageComplete
        );
    });

    function onMessageFromParent(arg) {
        const messageFromParent = JSON.parse(arg.message);
        document.querySelector('h1').textContent = messageFromParent.name;
    }

    function onRegisterMessageComplete(asyncResult) {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.log(asyncResult.error.message);
            return;
        }
    }
Office.UI#closeContainer:member(1):
  - |-
    // The following example shows how to open a browser window to a download page and then close the add-in task pane.
    Office.context.ui.openBrowserWindow("https://www.contoso.com/download");
    Office.context.ui.closeContainer();
Office.UI#displayDialogAsync:member(1):
  - |-
    // The following example shows how to open a dialog with a specified size. It also shows
    // how to register a function to handle the message when Office.UI.messageParent() is called
    // in the dialog. The implementation of the processMessage() function is omitted.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult) => {
            const dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );

    // The following example does the same thing in TypeScript.

    Office.context.ui.displayDialogAsync("https://www.contoso.com/myDialog.html", { height: 30, width: 20 },
        (asyncResult: Office.AsyncResult) => {
            const dialog: Office.Dialog = asyncResult.value;
            dialog.addEventHandler(Office.EventType.DialogMessageReceived, (arg: string) => {
                dialog.close();
                processMessage(arg);
            });
        }
    );
Office.UI#messageParent:member(1):
  - |-
    // The following example shows how to send a JSON string to the parent. The profile object
    // is returned from some website when a user signs into it.
    function userProfileSignedIn(profile) {
        const profileMessage = {
            "name": profile.name,
            "email": profile.email,
        };
        Office.context.ui.messageParent(JSON.stringify(profileMessage));
    }
Office.UI#openBrowserWindow:member(1):
  - |-
    // The following example shows how to open a browser window to a download page and then close the add-in task pane.
    Office.context.ui.openBrowserWindow("https://www.contoso.com/download");
    Office.context.ui.closeContainer();
Office.Urls#javascriptRuntimeUrl:member:
  - |-
    // Get the value of the first parameter of the JavaScript runtime URL.
    // For example, if the URL is https://wwww.contoso.com/training?key1=value1&key2=value2,
    // the following function logs "First parameter value: value1" to the console.
    const url = Office.context.urls.javascriptRuntimeUrl;
    const regex = /=([^&]+)/;
    console.log(`First parameter value: ${url.match(regex)[1]}`);
Office.useShortNamespace:function(1):
  - |-
    function startUsingShortNamespace() {
        if (typeof Office === 'undefined') {
            Microsoft.Office.WebExtension.useShortNamespace(true);
        }
        else {
            Office.useShortNamespace(true);
        }
        write('Office alias is now ' + typeof Office);
    }

    function stopUsingShortNamespace() {
        if (typeof Office === 'undefined') {
            Microsoft.Office.WebExtension.useShortNamespace(false);
        }
        else {
            Office.useShortNamespace(false);
        }
        write('Office alias is now ' + typeof Office);
    }

    // Function that writes to a div with id='message' on the page.
    function write(message){
        document.getElementById('message').innerText += message; 
    }
Office.VisibilityMode:enum:
  - |-
    Office.onReady(() => {
        Office.addin.onVisibilityModeChanged((args) => {
            if (args.visibilityMode === Office.VisibilityMode.taskpane) {
                // Do something when the task pane is visible.
            }
        });

        // Other startup tasks.
    });
OfficeExtension.ClientObject#isNullObject:member:
  - |-
    // This Word snippet sets the hyperlink URL of a selected image. 
    await Word.run(async (context) => {
        const selection = context.document.getSelection();
        const firstImage = selection.inlinePictures.getFirstOrNullObject();
        await context.sync();

        // Check if an image was selected before changing its property.
        if (!firstImage.isNullObject) {
            firstImage.hyperlink = "https://www.microsoft.com";
        } else {
            console.log("No image selected");
        }

        await context.sync();
    });
OfficeExtension.ClientObject#context:member:
  - |-
    // *.run methods automatically create an OfficeExtension.ClientRequestContext
    // object to work with the Office file.
    await Excel.run(async (context: Excel.RequestContext) => {
      // `context` is the Excel-specific extension of OfficeExtension.ClientRequestContext.
      
      const workbook = context.workbook;
      // Interact with the Excel workbook...
    });
OfficeExtension.ClientResult:class:
  - |-
    await Excel.run(async (context) => {
        // Get the count of worksheets in the Excel workbook.
        const workbook = context.workbook;
        let countResult: OfficeExtension.ClientResult<number> = workbook.worksheets.getCount();

        // Sync to populate the countResult object.
        await context.sync();

        // Log the count using the value parameter.
        console.log(countResult.value);
    });
OfficeExtension.Error#traceMessages:member:
  - |-
    // The following example shows how you can instrument a batch of commands
    // to determine where an error occurred. The first batch successfully
    // inserts the first two paragraphs into the document and cause no errors.
    // The second batch successfully inserts the third and fourth paragraphs
    // but fails in the call to insert the fifth paragraph. All other commands
    // after the failed command in the batch are not executed, including the
    // command that adds the fifth trace message. In this case, the error
    // occurred after the fourth paragraph was inserted, and before adding the
    // fifth trace message.

    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {

        // Create a proxy object for the document body.
        const body = context.document.body;

        // Queue a command to insert the paragraph at the end of the document body.
        // Start a batch of commands.
        body.insertParagraph('1st paragraph', Word.InsertLocation.end);
        // Queue a command for instrumenting this part of the batch.
        context.trace('1st paragraph successful');

        body.insertParagraph('2nd paragraph', Word.InsertLocation.end);
        context.trace('2nd paragraph successful');

        // Synchronize the document state by executing the queued-up commands,
        // and return a promise to indicate task completion.
        await context.sync();

        // Queue a command to insert the paragraph at the end of the document body.
        // Start a new batch of commands.
        body.insertParagraph('3rd paragraph', Word.InsertLocation.end);
        context.trace('3rd paragraph successful');

        body.insertParagraph('4th paragraph', Word.InsertLocation.end);
        context.trace('4th paragraph successful');

        // This command will cause an error. The trace messages in the queue up to
        // this point will be available via Error.traceMessages.
        body.insertParagraph(0, '5th paragraph', Word.InsertLocation.end);
        // Queue a command for instrumenting this part of the batch.
        // This trace message will not be set on Error.traceMessages.
        context.trace('5th paragraph successful');
        await context.sync();
    }).catch(function (error) {
        if (error instanceof OfficeExtension.Error) {
            console.log('Trace messages: ' + error.traceMessages);
        }
    });

    // Output: "Trace messages: 3rd paragraph successful,4th paragraph successful"
OfficeExtension.LoadOption:interface:
  - |-
    // This example shows how to get the paragraphs in the Word document
    // along with their text and font size properties.

    // Run a batch operation against the Word object model.
    Word.run(function (context) {
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;

        // Queue a command to load the text and font properties.
        // It is best practice to always specify the property set.
        // Otherwise, all properties are returned on the object.
        context.load(paragraphs, 'text, font/size');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        return context.sync().then(function () {
            // Insert code that works with the paragraphs loaded by context.load().
        })
    })
    .catch(function (error) {
        console.log('Error: ' + JSON.stringify(error));
        if (error instanceof OfficeExtension.Error) {
            console.log('Debug info: ' + JSON.stringify(error.debugInfo));
        }
    });
OfficeExtension.LoadOption#top:member:
  - |-
    // This OneNote example shows how to get the page title and indentation level
    // of the top five pages in the current section.
    OneNote.run(function (context) {
        // Get the pages in the current section.
        const pages = context.application.getActiveSection().pages;

        // Queue a command to load the pages.           
        pages.load({ "select":"title,pageLevel", "top":5, "skip":0 });
        return context.sync()
            .then(function() {
                // Iterate through the collection of pages.    
                $.each(pages.items, function(index, page) {
                    // Show some properties.
                    console.log("Page title: " + page.title);
                    console.log("Indentation level: " + page.pageLevel);
                });
            }).catch(function(error) {
                console.log("Error: " + error);
                if (error instanceof OfficeExtension.Error) {
                    console.log("Debug info: " + JSON.stringify(error.debugInfo));
                }
            })
        });

OfficeRuntime.Auth:interface:
  - |-
    // Get the auth context object and use it to get an
    // access token.
    const authContext = OfficeRuntime.context.auth;
    const accessToken = authContext.getAccessTokenAsync();
OfficeRuntime.Auth#getAccessToken:member(1):
  - |-
    async function getUserData() {
      try {
          let userTokenEncoded = await OfficeRuntime.auth.getAccessToken();
          let userToken = jwt_decode(userTokenEncoded); // Using the https://www.npmjs.com/package/jwt-decode library.
          console.log(userToken.name); // user name
          console.log(userToken.preferred_username); // email
          console.log(userToken.oid); // user id     
      }
      catch (exception) {
          if (exception.code === 13003) {
              // SSO is not supported for domain user accounts, only
              // Microsoft 365 Education or work account, or a Microsoft account.
          } else {
              // Handle error
          }
      }
    }
OneNote.Application#getActiveNotebook:member(1):
  - |-
    await OneNote.run(async (context) => {
            
        // Get the active notebook.
        const notebook = context.application.getActiveNotebook();
                
        // Queue a command to load the notebook.
        // For best performance, request specific properties.
        notebook.load('id,name');
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                        
        // Show some properties.
        console.log("Notebook name: " + notebook.name);
        console.log("Notebook ID: " + notebook.id);
                
    });
OneNote.Application#getActiveNotebookOrNull:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the active notebook.
        const notebook = context.application.getActiveNotebookOrNull();
    
        // Queue a command to load the notebook.
        // For best performance, request specific properties.
        notebook.load('id,name');
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Check if active notebook is set.
        if (!notebook.isNullObject) {
            console.log("Notebook name: " + notebook.name);
            console.log("Notebook ID: " + notebook.id);
        }
    });
OneNote.Application#getActiveOutline:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // get active outline.
        const outline = context.application.getActiveOutline();
    
        // Queue a command to load the id of the outline.
        outline.load('id');
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Show some properties.
        console.log("outline id: " + outline.id);
    });
OneNote.Application#getActiveOutlineOrNull:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // get active outline.
        const outline = context.application.getActiveOutlineOrNull();
    
        // Queue a command to load the id of the outline.
        outline.load('id');
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        if (!outline.isNullObject) {
            console.log("outline id: " + outline.id);
        }
    });
OneNote.Application#getActivePage:member(1):
  - |-
    await OneNote.run(async (context) => {
            
        // Get the active page.
        const page = context.application.getActivePage();
                
        // Queue a command to load the page.
        // For best performance, request specific properties.
        page.load('id,title');
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                        
        // Show some properties.
        console.log("Page title: " + page.title);
        console.log("Page ID: " + page.id);
    });
OneNote.Application#getActivePageOrNull:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the active page.
        const page = context.application.getActivePageOrNull();
    
        // Queue a command to load the page.
        // For best performance, request specific properties.
        page.load('id,title');
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                
        if (!page.isNullObject) {
            // Show some properties.
            console.log("Page title: " + page.title);
            console.log("Page ID: " + page.id);
        }
    });
OneNote.Application#getActiveSection:member(1):
  - |-
    await OneNote.run(async (context) => {
            
        // Get the active section.
        const section = context.application.getActiveSection();
                
        // Queue a command to load the section.
        // For best performance, request specific properties.
        section.load('id,name');
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                        
        // Show some properties.
        console.log("Section name: " + section.name);
        console.log("Section ID: " + section.id);
    });
OneNote.Application#getActiveSectionOrNull:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the active section.
        const section = context.application.getActiveSectionOrNull();
    
        // Queue a command to load the section.
        // For best performance, request specific properties.
        section.load('id,name');
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        if (!section.isNullObject) {
            // Show some properties.
            console.log("Section name: " + section.name);
            console.log("Section ID: " + section.id);
        }
    });
OneNote.Application#navigateToPage:member(1):
  - |-
    await OneNote.run(async (context) => {
            
        // Get the pages in the current section.
        const pages = context.application.getActiveSection().pages;
                
        // Queue a command to load the pages.
        // For best performance, request specific properties.
        pages.load('id');
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync()
                        
        // This example loads the first page in the section.
        const page = pages.items[0];
                    
        // Open the page in the application.
        context.application.navigateToPage(page);
                
        // Run the queued command.
        await context.sync();
    });
OneNote.Application#navigateToPageWithClientUrl:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the pages in the current section.
        const pages = context.application.getActiveSection().pages;
    
        // Queue a command to load the pages.
        // For best performance, request specific properties.
        pages.load('clientUrl');
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync()
    
        // This example loads the first page in the section.
        const page = pages.items[0];

        // Open the page in the application.
        context.application.navigateToPageWithClientUrl(page.clientUrl);

        // Run the queued command.
        await context.sync();
    });
OneNote.FloatingInk#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Gets the active page.
        const page = context.application.getActivePage();
        const contents = page.contents;
        
        // Load page contents and their types.
        page.load('contents/type');
        await context.sync();
            
        // Load every ink content.
        $.each(contents.items, function(i, content) {
            if (content.type == "Ink")
            {
                content.load('ink/id');
            }                            
        });
        await context.sync();
            
        // Log ID of every ink content.
        $.each(contents.items, function(i, content) {
            if (content.type == "Ink")
            {
                console.log(content.ink.id);
            }                            
        });           
    });
OneNote.Image#getBase64Image:member(1):
  - |-
    let image = null;
    let imageString;
    
    await OneNote.run(async (context) => {
        // Get the current outline.
        const outline = context.application.getActiveOutline();
        
        // Queue a command to load paragraphs and their types.
        outline.load("paragraphs/type")
        await context.sync();
        for (let i=0; i < outline.paragraphs.items.length; i++) {
            const paragraph = outline.paragraphs.items[i];
            if (paragraph.type == "Image")
            {
                image = paragraph.image;
            }
        }

        if (image != null) {
            imageString = image.getBase64Image();
            await context.sync();
        }

        console.log(imageString);
    });
OneNote.Image#load:member(2):
  - |-
    await OneNote.run(async (context) => {
        // Get the current outline.
        const outline = context.application.getActiveOutline();
        let image = null;
        
        // Queue a command to load paragraphs and their types.
        outline.load("paragraphs/type")
        await context.sync();

        for (let i=0; i < outline.paragraphs.items.length; i++) {
            const paragraph = outline.paragraphs.items[i];
            if (paragraph.type == "Image")
            {
                image = paragraph.image;
            }
        }

        if (image != null) {
            // Load all properties and relationships.
            image.load(["id", "width", "height", "description", "hyperlink"]);
            await context.sync();
        }

        if (image != null) {                   
            console.log("image " + image.id + " width is " + image.width + " height is " + image.height);
            console.log("description: " + image.description);                   
            console.log("hyperlink: " + image.hyperlink);
        }
    });
OneNote.Image#ocrData:member:
  - |-
    let image = null;
    
    await OneNote.run(async (context) => {
        // Get the current outline.
        const outline = context.application.getActiveOutline();
    
        // Queue a command to load paragraphs and their types.
        outline.load("paragraphs")
        await context.sync();

        for (let i=0; i < outline.paragraphs.items.length; i++) {
            const paragraph = outline.paragraphs.items[i];
            if (paragraph.type == "Image")
            {
                image = paragraph.image;
            }
        }
        if (image != null) {
            image.load("ocrData");
        }

        await context.sync();
                
        // Log ocrText and ocrLanguageId.
        console.log(image.ocrData.ocrText);
        console.log(image.ocrData.ocrLanguageId);
    });
OneNote.Notebook#addSection:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Gets the active notebook.
        const notebook = context.application.getActiveNotebook();
    
        // Queue a command to add a new section.
        const section = notebook.addSection("Sample section");
        
        // Queue a command to load the new section. This example reads the name property later.
        section.load("name");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        console.log("New section name is " + section.name);
    });
OneNote.Notebook#addSectionGroup:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Gets the active notebook.
        const notebook = context.application.getActiveNotebook();
    
        // Queue a command to add a new section group.
        const sectionGroup = notebook.addSectionGroup("Sample section group");
    
        // Queue a command to load the new section group.
        sectionGroup.load();
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        console.log("New section group name is " + sectionGroup.name);
    });
OneNote.Notebook#getRestApiId:member(1):
  - |-
    await OneNote.run(async (context) => {
        // Get the current notebook.
        const notebook = context.application.getActiveNotebook();
        const restApiId = notebook.getRestApiId();
    
        await context.sync();
        console.log("The REST API ID is " + restApiId.value);
        // Note that the REST API ID isn't all you need to interact with the OneNote REST API.
        // This is only required for SharePoint notebooks. baseUrl will be null for OneDrive notebooks.
        // For SharePoint notebooks, the notebook baseUrl should be used to talk to the OneNote REST API
        // according to the OneNote Development Blog.
        // https://learn.microsoft.com/archive/blogs/onenotedev/and-sharepoint-makes-three
    });
OneNote.Notebook#load:member(2):
  - |-
    await OneNote.run(async (context) => {
            
        // Get the current notebook.
        const notebook = context.application.getActiveNotebook();
                
        // Queue a command to load the notebook.
        // For best performance, request specific properties.
        notebook.load('baseUrl');
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        console.log("Base url: " + notebook.baseUrl);
        // This is only required for SharePoint notebooks, and will be null for OneDrive notebooks.
        // This baseUrl should be used to talk to OneNote REST APIs according to the OneNote Development Blog.
        // https://learn.microsoft.com/archive/blogs/onenotedev/and-sharepoint-makes-three
    });
OneNote.NotebookCollection#getByName:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the notebooks that are open in the application instance and have the specified name.
        const notebooks = context.application.notebooks.getByName("Homework");
    
        // Queue a command to load the notebooks.
        // For best performance, request specific properties.
        notebooks.load("id,name");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Iterate through the collection or access items individually by index.
        // For example: notebooks.items[0]
        if (notebooks.items.length > 0) {
            console.log("Notebook name: " + notebooks.items[0].name);
            console.log("Notebook ID: " + notebooks.items[0].id);
        }
    });
OneNote.NotebookCollection#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the notebooks that are open in the application instance and have the specified name.
        const notebooks = context.application.notebooks.getByName("Homework");
    
        // Queue a command to load the notebooks.
        // For best performance, request specific properties.
        notebooks.load("id");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Iterate through the collection or access items individually by index.
        // For example: notebooks.items[0]
        $.each(notebooks.items, function(index, notebook) {
            notebook.addSection("Biology");
            notebook.addSection("Spanish");
            notebook.addSection("Computer Science");
        });
        
        await context.sync();
    });
OneNote.Outline#appendHtml:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Gets the active page.
        const activePage = context.application.getActivePage();
    
        // Get pageContents of the activePage.
        const pageContents = activePage.contents;
    
        // Queue a command to load the pageContents to access its data.
        context.load(pageContents);
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        if (pageContents.items.length != 0 && pageContents.items[0].type == "Outline")
        {
            // First item is an outline.
            const outline = pageContents.items[0].outline;

            // Queue a command to append a paragraph to the outline.
            outline.appendHtml("<p>new paragraph</p>");

            // Run the queued commands.
            await context.sync();
        }
    });
OneNote.Outline#appendTable:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Gets the active page.
        const activePage = context.application.getActivePage();
    
        // Get pageContents of the activePage.
        const pageContents = activePage.contents;
    
        // Queue a command to load the pageContents to access its data.
        context.load(pageContents);
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        if (pageContents.items.length != 0 && pageContents.items[0].type == "Outline") {
            // First item is an outline.
            const outline = pageContents.items[0].outline;

            // Queue a command to append a paragraph to the outline.
            outline.appendTable(2, 2, [["1", "2"],["3", "4"]]);

            // Run the queued commands.
            await context.sync();
        }
    });
OneNote.Page#addOutline:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Gets the active page.
        const page = context.application.getActivePage();
    
        // Queue a command to add an outline with given html.
        const outline = page.addOutline(200, 200,
    "<p>Images and a table below:</p> \
     <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\"> \
     <img src=\"http://imagenes.es.sftcdn.net/es/scrn/6653000/6653659/microsoft-onenote-2013-01-535x535.png\"> \
     <table> \
       <tr> \
         <td>Jill</td> \
         <td>Smith</td> \
         <td>50</td> \
       </tr> \
       <tr> \
         <td>Eve</td> \
         <td>Jackson</td> \
         <td>94</td> \
       </tr> \
     </table>"     
            );
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    });
OneNote.Page#copyToSection:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        
        // Gets the active notebook.
        const notebook = app.getActiveNotebook();
        
        // Gets the active page.
        const page = app.getActivePage();
        
        // Queue a command to load sections under the notebook.
        notebook.load('sections');
        
        let newPage;
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        const section = notebook.sections.items[0];
        
        // Copy page to the section.
        newPage = page.copyToSection(section);
        newPage.load('id');
        await context.sync();
        
        console.log(newPage.id);
    });
OneNote.Page#getRestApiId:member(1):
  - |-
    await OneNote.run(async (context) => {
        // Get the current page.
        const page = context.application.getActivePage();
        const restApiId = page.getRestApiId();
    
        await context.sync();
        console.log("The REST API ID is " + restApiId.value);
        // Note that the REST API ID isn't all you need to interact with the OneNote REST API.
        // This is only required for SharePoint notebooks. baseUrl will be null for OneDrive notebooks.
        // For SharePoint notebooks, the notebook baseUrl should be used to talk to the OneNote REST API
        // according to the OneNote Development Blog.
        // https://learn.microsoft.com/archive/blogs/onenotedev/and-sharepoint-makes-three
    });
OneNote.Page#insertPageAsSibling:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Gets the active page.
        const activePage = context.application.getActivePage();
    
        // Queue a command to add a new page after the active page.
        const newPage = activePage.insertPageAsSibling("After", "Next Page");
    
        // Queue a command to load the newPage to access its data.
        context.load(newPage);
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        console.log("page is created with title: " + newPage.title);
    });
OneNote.Page#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Gets the active page.
        const activePage = context.application.getActivePage();
    
        // Queue a command to add a new page after the active page.
        const pageContents = activePage.contents;
    
        // Queue a command to load the pageContents to access its data.
        context.load(pageContents);
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync()
        for(let i=0; i < pageContents.items.length; i++) {
            const pageContent = pageContents.items[i];
            if (pageContent.type == "Outline") {
                console.log("Found an outline");
            } else if (pageContent.type == "Image") {
                console.log("Found an image");
            } else if (pageContent.type == "Other") {
                console.log("Found a type not supported yet.");
            }
        }
    });
OneNote.PageCollection#getByTitle:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get all the pages in the current section.
        const allPages = context.application.getActiveSection().pages;
    
        // Queue a command to load the pages.
        // For best performance, request specific properties.
        allPages.load("id"); 
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Get the sections with the specified name.
        const todoPages = allPages.getByTitle("Todo list");

        // Queue a command to load the section.
        // For best performance, request specific properties.
        todoPages.load("id,title"); 

        await context.sync()

        // Iterate through the collection or access items individually by index.
        if (todoPages.items.length > 0) {
            console.log("Page title: " + todoPages.items[0].title);
            console.log("Page ID: " + todoPages.items[0].id);
        }
    });
OneNote.PageCollection#load:member(2):
  - |-
    await OneNote.run(async (context) => {
        
        // Get the pages in the current section.
        const pages = context.application.getActiveSection().pages;
        
        // Queue a command to load the id and title for each page.
        pages.load('id,title');
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                
        // Display the properties.
        $.each(pages.items, function(index, page) {
            console.log(page.title);
            console.log(page.id);
        });
    });
OneNote.PageContent#delete:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        const page = context.application.getActivePage();
        const pageContents = page.contents;
    
        const firstPageContent = pageContents.getItemAt(0);
        firstPageContent.load('type');
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        if (firstPageContent.isNullObject === false) {
            firstPageContent.delete();
            await context.sync();
        }
    });
OneNote.PageContentCollection#getItemAt:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        const page = context.application.getActivePage();
        const pageContents = page.contents;
        const firstPageContent = pageContents.getItemAt(0);
        firstPageContent.load('type');
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        console.log("The first page content item is of type: " + firstPageContent.type);
        await context.sync();
    });
OneNote.PageContentCollection#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
    
        // Queue a command to load the type of each pageContent.
        pageContents.load("type");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        $.each(pageContents.items, function(index, pageContent) {
            console.log("PageContent type: " + pageContent.type);
        });
    });
OneNote.Paragraph#delete:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
    
        // Get the first PageContent on the page assuming its an outline, get the outline's paragraphs.
        const pageContent = pageContents.getItemAt(0);
        
        const paragraphs = pageContent.outline.paragraphs;
        
        const firstParagraph = paragraphs.getItemAt(0);
        
        // Queue a command to load the id and type of the first paragraph.
        firstParagraph.load("id,type");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                
        // Queue a command to delete the first paragraph.
        firstParagraph.delete();
        
        // Run the command to delete it.
        await context.sync();
    });
OneNote.Paragraph#insertHtmlAsSibling:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
    
        // Get the first PageContent on the page.
        // Assuming its an outline, get the outline's paragraphs.
        const pageContent = pageContents.getItemAt(0);
        const paragraphs = pageContent.outline.paragraphs;
        const firstParagraph = paragraphs.getItemAt(0);
    
        // Queue a command to load the id and type of the first paragraph.
        firstParagraph.load("id,type");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Queue commands to insert before and after the first paragraph.
        firstParagraph.insertHtmlAsSibling("Before", "<p>ContentBeforeFirstParagraph</p>");
        firstParagraph.insertHtmlAsSibling("After", "<p>ContentAfterFirstParagraph</p>");
        
        // Run the command to run inserts.
        await context.sync();
    });
OneNote.Paragraph#insertImageAsSibling:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
    
        // Get the first PageContent on the page.
        // Assuming its an outline, get the outline's paragraphs.
        const pageContent = pageContents.getItemAt(0);
        const paragraphs = pageContent.outline.paragraphs;
        const firstParagraph = paragraphs.getItemAt(0);
    
        // Queue a command to load the id and type of the first paragraph.
        firstParagraph.load("id,type");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Queue commands to insert before and after the first paragraph.
        firstParagraph.insertImageAsSibling("Before", "R0lGODlhDwAPAKECAAAAzMzM/////wAAACwAAAAADwAPAAACIISPeQHsrZ5ModrLlN48CXF8m2iQ3YmmKqVlRtW4MLwWACH+H09wdGltaXplZCBieSBVbGVhZCBTbWFydFNhdmVyIQAAOw==");
        firstParagraph.insertImageAsSibling("After", "R0lGODlhDwAPAKECAAAAzMzM/////wAAACwAAAAADwAPAAACIISPeQHsrZ5ModrLlN48CXF8m2iQ3YmmKqVlRtW4MLwWACH+H09wdGltaXplZCBieSBVbGVhZCBTbWFydFNhdmVyIQAAOw==");
        
        // Run the command to insert images.
        await context.sync();
    });
OneNote.Paragraph#insertRichTextAsSibling:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
    
        // Get the first PageContent on the page assuming its an outline, get the outline's paragraphs.
        const pageContent = pageContents.getItemAt(0);
        const paragraphs = pageContent.outline.paragraphs;
        const firstParagraph = paragraphs.getItemAt(0);
    
        // Queue a command to load the id and type of the first paragraph.
        firstParagraph.load("id,type");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Queue commands to insert before and after the first paragraph.
        firstParagraph.insertRichTextAsSibling("Before", "Text Appears Before Paragraph");
        firstParagraph.insertRichTextAsSibling("After", "Text Appears After Paragraph");
        
        // Run the command to insert text contents.
        await context.sync();
    });
OneNote.Paragraph#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
        
        // Queue a command to load the outline property of each pageContent.
        pageContents.load("outline");
            
        // Get the first PageContent on the page, and then get its Outline.
        const pageContent = pageContents._GetItem(0);
        const paragraphs = pageContent.outline.paragraphs;
                
        // Queue a command to load the id and type of each paragraph.
        paragraphs.load("id,type");
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        // Write the text.
        $.each(paragraphs.items, function(index, paragraph) {
            console.log("Paragraph type: " + paragraph.type);
            console.log("Paragraph ID: " + paragraph.id);
        });
    });
OneNote.ParagraphCollection#getItemAt:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
    
        // Get the first PageContent on the page, and then get its Outline's first paragraph.
        const pageContent = pageContents.getItemAt(0);
        const paragraphs = pageContent.outline.paragraphs;
    
        const firstParagraph = paragraphs.getItemAt(0);
    
        // Queue a command to load the id and type properties of this paragraph.
        firstParagraph.load("id,type");
    
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        // Write text from paragraph to console.
        console.log(
            "First Paragraph found with id : " + 
            firstParagraph.id + " and type " + firstParagraph.type);
    });
OneNote.ParagraphCollection#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
    
        // Get the first PageContent on the page, and then get its Outline's first paragraph.
        const pageContent = pageContents.getItem(0);
        const paragraphs = pageContent.outline.paragraphs;
        
        // Queue a command to load the id and type of each paragraph.
        paragraphs.load("id,type");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        const firstParagraph = paragraphs.items[0];
        // Write text from first paragraph to console.
        console.log(
            "First Paragraph found with id : " + 
            firstParagraph.id + " and type " + firstParagraph.type);
    });
OneNote.RichText#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the collection of pageContent items from the page.
        const pageContents = context.application.getActivePage().contents;
    
        // Get the first PageContent on the page, and then get its outline's paragraphs.
        const outlinePageContents = pageContents.getItem(0);
        let paragraphs = outlinePageContents.outline.paragraphs;
        const richTextParagraphs = paragraphs.items;
        // Queue a command to load the id and type of each page content in the outline.
        pageContents.load("id,type");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        // Load all page contents of type Outline.
        $.each(pageContents.items, function(index, pageContent) {
            if(pageContent.type == 'Outline')
            {
                pageContent.load('outline,outline/paragraphs,outline/paragraphs/type');
                outlinePageContents.push(pageContent);
            }
        });
        await context.sync();

        // Load all rich text paragraphs across outlines.
        $.each(outlinePageContents, function(index, outlinePageContent) {
            const outline = outlinePageContent.outline;
            paragraphs = paragraphs.concat(outline.paragraphs.items);
        });
        $.each(paragraphs, function(index, paragraph) {
            if(paragraph.type == 'RichText')
            {
                richTextParagraphs.push(paragraph);
                paragraph.load("id,richText/text");
            }
        });
        await context.sync();

        // Display all rich text paragraphs to the console.
        $.each(richTextParagraphs, function(index, richTextParagraph) {
            const richText = richTextParagraph.richText;
            console.log(
                "Paragraph found with richtext content : " + 
                richText.text + " and richtext id : " + richText.id);
        });
        await context.sync();
    });
OneNote.Section#addPage:member(1):
  - |-
    await OneNote.run(async (context) => {
                
        // Queue a command to add a page to the current section.
        const page = context.application.getActiveSection().addPage("Wish list");
                
        // Queue a command to load the id and title of the new page.
        // This example loads the new page so it can read its properties later.
        page.load('id,title');
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                 
        // Display the properties.
        console.log("Page name: " + page.title);
        console.log("Page ID: " + page.id);
    });
OneNote.Section#copyToNotebook:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        
        // Gets the active Notebook.
        const notebook = app.getActiveNotebook();
        
        // Gets the active Section.
        const section = app.getActiveSection();
        
        let newSection;
        
        await context.sync();

        newSection = section.copyToNotebook(notebook);
        newSection.load('id');
        await context.sync();
        
        console.log(newSection.id);
    });
OneNote.Section#copyToSectionGroup:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        
        // Gets the active Notebook.
        const notebook = app.getActiveNotebook();
        
        // Gets the active Section.
        const section = app.getActiveSection();
        
        let newSection;
        
        await context.sync();

        const firstSectionGroup = notebook.sectionGroups.items[0];
        newSection = section.copyToSectionGroup(firstSectionGroup);
        newSection.load('id');
        await context.sync();
        
        console.log(newSection.id);
    });
OneNote.Section#insertSectionAsSibling:member(2):
  - |-
    await OneNote.run(async (context) => {
                
        // Queue a command to insert a section after the current section.
        const section = context.application.getActiveSection().insertSectionAsSibling("After", "New section");
                
        // Queue a command to load the id and name of the new section.
        // This example loads the new section so it can read its properties later.
        section.load('id,name');
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                 
        // Display the properties.
        console.log("Section name: " + section.name);
        console.log("Section ID: " + section.id);
    });
OneNote.Section#getRestApiId:member(1):
  - |-
    await OneNote.run(async (context) => {
        // Get the current section.
        const section = context.application.getActiveSection();
        const restApiId = section.getRestApiId();
    
        await context.sync();
        console.log("The REST API ID is " + restApiId.value);
        // Note that the REST API ID isn't all you need to interact with the OneNote REST API.
        // This is only required for SharePoint notebooks. baseUrl will be null for OneDrive notebooks.
        // For SharePoint notebooks, the notebook baseUrl should be used to talk to the 
        // OneNote REST API according to the OneNote Development Blog.
        // https://learn.microsoft.com/archive/blogs/onenotedev/and-sharepoint-makes-three
    });
OneNote.Section#load:member(2):
  - |-
    await OneNote.run(async (context) => {
            
        // Get the current section.
        const section = context.application.getActiveSection();
                
        // Queue a command to load the section.
        // For best performance, request specific properties.
        section.load("id");
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        console.log("Section ID: " + section.id);
    });
OneNote.SectionCollection#getByName:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the sections in the current notebook.
        const sections = context.application.getActiveNotebook().sections;
    
        // Queue a command to load the sections.
        // For best performance, request specific properties.
        sections.load("id"); 
        
        // Get the sections with the specified name.
        const groceriesSections = sections.getByName("Groceries");
        
        // Queue a command to load the sections with the specified name.
        groceriesSections.load("id,name");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Iterate through the collection or access items individually by index.
        if (groceriesSections.items.length > 0) {
            console.log("Section name: " + groceriesSections.items[0].name);
            console.log("Section ID: " + groceriesSections.items[0].id);
        }
    });
OneNote.SectionCollection#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the sections in the current notebook.
        const sections = context.application.getActiveNotebook().sections;
    
        // Queue a command to load the sections.
        // For best performance, request specific properties.
        sections.load("name"); 
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                
        // Iterate through the collection or access items individually by index, for example: sections.items[0]
        $.each(sections.items, function(index, section) {
            if (section.name === "Homework") {
                section.addPage("Biology");
                section.addPage("Spanish");
                section.addPage("Computer Science");
            }
        });
        await context.sync();
    });
OneNote.SectionGroup#addSection:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the section groups that are direct children of the current notebook.
        const sectionGroups = context.application.getActiveNotebook().sectionGroups;
        
        // Queue a command to load the section groups.
        // For best performance, request specific properties.
        sectionGroups.load("id");
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                
        // Add a section to each section group.
        $.each(sectionGroups.items, function(index, sectionGroup) {
            sectionGroup.addSection("Agenda");
        });
        
        // Run the queued commands.
        await context.sync();
    });
OneNote.SectionGroup#addSectionGroup:member(1):
  - |-
    await OneNote.run(async (context) => {
        let sectionGroup;
        let nestedSectionGroup;
    
        // Gets the active notebook.
        const notebook = context.application.getActiveNotebook();
    
        // Queue a command to add a new section group.
        const sectionGroups = notebook.sectionGroups;
    
        // Queue a command to load the new section group.
        sectionGroups.load();
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        sectionGroup = sectionGroups.items[0];
        sectionGroup.load();
        await context.sync();

        nestedSectionGroup = sectionGroup.addSectionGroup("Sample nested section group");
        nestedSectionGroup.load();
        await context.sync();
        
        console.log("New nested section group name is " + nestedSectionGroup.name);
    });
OneNote.SectionGroup#load:member(2):
  - |-
    await OneNote.run(async (context) => {
            
        // Get the parent section group that contains the current section.
        const sectionGroup = context.application.getActiveSection().parentSectionGroup;
                
        // Queue a command to load the section group.
        // For best performance, request specific properties.
        sectionGroup.load("id,name");
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                
        // Write the properties.
        console.log("Section group name: " + sectionGroup.name);
        console.log("Section group ID: " + sectionGroup.id);
    });
OneNote.SectionGroupCollection#getByName:member(1):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the section groups that are direct children of the current notebook.
        const sectionGroups = context.application.getActiveNotebook().sectionGroups;
    
        // Queue a command to load the section groups.
        // For best performance, request specific properties.
        sectionGroups.load("id"); 
    
        // Get the section groups with the specified name.
        const labsSectionGroups = sectionGroups.getByName("Labs");
    
        // Queue a command to load the section groups with the specified properties.
        labsSectionGroups.load("id,name"); 
                
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
    
        // Iterate through the collection or access items individually by index.
        if (labsSectionGroups.items.length > 0) {
            console.log("Section group name: " + labsSectionGroups.items[0].name);
            console.log("Section group ID: " + labsSectionGroups.items[0].id);
        }
    });
OneNote.SectionGroupCollection#load:member(2):
  - |-
    await OneNote.run(async (context) => {
    
        // Get the section groups that are direct children of the current notebook.
        const sectionGroups = context.application.getActiveNotebook().sectionGroups;
    
        // Queue a command to load the section groups.
        // For best performance, request specific properties.
        sectionGroups.load("name"); 
    
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
                
        // Iterate through the collection or access items individually by index.
        // For example: sectionGroups.items[0]
        $.each(sectionGroups.items, function(index, sectionGroup) {
            console.log("Section group name: " + sectionGroup.name);  
            console.log("Section group ID: " + sectionGroup.id);  
        });
    });
OneNote.Table#appendColumn:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        const paragraphs = outline.paragraphs;
        
        // For each table, append a column.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                table.appendColumn(["cell0", "cell1"]);
            }
        }
        await context.sync();
    });
OneNote.Table#appendRow:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        const paragraphs = outline.paragraphs;
        
        // For each table, append a column.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                const row = table.appendRow(["cell0", "cell1"]);
            }
        }
        await context.sync();
    });
OneNote.Table#getCell:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        const paragraphs = outline.paragraphs;
        
        // For each table, get a cell in the second row and third column.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                const cell = table.getCell(2 /*Row Index*/, 3 /*Column Index*/);
            }
        }
        await context.sync();
    });
OneNote.Table#insertColumn:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        const paragraphs = outline.paragraphs;
        
        // For each table, insert a column at index two.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                table.insertColumn(2, ["cell0", "cell1"]);
            }
        }
        await context.sync();
    });
OneNote.Table#insertRow:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync()

        const paragraphs = outline.paragraphs;
        
        // For each table, insert a row at index two.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                const row = table.insertRow(2, ["cell0", "cell1"]);
            }
        }
        await context.sync();
    });
OneNote.Table#load:member(2):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        const paragraphs = outline.paragraphs;
        
        // For each table, log properties.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                context.load(table);
                await context.sync();

                console.log("Table Id: " + table.id);
                console.log("Row Count: " + table.rowCount);
                console.log("Column Count: " + table.columnCount);
                await context.sync();
            }
        }
    });
OneNote.TableCell#appendHtml:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        
        const paragraphs = outline.paragraphs;
        
        // For each table, get a table cell at row one and column two and add "Hello".
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                const cell = table.getCell(1 /*Row Index*/, 2 /*Column Index*/);
                cell.appendHtml("<p>Hello</p>");
            }
        }
        await context.sync();
    });
OneNote.TableCell#appendRichText:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        const appendedRichText = null;
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();

        const paragraphs = outline.paragraphs;
        
        // For each table, get a table cell at row one and column two and add "Hello".
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                const cell = table.getCell(1 /*Row Index*/, 2 /*Column Index*/);
                appendedRichText = cell.appendRichText("Hello");
            }
        }
        await context.sync();
    });
OneNote.TableCell#load:member(2):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        const paragraphs = outline.paragraphs;
        
        // For each table, get a table cell at row one and column two.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                const cell = table.getCell(1 /*Row Index*/, 2 /*Column Index*/);
                
                // Queue a command to load the table cell.
                context.load(cell);
                await context.sync();

                console.log("Cell Id: " + cell.id);
                console.log("Cell Index: " + cell.cellIndex);
                console.log("Cell's Row Index: " + cell.rowIndex);
            }
        }
        await context.sync();
    });
OneNote.TableRow#insertRowAsSibling:member(1):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        
        const paragraphs = outline.paragraphs;
        
        // For each table, get table rows.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                
                // Queue a command to load table.rows.
                context.load(table, "rows");
                
                // Run the queued commands.
                await context.sync();

                const rows = table.rows;
                rows.items[1].insertRowAsSibling("Before", ["cell0", "cell1"]);
                await context.sync();
            }
        }
    });
OneNote.TableRow#load:member(2):
  - |-
    await OneNote.run(async (context) => {
        const app = context.application;
        const outline = app.getActiveOutline();
        
        // Queue a command to load outline.paragraphs and their types.
        context.load(outline, "paragraphs, paragraphs/type");
        
        // Run the queued commands, and return a promise to indicate task completion.
        await context.sync();
        
        const paragraphs = outline.paragraphs;
        
        // For each table, get table rows.
        for (let i = 0; i < paragraphs.items.length; i++) {
            const paragraph = paragraphs.items[i];
            if (paragraph.type == "Table") {
                const table = paragraph.table;
                
                // Queue a command to load table.rows.
                context.load(table, "rows");
                await context.sync();

                const rows = table.rows;
                
                // For each table row, log cell count and row index.
                for (let i = 0; i < rows.items.length; i++) {
                    console.log("Row " + i + " Id: " + rows.items[i].id);
                    console.log("Row " + i + " Cell Count: " + rows.items[i].cellCount);
                    console.log("Row " + i + " Row Index: " + rows.items[i].rowIndex);
                }
                await context.sync();
            }
        }
    });

Office.AppointmentCompose#addHandlerAsync:member(1):
  - |-
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.AppointmentCompose#addItemAttachmentAsync:member(1):
  - |-
    // The following example adds an existing Outlook item as an attachment
    // with the name "My Attachment".
    function addAttachment() {
        // EWS ID of item to attach (shortened for readability).
        const itemId = "AAMkADI1...AAA=";

        // The values in asyncContext can be accessed in the callback.
        const options = { asyncContext: { var1: 1, var2: 2 } };

        Office.context.mailbox.item.addItemAttachmentAsync(itemId, "My Attachment", options, (result) => {
            if (result.status === Office.AsyncResultStatus.Failed) {
                console.error("Failed to add attachment: " + result.error.message);
                return;
            }

            console.log("Attachment added successfully.");
            console.log("var1: " + result.asyncContext.var1);
            console.log("var2: " + result.asyncContext.var2);
        });
    }
Office.AppointmentCompose#body:member:
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext: "This is passed to the callback" },
        function callback(result) {
            // Do something with the result.
        });

    // The following is an example of an object that is passed as the result parameter to the callback function.
    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.AppointmentCompose#end:member:
  - |-
    // The following example sets the end time of an appointment in compose mode by
    // using the `setAsync` method of the `Time` object.
    const endTime = new Date("3/14/2015");
    const options = {
        // Pass information that can be used in the callback.
        asyncContext: {verb: "Set"}
    };
    Office.context.mailbox.item.end.setAsync(endTime, options, function(result) {
        if (result.error) {
            console.debug(result.error);
        } else {
            // Access the asyncContext that was passed to the setAsync method.
            console.debug("End Time " + result.asyncContext.verb);
        }
    });
Office.AppointmentCompose#getInitializationContextAsync:member(1):
  - |-
    // Get the initialization context (if present).
    Office.context.mailbox.item.getInitializationContextAsync((asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            if (asyncResult.value.length > 0) {
                // The value is a string, parse to an object.
                const context = JSON.parse(asyncResult.value);
                // Do something with context.
            } else {
                // Empty context, treat as no context.
            }
        } else {
            // Handle the error.
        }
    });
Office.AppointmentCompose#getSelectedDataAsync:member(1):
  - |-
    // Get selected data.
    Office.context.mailbox.item.getSelectedDataAsync(Office.CoercionType.Text, { option1: "option1"}, getCallback);

    function getCallback(asyncResult) {
        const text = asyncResult.value.data;
        const prop = asyncResult.value.sourceProperty;

        console.log(`Selected text in ${prop}: ${text}`);
    }
Office.AppointmentCompose#location:member:
  - |-
    const userContext = { value : 1 };
    Office.context.mailbox.item.location.getAsync( { context: userContext}, callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const location = asyncResult.value;
    }
Office.AppointmentCompose#optionalAttendees:member:
  - |-
    Office.context.mailbox.item.optionalAttendees.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.optionalAttendees.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.optionalAttendees.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfOptionalAttendeesRecipients = asyncResult.value;
    }
Office.AppointmentCompose#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.item.removeHandlerAsync(Office.EventType.InfobarClicked, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.AppointmentCompose#requiredAttendees:member:
  - |-
    Office.context.mailbox.item.requiredAttendees.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.requiredAttendees.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.requiredAttendees.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfRequiredAttendeesRecipients = asyncResult.value;
        console.log(JSON.stringify(arrayOfRequiredAttendeesRecipients));
    }
Office.AppointmentCompose#saveAsync:member(2):
  - |-
    Office.context.mailbox.item.saveAsync(
        function callback(result) {
            // Process the result.
        });

    // The following is an example of the
    // `result` parameter passed to the
    // callback function. The `value`
    // property contains the item ID of
    // the item.
    {
        "value": "AAMkADI5...AAA=",
        "status": "succeeded"
    }
Office.AppointmentCompose#setSelectedDataAsync:member(1):
  - |-
    Office.context.mailbox.item.setSelectedDataAsync("<b>Hello World!</b>", { coercionType : "html" });
  - |-
    Office.context.mailbox.item.setSelectedDataAsync("Hello World!");
Office.AppointmentRead#addHandlerAsync:member(1):
  - |-
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.AppointmentRead#attachments:member:
  - |-
    // The following code builds an HTML string with details of all attachments on the current item.
    const item = Office.context.mailbox.item;
    let outputString = "";

    if (item.attachments.length > 0) {
        for (let i = 0 ; i < item.attachments.length ; i++) {
            const attachment = item.attachments[i];
            outputString += "<BR>" + i + ". Name: ";
            outputString += attachment.name;
            outputString += "<BR>ID: " + attachment.id;
            outputString += "<BR>contentType: " + attachment.contentType;
            outputString += "<BR>size: " + attachment.size;
            outputString += "<BR>attachmentType: " + attachment.attachmentType;
            outputString += "<BR>isInline: " + attachment.isInline;
        }
    }

    console.log(outputString);
Office.AppointmentRead#body:member:
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        Office.CoercionType.Text,
        { asyncContext: "This is passed to the callback" },
        (result) => {
            // Do something with the result.
        }
    );

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": "TEXT of whole body (including message threads that appear below the current body)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.AppointmentRead#displayReplyAllForm:member(1):
  - |-
    // The following code passes a string to the `displayReplyAllForm` method.
    Office.context.mailbox.item.displayReplyAllForm('hello there');
    Office.context.mailbox.item.displayReplyAllForm('<b>hello there</b>');

    // Reply with an empty body.
    Office.context.mailbox.item.displayReplyAllForm({});

    // Reply with just a body.
    Office.context.mailbox.item.displayReplyAllForm(
    {
    'htmlBody' : 'hi'
    });

    // Reply with a body and a file attachment.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
            'type' : Office.MailboxEnums.AttachmentType.File,
            'name' : 'squirrel.png',
            'url' : 'http://i.imgur.com/sRgTlGR.jpg'
            }
        ]
    });

    // Reply with a body and an item attachment.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
            'type' : 'item',
            'name' : 'rand',
            'itemId' : Office.context.mailbox.item.itemId
            }
        ]
    });

    // Reply with a body, file attachment, item attachment, and a callback.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
                'type' : Office.MailboxEnums.AttachmentType.File,
                'name' : 'squirrel.png',
                'url' : 'http://i.imgur.com/sRgTlGR.jpg'
            },
            {
                'type' : 'item',
                'name' : 'rand',
                'itemId' : Office.context.mailbox.item.itemId
            }
        ],
        'callback' : function(asyncResult)
        {
            console.log(asyncResult.value);
        }
    });
Office.AppointmentRead#getInitializationContextAsync:member(1):
  - |-
    // Get the initialization context (if present).
    Office.context.mailbox.item.getInitializationContextAsync((asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            if (asyncResult.value.length > 0) {
                // The value is a string, parse to an object.
                const context = JSON.parse(asyncResult.value);
                // Do something with context.
            } else {
                // Empty context, treat as no context.
            }
        } else {
            // Handle the error.
        }
    });
Office.AppointmentRead#getRegExMatches:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    // The following example shows how to access the array of
    // matches for the regular expression rule elements `fruits`
    // and `veggies`, which are specified in the manifest.
    const allMatches = Office.context.mailbox.item.getRegExMatches();
    const fruits = allMatches.fruits;
    const veggies = allMatches.veggies;
Office.AppointmentRead#getRegExMatchesByName:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    const fruits = Office.context.mailbox.item.getRegExMatchesByName("fruits");
    const veggies = Office.context.mailbox.item.getRegExMatchesByName("veggies");
Office.AppointmentRead#getSelectedRegExMatches:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    // The following example shows how to access the array of matches for the
    // regular expression rule elements `fruits` and `veggies`, which are
    // specified in the manifest.
    const selectedMatches = Office.context.mailbox.item.getSelectedRegExMatches();
    const fruits = selectedMatches.fruits;
    const veggies = selectedMatches.veggies;
Office.AppointmentRead#isAllDayEvent:member:
  - |-
    const isAllDayEvent = Office.context.mailbox.item.isAllDayEvent;
    console.log("Is this an all-day event? " + isAllDayEvent);
Office.AppointmentRead#itemId:member:
  - |-
    // The following code checks for the presence of an item
    // identifier. If the `itemId` property returns `null` or
    // `undefined`, it saves the item to the store and gets the
    // item identifier from the asynchronous result.
    // **Important**: `saveAsync` was introduced with requirement set 1.3
    // so you can't get the `itemId` in Compose mode in earlier sets.
    let itemId = Office.context.mailbox.item.itemId;
    if (itemId === null || itemId == undefined) {
        Office.context.mailbox.item.saveAsync(function(result) {
            itemId = result.value;
        });
    }
Office.AppointmentRead#location:member:
  - |-
    const location = Office.context.mailbox.item.location;
    console.log("location: " + location);
Office.AppointmentRead#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.item.removeHandlerAsync(Office.EventType.InfobarClicked, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.AppointmentRead#sensitivity:member:
  - |-
    const sensitivity = Office.context.mailbox.item.sensitivity;
    console.log("Sensitivity: " + sensitivity);
Office.AppointmentTimeChangedEventArgs:interface:
  - |-
    // Adds an event handler for the AppointmentTimeChanged event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.AppointmentTimeChanged, appointmentTimeChangedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the AppointmentTimeChanged event.
    function appointmentTimeChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        console.log(`Start time: ${event.start}`);
        console.log(`End time: ${event.end}`);
    }
Office.AttachmentsChangedEventArgs:interface:
  - |-
    // Handles the OnMessageAttachmentsChanged event.
    function onMessageAttachmentsChangedHandler(event) {
        console.log(`Event: ${event.type}`);

        if (event.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = event.attachmentDetails;
            // Perform operations on the attachment that was added.
        }
    }
Office.AttachmentContent#format:member:
  - |-
    const item = Office.context.mailbox.item;
    const options = {asyncContext: {currentItem: item}};
    item.getAttachmentsAsync(options, callback);

    function callback(result) {
        if (result.value.length > 0) {
            for (let i = 0 ; i < result.value.length ; i++) {
                result.asyncContext.currentItem.getAttachmentContentAsync(result.value[i].id, handleAttachmentsCallback);
            }
        }
    }

    function handleAttachmentsCallback(result) {
        // Parse string to be a url, an .eml file, a base64-encoded string, or an .icalendar file.
        switch (result.value.format) {
            case Office.MailboxEnums.AttachmentContentFormat.Base64:
                // Handle file attachment.
                break;
            case Office.MailboxEnums.AttachmentContentFormat.Eml:
                // Handle email item attachment.
                break;
            case Office.MailboxEnums.AttachmentContentFormat.ICalendar:
                // Handle .icalender attachment.
                break;
            case Office.MailboxEnums.AttachmentContentFormat.Url:
                // Handle cloud attachment.
                break;
            default:
                // Handle attachment formats that are not supported.
        }
    }
Office.AttachmentDetails:interface:
  - |-
    // The following code builds an HTML string with details
    // of all attachments on the current item.
    const item = Office.context.mailbox.item;
    let outputString = "";

    if (item.attachments.length > 0) {
        for (let i = 0 ; i < item.attachments.length ; i++) {
            const attachment = item.attachments[i];
            outputString += "<BR>" + i + ". Name: ";
            outputString += attachment.name;
            outputString += "<BR>ID: " + attachment.id;
            outputString += "<BR>contentType: " + attachment.contentType;
            outputString += "<BR>size: " + attachment.size;
            outputString += "<BR>attachmentType: " + attachment.attachmentType;
            outputString += "<BR>isInline: " + attachment.isInline;
        }
    }

    console.log(outputString);
Office.Body#getAsync:member(1):
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext: "This is passed to the callback" },
        function callback(result) {
            // Do something with the result.
        });

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.Body#setAsync:member(1):
  - |-
    // When including links in HTML markup, you can disable online link preview
    // by setting the id attribute on the anchor (<a>) to "LPNoLP".
    Office.context.mailbox.item.body.setAsync(
        '<a id="LPNoLP" href="http://www.contoso.com">Click here!</a>',
        { 
            coercionType: Office.CoercionType.Html,
            asyncContext: "This is passed to the callback"
        },
        (result) => {
            // Process the result.
        }
    );

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": null,
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.CategoryDetails:interface:
  - |-
    const categories = [
        {
            "displayName": "Urgent!",
            "color": Office.MailboxEnums.CategoryColor.Preset0
        }
    ];
Office.Contact:interface:
  - |-
    const item = Office.context.mailbox.item;
    // Get an array of strings that represent contacts in the current item's body.
    const contacts = item.getEntitiesByType(Office.MailboxEnums.EntityType.Contact);
    console.log("There are " + contacts.length + " contacts.")
    contacts.forEach(function (contact) {
        console.log("Person name: " + JSON.stringify(contact.personName));
        console.log("Business name: " + JSON.stringify(contact.businessName));
        console.log("Addresses: " + JSON.stringify(contact.addresses));
        console.log("Phone numbers: " + JSON.stringify(contact.phoneNumbers));
        console.log("Email addresses: " + JSON.stringify(contact.emailAddresses));
        console.log("Urls: " + JSON.stringify(contact.urls));
    });

    /* Example email that includes contact details of sender, John Smith:
    Hi there,
    I have received the package.

    Thanks.
    John Smith
    Account Manager
    Contoso Corporation
    1 Contoso Way, Redmond, WA 98052
    john.smith@contoso.com
    111-111-1111
    https://contoso.com/john.smith
    */
Office.EmailAddressDetails#appointmentResponse:member:
  - |-
    // The following sample provides the responses from required attendees.
    // Note that this sample needs the add-in to be in Appointment Read (Attendee) mode.
    const requiredAttendees = Office.context.mailbox.item.requiredAttendees;
    console.log("There are " + requiredAttendees.length + " required attendees.")
    requiredAttendees.forEach(function (requiredAttendee) {
        console.log("Attendee " + requiredAttendee.displayName + ": " + requiredAttendee.appointmentResponse);
    });
Office.EmailAddressDetails#displayName:member:
  - |-
    const organizerName = Office.context.mailbox.item.organizer.displayName;
    console.log("Organizer: " + organizerName);
Office.EmailAddressDetails#emailAddress:member:
  - |-
    const organizerAddress = Office.context.mailbox.item.organizer.emailAddress;
    console.log("Organizer's email address: " + organizerAddress);
Office.EmailAddressDetails#recipientType:member:
  - |-
    const requiredAttendees = Office.context.mailbox.item.requiredAttendees;
    console.log("There are " + requiredAttendees.length + " required attendees.")
    requiredAttendees.forEach(function (requiredAttendee) {
        console.log("Attendee " + requiredAttendee.displayName + ": " + requiredAttendee.recipientType);
    });
Office.EmailUser:interface:
  - |-
    // Add recipients to the To field of an email.
    const recipients: Office.EmailUser[] = [
        {
            "displayName": "Allie Bellew",
            "emailAddress": "allieb@contoso.com"
        },
        {
            "displayName": "Alex Darrow",
            "emailAddress": "alexd@contoso.com"
        }
    ];

    Office.context.mailbox.item.to.addAsync(recipients, (result) => {
        if (result.status === Office.AsyncResultStatus.Failed) {
            console.log(result.error.message);
            return;
        }

        console.log("Recipients added to the To field.");
    });
Office.EnhancedLocationsChangedEventArgs:interface:
  - |-
    // Adds an event handler for the EnhancedLocationsChanged event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.EnhancedLocationsChanged, enhancedLocationsChangedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the EnhancedLocationsChanged event.
    function enhancedLocationsChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const enhancedLocations = event.enhancedLocations;
        enhancedLocations.forEach((location) => {
            console.log(`Display name: ${location.displayName}`);
            const locationType = location.locationIdentifier.type;
            console.log(`Type: ${locationType}`);
            if (locationType === Office.MailboxEnums.LocationType.Room) {
                console.log(`Email address: ${location.emailAddress}`);
            }
        });
    }
Office.Entities#addresses:member:
  - |-
    const item = Office.context.mailbox.item;
    const addresses = item.getEntitiesByType(Office.MailboxEnums.EntityType.Address);
Office.Entities#contacts:member:
  - |-
    const item = Office.context.mailbox.item;
    const contacts = item.getEntitiesByType(Office.MailboxEnums.EntityType.Contact);
Office.Entities#emailAddresses:member:
  - |-
    const item = Office.context.mailbox.item;
    const emailAddresses = item.getEntitiesByType(Office.MailboxEnums.EntityType.EmailAddress);
Office.Entities#meetingSuggestions:member:
  - |-
    const item = Office.context.mailbox.item;
    const meetingSuggestions = item.getEntitiesByType(Office.MailboxEnums.EntityType.MeetingSuggestion);
Office.Entities#phoneNumbers:member:
  - |-
    const item = Office.context.mailbox.item;
    const phoneNumbers = item.getEntitiesByType(Office.MailboxEnums.EntityType.PhoneNumber);
Office.Entities#taskSuggestions:member:
  - |-
    const item = Office.context.mailbox.item;
    const taskSuggestions = item.getEntitiesByType(Office.MailboxEnums.EntityType.TaskSuggestion);
Office.Entities#urls:member:
  - |-
    const item = Office.context.mailbox.item;
    const urls = item.getEntitiesByType(Office.MailboxEnums.EntityType.Url);
Office.InfobarClickedEventArgs:interface:
  - |-
    // Adds an event handler for the InfobarClicked event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.InfobarClicked, infobarClickedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the InfobarClicked event.
    function infobarClickedHandler(event) {
        console.log(`Event: ${event.type}`);
        const infobarDetails = event.infobarDetails;
        console.log(`Notification type: ${infobarDetails.infobarType}`);
        console.log(`Action type: ${infobarDetails.actionType}`);
    }
Office.LoadedMessageCompose:interface:
  - |-
    // Gets the sender's email address of each selected message.
    async function getSenderEmailAddress(item) {
        const itemId = item.itemId;
        await new Promise((resolve) => {
            Office.context.mailbox.loadItemByIdAsync(itemId, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.log(result.error.message);
                    return;
                }

                const loadedItem = result.value;
                const sender = loadedItem.from.emailAddress;
                console.log(sender);

                // Unload the current message before processing another selected message.
                loadedItem.unloadAsync((asyncResult) => {
                    if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                        console.log(asyncResult.error.message);
                        return;
                    }

                    resolve();
                });
            });
        });
    }
Office.LoadedMessageRead:interface:
  - |-
    // Gets the sender's email address of each selected message.
    async function getSenderEmailAddress(item) {
        const itemId = item.itemId;
        await new Promise((resolve) => {
            Office.context.mailbox.loadItemByIdAsync(itemId, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.log(result.error.message);
                    return;
                }

                const loadedItem = result.value;
                const sender = loadedItem.from.emailAddress;
                console.log(sender);

                // Unload the current message before processing another selected message.
                loadedItem.unloadAsync((asyncResult) => {
                    if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                        console.log(asyncResult.error.message);
                        return;
                    }

                    resolve();
                });
            });
        });
    }
Office.Location#getAsync:member(1):
  - |-
    const userContext = { value : 1 };
    Office.context.mailbox.item.location.getAsync( { context: userContext}, callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const location = asyncResult.value;
    }
Office.LocationDetails:interface:
  - |-
    Office.context.mailbox.item.enhancedLocation.getAsync(callbackFunction);

    function callbackFunction(asyncResult) {
        asyncResult.value.forEach(function (place) {
            console.log("Display name: " + place.displayName);
            console.log("Type: " + place.locationIdentifier.type);
            if (place.locationIdentifier.type === Office.MailboxEnums.LocationType.Room) {
                console.log("Email address: " + place.emailAddress);
            }
        });
    }
Office.LocationIdentifier:interface:
  - |-
    const locations = [
        {
            "id": "Contoso",
            "type": Office.MailboxEnums.LocationType.Custom
        }
    ];
Office.Mailbox:interface:
  - |-
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.ItemChanged, loadNewItem, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    // Handle error.
                }
            });
        });
    });

    function loadNewItem(eventArgs) {
        const item = Office.context.mailbox.item;

        // Check that item isn't null.
        if (item !== null) {
            // Work with item. For example, define and call a function that
            // loads the properties of the newly selected item.
            loadProps(item);
        }
    }
Office.Mailbox#addHandlerAsync:member(1):
  - |-
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.ItemChanged, loadNewItem, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    // Handle error.
                }
            });
        });
    });

    function loadNewItem(eventArgs) {
        const item = Office.context.mailbox.item;

        // Check that item isn't null.
        if (item !== null) {
            // Work with item. For example, define and call a function that
            // loads the properties of the newly selected item.
            loadProps(item);
        }
    }
Office.Mailbox#convertToUtcClientTime:member(1):
  - |-
    // Represents 3:37 PM PDT on Monday, August 26, 2019.
    const input = {
        date: 26,
        hours: 15,
        milliseconds: 2,
        minutes: 37,
        month: 7,
        seconds: 2,
        timezoneOffset: -420,
        year: 2019
    };

    // result should be a Date object.
    const result = Office.context.mailbox.convertToUtcClientTime(input);
    
    // Output should be "2019-08-26T22:37:02.002Z".
    console.log(result.toISOString());
Office.Mailbox#getIsIdentityManaged:member(1):
  - |-
    // Checks if the mailbox is managed by Microsoft Intune.
    const isIdentityManaged = Office.context.mailbox.getIsIdentityManaged();
    console.log(`Intune-managed mailbox: ${isIdentityManaged}`);
Office.Mailbox#getIsOpenFromLocationAllowed:member(1):
  - |-
    // Checks if the add-in can access data from the device's photo library.
    const isOpenFromPhotoLibraryAllowed = Office.context.mailbox.getIsOpenFromLocationAllowed(Office.MailboxEnums.OpenLocation.PhotoLibrary);
    if (isOpenFromPhotoLibraryAllowed) {
        console.log("Access to the photo library is allowed.");
        // Do something.
    } else {
        console.log("Access to the photo library isn't allowed.");
    }
Office.Mailbox#getIsSaveToLocationAllowed:member(1):
  - |-
    // Checks if the add-in can save data to SharePoint.
    const isSaveToSharePointAllowed = Office.context.mailbox.getIsSaveToLocationAllowed(Office.MailboxEnums.SaveLocation.SharePoint);
    if (isSaveToSharePointAllowed) {
        console.log("Saving to SharePoint is allowed.");
        // Do something.
    } else {
        console.log("Saving to SharePoint isn't allowed.");
    }
Office.Mailbox#makeEwsRequestAsync:member(1):
  - |-
    function getSubjectRequest(id) {
        // Return a GetItem operation request for the subject of the specified item.
        const request =
            '<?xml version="1.0" encoding="utf-8"?>' +
            '<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' +
            '               xmlns:xsd="http://www.w3.org/2001/XMLSchema"' +
            '               xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"' +
            '               xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types">' +
            '  <soap:Header>' +
            '    <RequestServerVersion Version="Exchange2016" xmlns="http://schemas.microsoft.com/exchange/services/2006/types" soap:mustUnderstand="0" />' +
            '  </soap:Header>' +
            '  <soap:Body>' +
            '    <GetItem xmlns="http://schemas.microsoft.com/exchange/services/2006/messages">' +
            '      <ItemShape>' +
            '        <t:BaseShape>IdOnly</t:BaseShape>' +
            '        <t:AdditionalProperties>' +
            '            <t:FieldURI FieldURI="item:Subject"/>' +
            '        </t:AdditionalProperties>' +
            '      </ItemShape>' +
            '      <ItemIds><t:ItemId Id="' + id + '"/></ItemIds>' +
            '    </GetItem>' +
            '  </soap:Body>' +
            '</soap:Envelope>';

        return request;
    }

    function sendRequest() {
        // Create a local variable that contains the mailbox.
        Office.context.mailbox.makeEwsRequestAsync(
            getSubjectRequest(mailbox.item.itemId), callback);
    }

    function callback(asyncResult)  {
        const result = asyncResult.value;
        const context = asyncResult.asyncContext;

        // Process the returned response here.
    }
Office.Mailbox#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.removeHandlerAsync(Office.EventType.OfficeThemeChanged, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.Mailbox#restUrl:member:
  - |-
    // Get the URL of the REST endpoint.
    const restUrl = Office.context.mailbox.restUrl;
    console.log(`REST API URL: ${restUrl}`);
Office.MailboxEnums.AttachmentStatus:enum:
  - |-
    // Get the attachment that was just added to a message or appointment.
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.MailboxEnums.DelegatePermissions:enum:
  - |-
    Office.context.mailbox.item.getSharedPropertiesAsync((result) => {
        if (result.status === Office.AsyncResultStatus.Failed) {
            console.error("The current folder or mailbox isn't shared.");
            return;
        }

        const delegatePermissions = result.value.delegatePermissions;

        // Check if the user has write permissions to the shared resource.
        if ((delegatePermissions & Office.MailboxEnums.DelegatePermissions.Write) != 0) {
            console.log("User has write permissions to the shared resource.");
            // Perform the necessary operations.
        }
    });
Office.MailboxEnums.InfobarActionType:enum:
  - |-
    /*
    * This snippet activates when a notification message is dismissed from an Outlook message or appointment.
    * The event handler logs the custom action and notification type to the console.
    */
    Office.context.mailbox.item.addHandlerAsync(Office.EventType.InfobarClicked, eventHandler, callback);

    function eventHandler(event) {
        const infobarDetails = event.infobarDetails;

        // Log the custom action type.
        console.log(`Custom action type: ${infobarDetails.actionType}`);

        // Log the notification type.
        switch (infobarDetails.infobarType) {
            case Office.MailboxEnums.InfobarType.Error:
                console.log("Notification type: Error message");
                break;
            case Office.MailboxEnums.InfobarType.Informational:
                console.log("Notification type: Informational message");
                break;
            case Office.MailboxEnums.InfobarType.Insight:
                console.log("Notification type: Informational message with available actions from the task pane");
                break;
            case Office.MailboxEnums.InfobarType.ProgressIndicator:
                console.log("Notification type: Progress indicator");
                break;
        }
    }
Office.InfobarDetails:interface:
  - |-
    /*
    * This snippet activates when a notification message is dismissed from an Outlook message or appointment.
    * The event handler logs the custom action and notification type to the console.
    */
    Office.context.mailbox.item.addHandlerAsync(Office.EventType.InfobarClicked, eventHandler, callback);

    function eventHandler(event) {
        const infobarDetails = event.infobarDetails;

        // Log the custom action type.
        console.log(`Custom action type: ${infobarDetails.actionType}`);

        // Log the notification type.
        switch (infobarDetails.infobarType) {
            case Office.MailboxEnums.InfobarType.Error:
                console.log("Notification type: Error message");
                break;
            case Office.MailboxEnums.InfobarType.Informational:
                console.log("Notification type: Informational message");
                break;
            case Office.MailboxEnums.InfobarType.Insight:
                console.log("Notification type: Informational message with available actions from the task pane");
                break;
            case Office.MailboxEnums.InfobarType.ProgressIndicator:
                console.log("Notification type: Progress indicator");
                break;
        }
    }
Office.MailboxEnums.InfobarType:enum:
  - |-
    /*
    * This snippet activates when a notification message is dismissed from an Outlook message or appointment.
    * The event handler logs the custom action and notification type to the console.
    */
    Office.context.mailbox.item.addHandlerAsync(Office.EventType.InfobarClicked, eventHandler, callback);

    function eventHandler(event) {
        const infobarDetails = event.infobarDetails;

        // Log the custom action type.
        console.log(`Custom action type: ${infobarDetails.actionType}`);

        // Log the notification type.
        switch (infobarDetails.infobarType) {
            case Office.MailboxEnums.InfobarType.Error:
                console.log("Notification type: Error message");
                break;
            case Office.MailboxEnums.InfobarType.Informational:
                console.log("Notification type: Informational message");
                break;
            case Office.MailboxEnums.InfobarType.Insight:
                console.log("Notification type: Informational message with available actions from the task pane");
                break;
            case Office.MailboxEnums.InfobarType.ProgressIndicator:
                console.log("Notification type: Progress indicator");
                break;
        }
    }
Office.MailboxEnums.MoveSpamItemTo:enum:
  - |-
    // The following example handles a SpamReporting event to process a reported spam or phishing message.
    function onSpamReport(event) {
        // Get the Base64-encoded EML format of a reported message.
        Office.context.mailbox.item.getAsFileAsync({ asyncContext: event }, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(`Error encountered during message processing: ${asyncResult.error.message}`);
                return;
            }

            // Run additional processing operations here.

            /**
             * Signal that the spam-reporting event has completed processing.
             * It then moves the reported message to a custom mailbox folder named "Reported Messages"
             * and shows a post-processing dialog to the user.
             * If an error occurs while the message is being processed, the `onErrorDeleteItem`
             * property determines whether the message will be deleted.
             */
            const event = asyncResult.asyncContext;
            event.completed({
                moveItemTo: Office.MailboxEnums.MoveSpamItemTo.CustomFolder,
                folderName: "Reported Messages",
                onErrorDeleteItem: true,
                showPostProcessingDialog: {
                    title: "Contoso Spam Reporting",
                    description: "Thank you for reporting this message.",
                },
            });
        });
    }
Office.MailboxEnums.OpenLocation:enum:
  - |-
    // Checks if the add-in can access data from the device's photo library.
    const isOpenFromPhotoLibraryAllowed = Office.context.mailbox.getIsOpenFromLocationAllowed(Office.MailboxEnums.OpenLocation.PhotoLibrary);
    if (isOpenFromPhotoLibraryAllowed) {
        console.log("Access to the photo library is allowed.");
        // Do something.
    } else {
        console.log("Access to the photo library isn't allowed.");
    }
Office.MailboxEnums.SaveLocation:enum:
  - |-
    // Checks if the add-in can save data to SharePoint.
    const isSaveToSharePointAllowed = Office.context.mailbox.getIsSaveToLocationAllowed(Office.MailboxEnums.SaveLocation.SharePoint);
    if (isSaveToSharePointAllowed) {
        console.log("Saving to SharePoint is allowed.");
        // Do something.
    } else {
        console.log("Saving to SharePoint isn't allowed.");
    }
Office.MailboxEnums.SendModeOverride:enum:
  - |-
    // The following example checks whether a location is specified in an appointment before it's sent.
    function onAppointmentSendHandler(event) {
        Office.context.mailbox.item.location.getAsync({ asyncContext: event }, (asyncResult) => {
            const event = asyncResult.asyncContext;
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(asyncResult.error.message);
                // If the add-in is unable to retrieve the appointment's location, the appointment isn't sent.
                event.completed({ allowEvent: false, errorMessage: "Failed to get the appointment's location." });
                return;
            }

            if (asyncResult.value === "") {
                // If no location is specified, the appointment isn't sent and the user is alerted to include a location.
                event.completed(
                    {
                        allowEvent: false,
                        cancelLabel: "Add a location",
                        commandId: "msgComposeOpenPaneButton",
                        errorMessage: "Don't forget to add a meeting location.",
                        sendModeOverride: Office.MailboxEnums.SendModeOverride.PromptUser
                    }
                );
            } else {
                // If a location is specified, the appointment is sent.
                event.completed({ allowEvent: true });
            }
        });
    }
Office.MailboxEvent#completed:member(1):
  - |-
    // The following example sets the subject when a new message is composed.
    function onNewMessageComposeHandler(event) {
        const subject = "Set by an event-based add-in!";
        Office.context.mailbox.item.subject.setAsync(
            subject,
            {
                asyncContext: event,
            },
            (asyncResult) => {
                const event = asyncResult.asyncContext;
                if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                    console.error("Failed to set subject: " + asyncResult.error.message);
                    event.completed();
                    return;
                }

                // Signal to the Outlook client that the event has been processed.
                console.log("Successfully set the subject.");
                event.completed();
            }
        );
    }
Office.MeetingSuggestion:interface:
  - |-
    const item = Office.context.mailbox.item;
    // Get an array of strings that represent meeting suggestions in the current item's body.
    const meetingSuggestions = item.getEntitiesByType(Office.MailboxEnums.EntityType.MeetingSuggestion);
    console.log("There are " + meetingSuggestions.length + " meeting suggestions.")
    meetingSuggestions.forEach(function (meetingSuggestion) {
        console.log("Subject: " + JSON.stringify(meetingSuggestion.subject));
        console.log("Attendees: " + JSON.stringify(meetingSuggestion.attendees));
        console.log("Location: " + JSON.stringify(meetingSuggestion.location));
        console.log("Start: " + JSON.stringify(meetingSuggestion.start));
        console.log("End: " + JSON.stringify(meetingSuggestion.end));
        console.log("Meeting: " + JSON.stringify(meetingSuggestion.meetingString));
    });
Office.MessageCompose#addHandlerAsync:member(1):
  - |-
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.MessageCompose#addItemAttachmentAsync:member(1):
  - |-
    // The following example adds an existing Outlook item as an attachment
    // with the name "My Attachment".
    function addAttachment() {
        // EWS ID of item to attach (shortened for readability).
        const itemId = "AAMkADI1...AAA=";

        // The values in asyncContext can be accessed in the callback.
        const options = { asyncContext: { var1: 1, var2: 2 } };

        Office.context.mailbox.item.addItemAttachmentAsync(itemId, "My Attachment", options, (result) => {
            if (result.status === Office.AsyncResultStatus.Failed) {
                console.error("Failed to add attachment: " + result.error.message);
                return;
            }

            console.log("Attachment added successfully.");
            console.log("var1: " + result.asyncContext.var1);
            console.log("var2: " + result.asyncContext.var2);
        });
    }
Office.MessageCompose#bcc:member:
  - |-
    Office.context.mailbox.item.bcc.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.bcc.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.bcc.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfBccRecipients = asyncResult.value;
    }
Office.MessageCompose#body:member:
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext: "This is passed to the callback" },
        function callback(result) {
            // Do something with the result.
        });

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.MessageCompose#cc:member:
  - |-
    Office.context.mailbox.item.cc.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.cc.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.cc.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfCcRecipients = asyncResult.value;
    }
Office.MessageCompose#getInitializationContextAsync:member(1):
  - |-
    // Get the initialization context (if present).
    Office.context.mailbox.item.getInitializationContextAsync((asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            if (asyncResult.value.length > 0) {
                // The value is a string, parse to an object.
                const context = JSON.parse(asyncResult.value);
                // Do something with context.
            } else {
                // Empty context, treat as no context.
            }
        } else {
            // Handle the error.
        }
    });
Office.MessageCompose#getSelectedDataAsync:member(1):
  - |-
    // Get selected data.
    Office.context.mailbox.item.getSelectedDataAsync(Office.CoercionType.Text, { option1: "option1"}, getCallback);

    function getCallback(asyncResult) {
        const text = asyncResult.value.data;
        const prop = asyncResult.value.sourceProperty;

        console.log(`Selected text in ${prop}: ${text}`);
    }
Office.MessageCompose#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.item.removeHandlerAsync(Office.EventType.ItemChanged, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.MessageCompose#saveAsync:member(2):
  - |-
    Office.context.mailbox.item.saveAsync(
        function callback(result) {
            // Process the result.
        });

    // The following is an example of the
    // `result` parameter passed to the
    // callback function. The `value`
    // property contains the item ID of
    // the item.
    {
        "value": "AAMkADI5...AAA=",
        "status": "succeeded"
    }
Office.MessageCompose#setSelectedDataAsync:member(1):
  - |-
    Office.context.mailbox.item.setSelectedDataAsync("<b>Hello World!</b>", { coercionType : "html" });
  - |-
    Office.context.mailbox.item.setSelectedDataAsync("Hello World!");
Office.MessageCompose#to:member:
  - |-
    Office.context.mailbox.item.to.setAsync( ['alice@contoso.com', 'bob@contoso.com'] );
    Office.context.mailbox.item.to.addAsync( ['jason@contoso.com'] );
    Office.context.mailbox.item.to.getAsync(callback);

    function callback(asyncResult) {
        const arrayOfToRecipients = asyncResult.value;
    }
Office.MessageRead:interface:
 - |-
   // The following code builds an HTML string with details of all attachments on the current item.
    const item = Office.context.mailbox.item;
    let outputString = "";
    if (item.attachments.length > 0) {
        for (let i = 0 ; i < item.attachments.length ; i++) {
            const attachment = item.attachments[i];
            outputString += "<BR>" + i + ". Name: ";
            outputString += attachment.name;
            outputString += "<BR>ID: " + attachment.id;
            outputString += "<BR>contentType: " + attachment.contentType;
            outputString += "<BR>size: " + attachment.size;
            outputString += "<BR>attachmentType: " + attachment.attachmentType;
            outputString += "<BR>isInline: " + attachment.isInline;
        }
    }
    console.log(outputString);
Office.MessageRead#addHandlerAsync:member(1):
  - |-
    function myHandlerFunction(eventarg) {
        if (eventarg.attachmentStatus === Office.MailboxEnums.AttachmentStatus.Added) {
            const attachment = eventarg.attachmentDetails;
            console.log("Event Fired and Attachment Added!");
            getAttachmentContentAsync(attachment.id, options, callback);
        }
    }

    Office.context.mailbox.item.addHandlerAsync(Office.EventType.AttachmentsChanged, myHandlerFunction, myCallback);
Office.MessageRead#attachments:member:
  - |-
    // The following code builds an HTML string with details of all attachments on the current item.
    const item = Office.context.mailbox.item;
    let outputString = "";

    if (item.attachments.length > 0) {
        for (let i = 0 ; i < item.attachments.length ; i++) {
            const attachment = item.attachments[i];
            outputString += "<BR>" + i + ". Name: ";
            outputString += attachment.name;
            outputString += "<BR>ID: " + attachment.id;
            outputString += "<BR>contentType: " + attachment.contentType;
            outputString += "<BR>size: " + attachment.size;
            outputString += "<BR>attachmentType: " + attachment.attachmentType;
            outputString += "<BR>isInline: " + attachment.isInline;
        }
    }

    console.log(outputString);
Office.MessageRead#body:member:
  - |-
    // This example gets the body of the item as plain text.
    Office.context.mailbox.item.body.getAsync(
        "text",
        { asyncContext: "This is passed to the callback" },
        function callback(result) {
            // Do something with the result.
        });

    // The following is an example of the result parameter passed to the callback function.
    {
        "value": "TEXT of whole body (including threads below)",
        "status": "succeeded",
        "asyncContext": "This is passed to the callback"
    }
Office.MessageRead#displayReplyAllForm:member(1):
  - |-
    // The following code passes a string to the `displayReplyAllForm` method.
    Office.context.mailbox.item.displayReplyAllForm('hello there');
    Office.context.mailbox.item.displayReplyAllForm('<b>hello there</b>');

    // Reply with an empty body.
    Office.context.mailbox.item.displayReplyAllForm({});

    // Reply with just a body.
    Office.context.mailbox.item.displayReplyAllForm(
    {
    'htmlBody' : 'hi'
    });

    // Reply with a body and a file attachment.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
            'type' : Office.MailboxEnums.AttachmentType.File,
            'name' : 'squirrel.png',
            'url' : 'http://i.imgur.com/sRgTlGR.jpg'
            }
        ]
    });

    // Reply with a body and an item attachment.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
            'type' : 'item',
            'name' : 'rand',
            'itemId' : Office.context.mailbox.item.itemId
            }
        ]
    });

    // Reply with a body, file attachment, item attachment, and a callback.
    Office.context.mailbox.item.displayReplyAllForm(
    {
        'htmlBody' : 'hi',
        'attachments' :
        [
            {
                'type' : Office.MailboxEnums.AttachmentType.File,
                'name' : 'squirrel.png',
                'url' : 'http://i.imgur.com/sRgTlGR.jpg'
            },
            {
                'type' : 'item',
                'name' : 'rand',
                'itemId' : Office.context.mailbox.item.itemId
            }
        ],
        'callback' : function(asyncResult)
        {
            console.log(asyncResult.value);
        }
    });
Office.MessageRead#getInitializationContextAsync:member(1):
  - |-
    // Get the initialization context (if present).
    Office.context.mailbox.item.getInitializationContextAsync((asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
            if (asyncResult.value.length > 0) {
                // The value is a string, parse to an object.
                const context = JSON.parse(asyncResult.value);
                // Do something with context.
            } else {
                // Empty context, treat as no context.
            }
        } else {
            // Handle the error.
        }
    });
Office.MessageRead#getRegExMatches:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    // The following example shows how to access the array of
    // matches for the regular expression rule elements `fruits`
    // and `veggies`, which are specified in the manifest.
    const allMatches = Office.context.mailbox.item.getRegExMatches();
    const fruits = allMatches.fruits;
    const veggies = allMatches.veggies;
Office.MessageRead#getRegExMatchesByName:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    const fruits = Office.context.mailbox.item.getRegExMatchesByName("fruits");
    const veggies = Office.context.mailbox.item.getRegExMatchesByName("veggies");
Office.MessageRead#getSelectedRegExMatches:member(1):
  - |-
    // Consider an add-in manifest has the following `Rule` element:
    //<Rule xsi:type="RuleCollection" Mode="And">
    //  <Rule xsi:type="ItemIs" FormType="Read" ItemType="Message" />
    //  <Rule xsi:type="RuleCollection" Mode="Or">
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="fruits" RegExValue="apple|banana|coconut" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //    <Rule xsi:type="ItemHasRegularExpressionMatch" RegExName="veggies" RegExValue="tomato|onion|spinach|broccoli" PropertyName="BodyAsPlaintext" IgnoreCase="true" />
    //  </Rule>
    //</Rule>

    // The object returned from `getRegExMatches` would have two properties: `fruits` and `veggies`.
    //{
    //'fruits': ['apple','banana','Banana','coconut'],
    //'veggies': ['tomato','onion','spinach','broccoli']
    //}

    // The following example shows how to access the array of matches for the
    // regular expression rule elements `fruits` and `veggies`, which are
    // specified in the manifest.
    const selectedMatches = Office.context.mailbox.item.getSelectedRegExMatches();
    const fruits = selectedMatches.fruits;
    const veggies = selectedMatches.veggies;
Office.MessageRead#itemId:member:
  - |-
    // The following code checks for the presence of an item
    // identifier. If the `itemId` property returns `null` or
    // `undefined`, it saves the item to the store and gets the
    // item identifier from the asynchronous result.
    // **Important**: `saveAsync` was introduced with requirement set 1.3
    // so you can't get the `itemId` in Compose mode in earlier sets.
    let itemId = Office.context.mailbox.item.itemId;
    if (itemId === null || itemId == undefined) {
        Office.context.mailbox.item.saveAsync(function(result) {
            itemId = result.value;
        });
    }
Office.MessageRead#removeHandlerAsync:member(2):
  - |-
    Office.context.mailbox.item.removeHandlerAsync(Office.EventType.ItemChanged, (asyncResult) => {
        if (asyncResult.status === Office.AsyncResultStatus.Failed) {
            console.error("Failed to remove event handler: " + asyncResult.error.message);
            return;
        }

        console.log("Event handler removed successfully.");
    });
Office.OfficeThemeChangedEventArgs:interface:
  - |-
    // Adds an event handler for the OfficeThemeChanged event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.OfficeThemeChanged, officeThemeChangedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the OfficeThemeChanged event.
    function officeThemeChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const currentTheme = event.officeTheme;
        // Perform operations based on the current theme.
    }
Office.PhoneNumber:interface:
  - |-
    const item = Office.context.mailbox.item;
    // Get an array of strings that represent phone numbers in the current item's body.
    const phoneNumbers = item.getEntitiesByType(Office.MailboxEnums.EntityType.PhoneNumber);
    console.log("There are " + phoneNumbers.length + " phone numbers.")
    phoneNumbers.forEach(function (phoneNumber) {
        console.log("Phone number: " + JSON.stringify(phoneNumber.phoneString));
        console.log("Type: " + JSON.stringify(phoneNumber.type));
        console.log("Source text: " + JSON.stringify(phoneNumber.originalPhoneString));
    });
Office.Recipients#addAsync:member(1):
  - |-
    // The following example creates an array of EmailUser objects
    // and adds them to the To recipients of the message.
    const newRecipients = [
        {
            "displayName": "Allie Bellew",
            "emailAddress": "allieb@contoso.com"
        },
        {
            "displayName": "Alex Darrow",
            "emailAddress": "alexd@contoso.com"
        }
    ];

    Office.context.mailbox.item.to.addAsync(newRecipients, function(result) {
        if (result.error) {
            console.log(result.error);
        } else {
            console.log("Recipients added");
        }
    });
Office.Recipients#setAsync:member(2):
  - |-
    // The following example creates an array of EmailUser objects and
    // replaces the CC recipients of the message with the array.
    const newRecipients = [
        {
            "displayName": "Allie Bellew",
            "emailAddress": "allieb@contoso.com"
        },
        {
            "displayName": "Alex Darrow",
            "emailAddress": "alexd@contoso.com"
        }
    ];

    Office.context.mailbox.item.cc.setAsync(newRecipients, function(result) {
        if (result.error) {
            console.log(result.error);
        } else {
            console.log("Recipients overwritten");
        }
    });
Office.RecipientsChangedEventArgs:interface:
  - |-
    // Handles the OnMessageRecipientsChanged event.
    function onMessageRecipientsChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const recipientFields = event.changedRecipientFields;
        console.log(getChangedRecipientFields(recipientFields));
    }

    // Gets the recipient fields that have changed.
    function getChangedRecipientFields(recipientFields) {
        return Object.keys(recipientFields).filter((key) => recipientFields[key] === true);
    }
Office.RecipientsChangedFields:interface:
  - |-
    // Handles the OnMessageRecipientsChanged event.
    function onMessageRecipientsChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const recipientFields = event.changedRecipientFields;
        const changedFields = getChangedRecipientFields(recipientFields);

        if (changedFields.includes("to")) {
            // Perform operations based on the updated recipients in the To field.
        }
    }

    // Gets the recipient fields that have changed.
    function getChangedRecipientFields(recipientFields) {
        return Object.keys(recipientFields).filter((key) => recipientFields[key] === true);
    }
Office.RecurrenceChangedEventArgs:interface:
  - |-
    // Adds an event handler for the RecurrenceChanged event.
    Office.onReady(() => {
        document.addEventListener('DOMContentLoaded', () => {
            // Get a reference to the mailbox and use it to add an event handler.
            const mailbox = Office.context.mailbox;
            mailbox.addHandlerAsync(Office.EventType.RecurrenceChanged, recurrenceChangedHandler, (result) => {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    console.error(`Failed to add event handler: ${asyncResult.error.message}`);
                    return;
                }

                console.log("Event handler added successfully.");
            });
        });
    });

    // Handles the RecurrenceChanged event.
    function recurrenceChangedHandler(event) {
        console.log(`Event: ${event.type}`);
        const recurrence = event.recurrence;

        // Perform operations based on the updated recurrence.
    }
Office.RecurrenceProperties:interface:
  - |-
    // This example gets the Recurrence object of an appointment item.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        if (!recurrence) {
            console.log("One-time appointment or meeting");
        } else {
            console.log(JSON.stringify(recurrence));
        }
    }

    // The following example shows the results of the getAsync call that retrieves the recurrence for a series.
    // NOTE: In this example, seriesTimeObject is a placeholder for the JSON representing the
    // recurrence.seriesTime property. You should use the SeriesTime object's methods to get the
    // recurrence date and time properties.
    Recurrence = {
        "recurrenceType": "weekly",
        "recurrenceProperties": {"interval": 2, "days": ["mon","thu","fri"], "firstDayOfWeek": "sun"},
        "seriesTime": {seriesTimeObject},
        "recurrenceTimeZone": {"name": "Pacific Standard Time", "offset": -480}
    }
Office.RecurrenceTimeZone:interface:
  - |-
    // This example gets the Recurrence object of an appointment item.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        if (!recurrence) {
        //if (recurrence == null) {
            console.log("One-time appointment or meeting");
        } else {
            console.log(JSON.stringify(recurrence));
        }
    }

    // The following example shows the results of the getAsync call that retrieves the recurrence for a series.
    // NOTE: In this example, seriesTimeObject is a placeholder for the JSON representing the
    // recurrence.seriesTime property. You should use the SeriesTime object's methods to get the
    // recurrence date and time properties.
    Recurrence = {
        "recurrenceType": "weekly",
        "recurrenceProperties": {"interval": 2, "days": ["mon","thu","fri"], "firstDayOfWeek": "sun"},
        "seriesTime": {seriesTimeObject},
        "recurrenceTimeZone": {"name": "Pacific Standard Time", "offset": -480}
    }
Office.SensitivityLabelChangedEventArgs:interface:
  - |-
    // Handles a change to an item's sensitivity label.
    function onSensitivityLabelChangedHandler(event) {
        console.log(`Event: ${event.type}`);

        // Perform operations based on the event.
    }
Office.SensitivityLabelDetails:interface:
  - |-
    // Check whether the catalog of sensitivity labels is enabled on the current mailbox.
    Office.context.sensitivityLabelsCatalog.getIsEnabledAsync((asyncResult) => {
        // If the catalog is enabled, get all available sensitivity labels.
        if (asyncResult.status === Office.AsyncResultStatus.Succeeded && asyncResult.value == true) {
            Office.context.sensitivityLabelsCatalog.getAsync((asyncResult) => {
                if (asyncResult.status === Office.AsyncResultStatus.Succeeded) {
                    const catalog = asyncResult.value;
                    console.log("Sensitivity Labels Catalog:");
                    
                    // Log the details of the available sensitivity labels to the console.
                    catalog.forEach((sensitivityLabel) => {
                        console.log(`Name: ${sensitivityLabel.name}`);
                        console.log(`ID: ${sensitivityLabel.id}`);
                        console.log(`Tooltip: ${sensitivityLabel.tooltip}`);
                        console.log(`Color: ${sensitivityLabel.color}`);
                        console.log(`Sublabels: ${JSON.stringify(sensitivityLabel.children)}`);
                    });
                } else {
                    console.log("Action failed with error: " + asyncResult.error.message);
                }
            });
        } else {
            console.log("Action failed with error: " + asyncResult.error.message);
        }
    });
Office.SeriesTime#getDuration:member(1):
  - |-
    // This example gets the duration of a usual instance in a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const duration = recurrence.seriesTime.getDuration();
    }
Office.SeriesTime#getEndDate:member(1):
  - |-
    // This example gets the end date of a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const endDate = recurrence.seriesTime.getEndDate();
    }
Office.SeriesTime#getEndTime:member(1):
  - |-
    // This example gets the end time of a usual instance in a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const endDate = recurrence.seriesTime.getEndTime();
    }
Office.SeriesTime#getStartDate:member(1):
  - |-
    // This example gets the start date of a recurring appointment series.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const endDate = recurrence.seriesTime.getStartDate();
    }
Office.SeriesTime#getStartTime:member(1):
  - |-
    // This example gets the start time of a usual
    // instance in a recurring appointment series.
    const seriesTimeObject = new SeriesTime();
    seriesTimeObject.setDuration(120);
Office.SeriesTime#setDuration:member(1):
  - |-
    // This example sets the duration of each appointment
    // in a recurring series to 2 hours.
    Office.context.mailbox.item.recurrence.getAsync(callback);

    function callback(asyncResult) {
        const context = asyncResult.context;
        const recurrence = asyncResult.value;
        const endDate = recurrence.seriesTime.getStartTime();
    }
Office.SeriesTime#setEndDate:member(1):
  - |-
    // This example sets the end date of a recurring
    // appointment series to November 2, 2017.
    const seriesTimeObject = new SeriesTime();
    seriesTimeObject.setEndDate(2017, 10, 2);
Office.SeriesTime#setEndDate:member(2):
  - |-
    // This example sets the end date of a
    // recurring appointment series to November 2, 2017
    // using ISO 8601 date standard.
    const seriesTimeObject = new SeriesTime()
    seriesTimeObject.setEndDate("2017-11-02");
Office.SeriesTime#setStartDate:member(1):
  - |-
    // This example sets the start date of a recurring
    // appointment series to November 2, 2017.
    const seriesTimeObject = new SeriesTime();
    seriesTimeObject.setStartDate(2017, 10, 2);
Office.SeriesTime#setStartDate:member(2):
  - |-
    // This example sets the start date of a recurring
    // appointment series to November 2, 2017
    // using ISO 8601 date standard.
    const seriesTimeObject = new SeriesTime()
    seriesTimeObject.setStartDate("2017-11-02");
Office.SeriesTime#setStartTime:member(1):
  - |-
    // This example sets the start time of each instance
    // of a recurring appointment series to 1:30 PM.
    const seriesTimeObject = new SeriesTime();
    seriesTimeObject.setStartTime(13, 30);

    // This example sets the start time of each instance
    // of a recurring appointment series to 11:30 AM.
    seriesTimeObject.setStartTime(11, 30);
Office.SeriesTime#setStartTime:member(2):
  - |-
    // This example sets the start time of each instance
    // of a recurring appointment series to 11:30 PM.
    const seriesTimeObject = new SeriesTime()
    seriesTimeObject.setStartTime("T23:30:00");
Office.SmartAlertsEventCompletedOptions:interface:
  - |-
    // The following example checks whether a location is specified in an appointment before it's sent.
    function onAppointmentSendHandler(event) {
        Office.context.mailbox.item.location.getAsync({ asyncContext: event }, asyncResult => {
            const event = asyncResult.asyncContext;
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(asyncResult.error.message);
                // If the add-in is unable to retrieve the appointment's location, the appointment isn't sent.
                event.completed({ allowEvent: false, errorMessage: "Failed to get the appointment's location." });
                return;
            }

            if (asyncResult.value === "") {
                // If no location is specified, the appointment isn't sent and the user is alerted to include a location.
                event.completed(
                    {
                        allowEvent: false,
                        cancelLabel: "Add a location",
                        commandId: "msgComposeOpenPaneButton",
                        contextData: JSON.stringify({ a: "aValue", b: "bValue" }),
                        errorMessage: "Don't forget to add a meeting location.",
                        errorMessageMarkdown: `
                            Don't forget to add a meeting location.\n\n
                            **Tip**: For a list of locations,
                            see [Meeting Locations]("https://www.contoso.com/meeting-locations).`,
                        sendModeOverride: Office.MailboxEnums.SendModeOverride.PromptUser
                    }
                );
            } else {
                // If a location is specified, the appointment is sent.
                event.completed({ allowEvent: true });
            }
        });
    }
Office.SpamReportingEventArgs:interface:
  - |-
    // This example handles a SpamReporting event to process a reported spam or phishing message.
    function onSpamReport(event) {
        if (event.type === "SpamReporting") {
            const reportedOptions = event.options;
            const additionalInfo = event.freeText;

            // Run additional processing operations here.

            // Signal that the event has completed processing.
            event.completed({
                moveItemTo: Office.MailboxEnums.MoveSpamItemTo.CustomFolder,
                folderName: "Reported Messages",
                onErrorDeleteItem: true,
                showPostProcessingDialog: {
                    title: "Contoso Spam Reporting",
                    description: "Thank you for reporting this message."
                }
            });
        }
    }
Office.SpamReportingEventCompletedOptions:interface:
  - |-
    // The following example handles a SpamReporting event to process a reported spam or phishing message.
    function onSpamReport(event) {
        // Gets the Base64-encoded EML format of a reported message.
        Office.context.mailbox.item.getAsFileAsync({ asyncContext: event }, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(`Error encountered during message processing: ${asyncResult.error.message}`);
                return;
            }

            // Run additional processing operations here.

            /**
            * Signals that the spam-reporting event has completed processing.
            * It then moves the reported message to a custom mailbox folder named "Reported Messages"
            * and shows a post-processing dialog to the user.
            * If an error occurs while the message is being processed, the `onErrorDeleteItem`
            * property determines whether the message will be deleted.
            */
            const event = asyncResult.asyncContext;
            event.completed({
                moveItemTo: Office.MailboxEnums.MoveSpamItemTo.CustomFolder,
                folderName: "Reported Messages",
                onErrorDeleteItem: true,
                showPostProcessingDialog: {
                    title: "Contoso Spam Reporting",
                    description: "Thank you for reporting this message.",
                },
            });
        });
    }
Office.SpamReportingEventCompletedOptions#postProcessingAction:member:
  - |-
    // The following example handles a SpamReporting event to process a reported spam or phishing message.
    function onSpamReport(event) {
        // Gets the Base64-encoded EML format of a reported message.
        Office.context.mailbox.item.getAsFileAsync({ asyncContext: event }, (asyncResult) => {
            if (asyncResult.status === Office.AsyncResultStatus.Failed) {
                console.log(`Error encountered during message processing: ${asyncResult.error.message}`);
                return;
            }

            // Run additional processing operations here.

            /**
            * Signals that the spam-reporting event has completed processing.
            * It then moves the reported message to the Junk Email folder of the mailbox and shows a
            * post-processing dialog to the user.
            */
            const event = asyncResult.asyncContext;
            event.completed({
                postProcessingAction: "moveToSpamFolder",
                showPostProcessingDialog: {
                    title: "Contoso Spam Reporting",
                    description: "Thank you for reporting this message.",
                },
            });
        });
    }
Office.Subject#getAsync:member(2):
  - |-
    Office.context.mailbox.item.subject.getAsync(callback);

    function callback(asyncResult) {
        const subject = asyncResult.value;
    }
Office.Subject#setAsync:member(1):
  - |-
    Office.context.mailbox.item.subject.setAsync("New subject!", function (asyncResult) {
        if (asyncResult.status === "failed") {
            console.log("Action failed with error: " + asyncResult.error.message);
        }
    });
Office.TaskSuggestion:interface:
  - |-
    const item = Office.context.mailbox.item;
    // Get an array of strings that represent task suggestions in the current item's body.
    const taskSuggestions = item.getEntitiesByType(Office.MailboxEnums.EntityType.TaskSuggestion);
    console.log("There are " + taskSuggestions.length + " task suggestions.")
    taskSuggestions.forEach(function (taskSuggestion) {
        console.log("Assignees: " + JSON.stringify(taskSuggestion.assignees));
        console.log("Task: " + JSON.stringify(taskSuggestion.taskString));
    });
Office.Time#setAsync:member(1):
  - |-
    const startTime = new Date("3/14/2015");
    const options = {
        // Pass information that can be used in the callback.
        asyncContext: {verb: "Set"}
    };
    Office.context.mailbox.item.start.setAsync(startTime, options, function(result) {
        if (result.error) {
            console.debug(result.error);
        } else {
            // Access the asyncContext that was passed to the setAsync method.
            console.debug("Start Time " + result.asyncContext.verb);
        }
    });
Office.UserProfile#accountType:member:
  - |-
    console.log(Office.context.mailbox.userProfile.accountType);
Office.UserProfile#displayName:member:
  - |-
    // Example: Allie Bellew
    console.log(Office.context.mailbox.userProfile.displayName);
Office.UserProfile#emailAddress:member:
  - |-
    // Example: allieb@contoso.com
    console.log(Office.context.mailbox.userProfile.emailAddress);
Office.UserProfile#timeZone:member:
  - |-
    // Example: Pacific Standard Time
    console.log(Office.context.mailbox.userProfile.timeZone);

PowerPoint.createPresentation:function(1):
  - |-
    const myFile = <HTMLInputElement>document.getElementById("file");
    const reader = new FileReader();

    reader.onload = (event) => {
      // Remove the metadata before the base64-encoded string.
      const startIndex = reader.result.toString().indexOf("base64,");
      const copyBase64 = reader.result.toString().substr(startIndex + 7);

      PowerPoint.createPresentation(copyBase64);
    };

    // Read in the file as a data URL so we can parse the base64-encoded string.
    reader.readAsDataURL(myFile.files[0]);
PowerPoint.RequestContext:class:
  - |-
    // *.run methods automatically create an OfficeExtension.ClientRequestContext
    // object to work with the Office file.
    await PowerPoint.run(async (context) => {
      const presentation = context.presentation;
      // Interact with the PowerPoint presentation...
    });
Visio.Application#showBorders:member:
  - |-
    Visio.run(session, function (ctx) {
        const application = ctx.document.application;
        application.showToolbars = false;
        application.showBorders = false;
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Comment#load:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shapeName = "Position Belt.41";
        const shape = activePage.shapes.getItem(shapeName);
        const shapeComments= shape.comments;
        shapeComments.load(["author", "text"]);
        return ctx.sync().then(function () {
            for (let i = 0; i < shapeComments.items.length; i++)
            {
                const comment = shapeComments.items[i];
                console.log("comment Author: " + comment.author);
                console.log("Comment Text: " + comment.text);
                console.log("Date " + comment.date);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.CommentCollection#load:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shapeName = "Position Belt.41";
        const shape = activePage.shapes.getItem(shapeName);
        const shapeComments= shape.comments;
        shapeComments.load(["author", "text"]);
        return ctx.sync().then(function () {
            for (let i = 0; i < shapeComments.items.length; i++)
            {
                const comment = shapeComments.items[i];
                console.log("comment Author: " + comment.author);
                console.log("Comment Text: " + comment.text);
                console.log("Date " + comment.date);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.DataRefreshCompleteEventArgs:interface:
  - |-
    Visio.run(session, function (ctx) {
        const document1 = ctx.document;
        eventResult1 = document1.onDataRefreshComplete.add(
            function (args){
                console.log("Data Refresh Result: "+args.success);
            });
    
        return ctx.sync().then(function () {
           console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Document#getActivePage:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const document = ctx.document;
        const activePage = document.getActivePage();
        activePage.load("name");
        return ctx.sync().then(function () {
            console.log("pageName: " +activePage.name);
        });   
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Document#setActivePage:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const document = ctx.document;
        const pageName = "Page-1";
        document.setActivePage(pageName);
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Document#startDataRefresh:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const document = ctx.document;
        document.startDataRefresh();
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Document#pages:member:
  - |-
    Visio.run(session, function (ctx) {
        const pages = ctx.document.pages;
        const pageCount = pages.getCount();
        return ctx.sync().then(function () {
            console.log("Pages Count: " +pageCount.value);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.DocumentLoadCompleteEventArgs:interface:
  - |-
    Visio.run(session, function (ctx) {
        const document1 = ctx.document;
        eventResult1 = document1.onDocumentLoadComplete.add(
            function (args){
                console.log("Document Loaded");
            });
    
        return ctx.sync().then(function () {
            console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.DocumentView#disableHyperlinks:member:
  - |-
    Visio.run(session, function (ctx) {
        const documentView = ctx.document.view;
        documentView.disableHyperlinks();
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Highlight#color:member:
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        shape.view.highlight.color = "#E7E7E7";
        shape.view.highlight.width = 100;
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.Hyperlink#load:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        const hyperlink = shape.hyperlinks.getItem(0);
        hyperlink.load();
        return ctx.sync().then(function() {
            console.log(hyperlink.description);
            console.log(hyperlink.address);
            console.log(hyperlink.subAddress);
            console.log(hyperlink.extraInfo);
         });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.HyperlinkCollection#load:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shapeName = "Manager Belt";
        const shape = activePage.shapes.getItem(shapeName);
        const shapeHyperlinks = shape.hyperlinks;
        shapeHyperlinks.load(["description", "address", "subAddress"]);
            ctx.sync().then(function () {
                for (let i = 0; i < shapeHyperlinks.items.length; i++) {
                    const hyperlink = shapeHyperlinks.items[i];
                    console.log(
                        "Description:"+hyperlink.description +"Address:"+hyperlink.address +"SubAddress:  " + 
                        hyperlink.subAddress);
                }
            });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.PageCollection#getItem:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const pageName = 'Page-1';
        const page = ctx.document.pages.getItem(pageName);
        page.activate();
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.PageLoadCompleteEventArgs:interface:
  - |-
    Visio.run(session, function (ctx) {
        const document1= ctx.document;
        eventResult1 = document1.onPageLoadComplete.add(
            function (args){
                console.log("Page name: "+args.pageName);
            });
    
        return ctx.sync().then(function () {
            console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.PageView#centerViewportOnShape:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        activePage.view.centerViewportOnShape(shape.Id);
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.PageView#zoom:member:
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        activePage.view.zoom = 300;
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.SelectionChangedEventArgs:interface:
  - |-
    let eventResult; // Global variable to store the EventHandlerResult returned on attaching handler.
    
    function AttachHandler() {
        Visio.run(session, function(ctx) {
            const doc = ctx.document;
            eventResult = doc.onSelectionChanged.add(
                function (args) {
                    console.log("Selected Shape Name: "+args.shapeNames[0]);
                });
            return ctx.sync().then(function(){
                console.log("Handler attached");
            });
        }).catch(function(error) {
            console.log("Error: " + error);
            if (error instanceof OfficeExtension.Error) {
                console.log("Debug info: " + JSON.stringify(error.debugInfo));
            }
        });
    
        function onSelectionChanged(args) {
            console.log(Date.now() + "Selection Changes Event" + JSON.stringify(args));
        }
    }
    
    function RemoveHandler() {
        if (!eventResult || !eventResult.context) {
            console.log("Handler has not been attached");
            return;
        }
    
        Visio.run(eventResult.context, function(ctx) {
            eventResult.remove();
            return ctx.sync().then(function (){
                eventResult = null;
                console.log("Handler removed");
            });
        }).catch(function(error) {
            console.log("Error: " + error);
            if (error instanceof OfficeExtension.Error) {
                console.log("Debug info: " + JSON.stringify(error.debugInfo));
            }
        });
    }
Visio.Shape#load:member(2):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shapeName = "Sample Name";
        const shape = activePage.shapes.getItem(shapeName);
        shape.load(["name", "id", "text", "select"]);
        return ctx.sync().then(function () {
            console.log(shape.name);
            console.log(shape.id);
            console.log(shape.text);
            console.log(shape.select);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        shape.view.highlight = { color: "#E7E7E7", width: 100 };
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeCollection#getCount:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const numShapesActivePage = activePage.shapes.getCount();
        return ctx.sync().then(function () {
            console.log("Shapes Count: " + numShapesActivePage.value);
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeDataItem#load:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        const shapeDataItem = shape.shapeDataItems.getItem(0);
        shapeDataItem.load(["label", "value"]);
            return ctx.sync().then(function() {
                console.log(shapeDataItem.label);
                console.log(shapeDataItem.value);
            });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeDataItemCollection#load:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        const shapeDataItems = shape.shapeDataItems;
        shapeDataItems.load(["label", "value"]);
        return ctx.sync().then(function() {
            for (let i = 0; i < shapeDataItems.items.length; i++) {
                console.log(shapeDataItems.items[i].label);
                console.log(shapeDataItems.items[i].value);
            }
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeMouseEnterEventArgs:interface:
  - |-
    Visio.run(session, function (ctx) {
        const document1= ctx.document;
        eventResult2 = document1.onShapeMouseEnter.add(
        function (args) {            
            console.log(Date.now()+":OnShapeMouseEnter Event"+JSON.stringify(args));
        });
        return ctx.sync().then(function () {
            console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeMouseLeaveEventArgs:interface:
  - |-
    Visio.run(session, function (ctx) {
        const document1= ctx.document;
        eventResult2 = document1.onShapeMouseLeave.add(
            function (args){            
                console.log(Date.now()+":OnShapeMouseLeave Event"+JSON.stringify(args));
            });
        return ctx.sync().then(function () {
            console.log("Success");
        });
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeView#highlight:member:
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        shape.view.highlight = { color: "#E7E7E7", width: 100 };
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeView#addOverlay:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        const overlayId = shape.view.addOverlay("Image", "Visio Online", "Center", "Middle", 50, 50);
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Visio.ShapeView#removeOverlay:member(1):
  - |-
    Visio.run(session, function (ctx) {
        const activePage = ctx.document.getActivePage();
        const shape = activePage.shapes.getItem(0);
        shape.view.removeOverlay(1);
        return ctx.sync();
    }).catch(function(error) {
        console.log("Error: " + error);
        if (error instanceof OfficeExtension.Error) {
            console.log("Debug info: " + JSON.stringify(error.debugInfo));
        }
    });
Word.Body:class:
  - |-
    // Get the body object and read its font size.
    await Word.run(async (context) => {
        // Create a proxy object for the document body.
        const body = context.document.body;
        body.load("font/size");

        await context.sync();

        console.log("Font size: " + body.font.size);
    });
Word.ContentControl:class:
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
    
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to load the properties on the first content control.
            contentControls.items[0].load(  'appearance,' +
                                            'cannotDelete,' +
                                            'cannotEdit,' +
                                            'color,' +
                                            'id,' +
                                            'placeHolderText,' +
                                            'removeWhenEdited,' +
                                            'title,' +
                                            'text,' +
                                            'type,' +
                                            'style,' +
                                            'tag,' +
                                            'font/size,' +
                                            'font/name,' +
                                            'font/color');

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Property values of the first content control:' +
                '   ----- appearance: ' + contentControls.items[0].appearance +
                '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                '   ----- color: ' + contentControls.items[0].color +
                '   ----- id: ' + contentControls.items[0].id +
                '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                '   ----- title: ' + contentControls.items[0].title +
                '   ----- text: ' + contentControls.items[0].text +
                '   ----- type: ' + contentControls.items[0].type +
                '   ----- style: ' + contentControls.items[0].style +
                '   ----- tag: ' + contentControls.items[0].tag +
                '   ----- font size: ' + contentControls.items[0].font.size +
                '   ----- font name: ' + contentControls.items[0].font.name +
                '   ----- font color: ' + contentControls.items[0].font.color);
        }
    });
Word.ContentControl#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the content controls collection.
        contentControls.load('text');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            
        if (contentControls.items.length === 0) {
            console.log("There isn't a content control in this document.");
        } else {
            // Queue a command to clear the contents of the first content control.
            contentControls.items[0].clear();

            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Content control cleared of contents.');
        }
    });
    
Word.ContentControl#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the content controls collection.
        contentControls.load('text');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            
        if (contentControls.items.length === 0) {
            console.log("There isn't a content control in this document.");
        } else {            
            // Queue a command to delete the first content control. 
            // The contents will remain in the document.
            contentControls.items[0].delete(true);

            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Content control cleared of contents.'); 
        }
    });
Word.ContentControl#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection that contains a specific tag.
        const contentControlsWithTag = context.document.contentControls.getByTag('Customer-Address');
        
        // Queue a command to load the tag property for all of content controls.
        contentControlsWithTag.load('tag');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControlsWithTag.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to get the HTML contents of the first content control.
            const html = contentControlsWithTag.items[0].getHtml();
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Content control HTML: ' + html.value);
        }
    });
Word.ContentControl#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to get the OOXML contents of the first content control.
            const ooxml = contentControls.items[0].getOoxml();
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Content control OOXML: ' + ooxml.value);
        }
    });
Word.ContentControl#insertBreak:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of content controls.
        contentControls.load('id');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        // We now will have access to the content control collection.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to insert a page break after the first content control.
            contentControls.items[0].insertBreak(Word.BreakType.page, Word.InsertLocation.after);
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Inserted a page break after the first content control.');    
        }
    });
Word.ContentControl#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to put HTML into the contents of the first content control.
            contentControls.items[0].insertHtml(
                '<strong>HTML content inserted into the content control.</strong>',
                'Start');
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Inserted HTML in the first content control.');
        }
    });
Word.ContentControl#insertOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to put OOXML into the contents of the first content control.
            contentControls.items[0].insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", "End");
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Inserted OOXML in the first content control.');
        }
    });  

    // Read "Create better add-ins for Word with Office Open XML" for guidance on working with OOXML.
    // https://learn.microsoft.com/office/dev/add-ins/word/create-better-add-ins-for-word-with-office-open-xml
Word.ContentControl#insertParagraph:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to insert a paragraph after the first content control.
            contentControls.items[0].insertParagraph('Text of the inserted paragraph.', 'After');
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Inserted a paragraph after the first content control.');
        }
    });  
Word.ContentControl#insertText:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to replace text in the first content control.
            contentControls.items[0].insertText('Replaced text in the first content control.', 'Replace');
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Replaced text in the first content control.');
        }
    });  

    // The Silly stories add-in sample shows how to use the insertText method.
    // https://aka.ms/sillystorywordaddin
Word.ContentControl#load:member(1):
  - |-
    // Load all of the content control properties
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        } else {
            // Queue a command to load the properties on the first content control.
            contentControls.items[0].load(  'appearance,' +
                                            'cannotDelete,' +
                                            'cannotEdit,' +
                                            'id,' +
                                            'placeHolderText,' +
                                            'removeWhenEdited,' +
                                            'title,' +
                                            'text,' +
                                            'type,' +
                                            'style,' +
                                            'tag,' +
                                            'font/size,' +
                                            'font/name,' +
                                            'font/color');             
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Property values of the first content control:' + 
                '   ----- appearance: ' + contentControls.items[0].appearance + 
                '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                '   ----- color: ' + contentControls.items[0].color +
                '   ----- id: ' + contentControls.items[0].id +
                '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                '   ----- title: ' + contentControls.items[0].title +
                '   ----- text: ' + contentControls.items[0].text +
                '   ----- type: ' + contentControls.items[0].type +
                '   ----- style: ' + contentControls.items[0].style +
                '   ----- tag: ' + contentControls.items[0].tag +
                '   ----- font size: ' + contentControls.items[0].font.size +
                '   ----- font name: ' + contentControls.items[0].font.name +
                '   ----- font color: ' + contentControls.items[0].font.color);
        }
    });  
Word.ContentControl#search:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
        
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
         
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to select the first content control.
            contentControls.items[0].select();
        
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Selected the first content control.');
        }
    });  
Word.ContentControlCollection#getById:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content control that contains a specific id.
        const contentControl = context.document.contentControls.getById(30086310);
    
        // Queue a command to load the text property for a content control.
        contentControl.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The content control with that Id has been found in this document.');
    });
Word.ContentControlCollection#getByIdOrNullObject:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content control that contains a specific id.
        const contentControl = context.document.contentControls.getByIdOrNullObject(30086310);
    
        // Queue a command to load the text property for a content control.
        contentControl.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControl.isNullObject) {
            console.log('There is no content control with that ID.')
        } else {
            console.log('The content control with that ID has been found in this document.');
        }
    });
Word.ContentControlCollection#getByTitle:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content controls collection that contains a specific title.
        const contentControlsWithTitle = context.document.contentControls.getByTitle('Enter Customer Address Here');
    
        // Queue a command to load the text property for all of content controls with a specific title.
        contentControlsWithTitle.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControlsWithTitle.items.length === 0) {
            console.log(
                "There isn't a content control with a title of 'Enter Customer Address Here' in this document.");
        } else {
            console.log(
                "The first content control with the title of 'Enter Customer Address Here' has this text: " + 
                contentControlsWithTitle.items[0].text);
        }
    });

    // The Word-Add-in-DocumentAssembly sample has another example of using the getByTitle method.
    // https://github.com/OfficeDev/Word-Add-in-DocumentAssembly
Word.ContentControlCollection#getFirst:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the first content control in the document.
        const contentControl = context.document.contentControls.getFirstOrNullObject();
    
        // Queue a command to load the text property for a content control.
        contentControl.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControl.isNullObject) {
            console.log('There are no content controls in this document.')
        } else {
            console.log('The first content control has been found in this document.');
        }
    });
Word.ContentControlCollection#load:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
    
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to load the properties on the first content control.
            contentControls.items[0].load(  'appearance,' +
                                            'cannotDelete,' +
                                            'cannotEdit,' +
                                            'color,' +
                                            'id,' +
                                            'placeHolderText,' +
                                            'removeWhenEdited,' +
                                            'title,' +
                                            'text,' +
                                            'type,' +
                                            'style,' +
                                            'tag,' +
                                            'font/size,' +
                                            'font/name,' +
                                            'font/color');

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Property values of the first content control:' +
                '   ----- appearance: ' + contentControls.items[0].appearance +
                '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                '   ----- color: ' + contentControls.items[0].color +
                '   ----- id: ' + contentControls.items[0].id +
                '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                '   ----- title: ' + contentControls.items[0].title +
                '   ----- text: ' + contentControls.items[0].text +
                '   ----- type: ' + contentControls.items[0].type +
                '   ----- style: ' + contentControls.items[0].style +
                '   ----- tag: ' + contentControls.items[0].tag +
                '   ----- font size: ' + contentControls.items[0].font.size +
                '   ----- font name: ' + contentControls.items[0].font.name +
                '   ----- font color: ' + contentControls.items[0].font.color);
        }
    });

    // The Silly stories add-in sample shows how the load method is used
    // to load the content control collection with the tag and title properties.
    // https://aka.ms/sillystorywordaddin
Word.ContentControlType:enum:
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the content controls collection.
        const contentControls = context.document.contentControls;
    
        // Queue a command to load the id property for all of the content controls.
        contentControls.load('id');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (contentControls.items.length === 0) {
            console.log('No content control found.');
        }
        else {
            // Queue a command to load the properties on the first content control.
            contentControls.items[0].load(  'appearance,' +
                                            'cannotDelete,' +
                                            'cannotEdit,' +
                                            'color,' +
                                            'id,' +
                                            'placeHolderText,' +
                                            'removeWhenEdited,' +
                                            'title,' +
                                            'text,' +
                                            'type,' +
                                            'style,' +
                                            'tag,' +
                                            'font/size,' +
                                            'font/name,' +
                                            'font/color');

            // Synchronize the document state by executing the queued commands,
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Property values of the first content control:' +
                '   ----- appearance: ' + contentControls.items[0].appearance +
                '   ----- cannotDelete: ' + contentControls.items[0].cannotDelete +
                '   ----- cannotEdit: ' + contentControls.items[0].cannotEdit +
                '   ----- color: ' + contentControls.items[0].color +
                '   ----- id: ' + contentControls.items[0].id +
                '   ----- placeHolderText: ' + contentControls.items[0].placeholderText +
                '   ----- removeWhenEdited: ' + contentControls.items[0].removeWhenEdited +
                '   ----- title: ' + contentControls.items[0].title +
                '   ----- text: ' + contentControls.items[0].text +
                '   ----- type: ' + contentControls.items[0].type +
                '   ----- style: ' + contentControls.items[0].style +
                '   ----- tag: ' + contentControls.items[0].tag +
                '   ----- font size: ' + contentControls.items[0].font.size +
                '   ----- font name: ' + contentControls.items[0].font.name +
                '   ----- font color: ' + contentControls.items[0].font.color);
        }
    });
Word.Document#getSelection:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        const textSample = 'This is an example of the insert text method. This is a method ' + 
            'which allows users to insert text into a selection. It can insert text into a ' +
            'relative location or it can overwrite the current selection. Since the ' +
            'getSelection method returns a range object, look up the range object documentation ' +
            'for everything you can do with a selection.';
        
        // Create a range proxy object for the current selection.
        const range = context.document.getSelection();
        
        // Queue a command to insert text at the end of the selection.
        range.insertText(textSample, Word.InsertLocation.end);
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Inserted the text at the end of the selection.');
    });  
Word.Document#load:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the document.
        const thisDocument = context.document;
        
        // Queue a command to load content control properties.
        thisDocument.load('contentControls/id, contentControls/text, contentControls/tag');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        if (thisDocument.contentControls.items.length !== 0) {
            for (let i = 0; i < thisDocument.contentControls.items.length; i++) {
                console.log(thisDocument.contentControls.items[i].id);
                console.log(thisDocument.contentControls.items[i].text);
                console.log(thisDocument.contentControls.items[i].tag);
            }
        } else {
            console.log('No content controls in this document.');
        }
    });
Word.Document#save:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the document.
        const thisDocument = context.document;
    
        // Queue a command to load the document save state (on the saved property).
        thisDocument.load('saved');    
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            
        if (thisDocument.saved === false) {
            // Queue a command to save this document.
            thisDocument.save();
            
            // Synchronize the document state by executing the queued commands, 
            // and return a promise to indicate task completion.
            await context.sync();
            console.log('Saved the document');
        } else {
            console.log('The document has not changed since the last save.');
        }
    });
Word.DocumentCreated#open:member(1):
  - |-
    // Create and open a new document in a new tab or window.
    await Word.run(async (context) => {
        const externalDoc = context.application.createDocument();
        await context.sync();

        externalDoc.open();
        await context.sync();
    });
Word.Font:class:
  - |-
    // Change the font color
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to change the font color of the current selection.
        selection.font.color = 'blue';
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The font color of the selection has been changed.');
    });
Word.Font#name:member:
  - |-
    // Change the font name
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to change the current selection's font name.
        selection.font.name = 'Arial';
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The font name has changed.');
    });
Word.Font#color:member:
  - |-
    // Change the font color
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to change the font color of the current selection.
        selection.font.color = 'blue';
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The font color of the selection has been changed.');
    });
Word.Font#size:member:
  - |-
    // Change the font size
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to change the current selection's font size.
        selection.font.size = 20;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The font size has changed.');
    });
Word.Font#highlightColor:member:
  - |-
    // Highlight selected text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to highlight the current selection.
        selection.font.highlightColor = '#FFFF00'; // Yellow
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection has been highlighted.');
    });
Word.Font#bold:member:
  - |-
    // Bold format text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to make the current selection bold.
        selection.font.bold = true;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection is now bold.');
    });
Word.Font#underline:member:
  - |-
    // Underline format text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to underline the current selection.
        selection.font.underline = Word.UnderlineType.single;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection now has an underline style.');
    });
Word.Font#strikeThrough:member:
  - |-
    // Strike format text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to strikethrough the font of the current selection.
        selection.font.strikeThrough = true;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection now has a strikethrough.');
    });
Word.InlinePicture#getNext:member(1):
  - |-
    // To use this snippet, add an inline picture to the document and assign it an alt text title.
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the first inline picture.
        const firstPicture = context.document.body.inlinePictures.getFirstOrNullObject();
    
        // Queue a command to load the alternative text title of the picture.
        firstPicture.load('altTextTitle');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (firstPicture.isNullObject) {
            console.log('There are no inline pictures in this document.')
        } else {
            console.log(firstPicture.altTextTitle);
        }
    }); 
Word.InlinePicture#getNextOrNullObject:member(1):
  - |-
    // To use this snippet, add an inline picture to the document and assign it an alt text title.
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy object for the first inline picture.
        const firstPicture = context.document.body.inlinePictures.getFirstOrNullObject();
    
        // Queue a command to load the alternative text title of the picture.
        firstPicture.load('altTextTitle');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (firstPicture.isNullObject) {
            console.log('There are no inline pictures in this document.')
        } else {
            console.log(firstPicture.altTextTitle);
        }
    }); 
Word.Paragraph#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        paragraphs.load('style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to clear the contents of the first paragraph.
        paragraphs.items[0].clear();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Cleared the contents of the first paragraph.');
    });
Word.Paragraph#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the text property for all of the paragraphs.
        paragraphs.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to delete the first paragraph.
        paragraphs.items[0].delete();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Deleted the first paragraph.');
    });
Word.Paragraph#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        paragraphs.load('style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a set of commands to get the HTML of the first paragraph.
        const html = paragraphs.items[0].getHtml();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Paragraph HTML: ' + html.value);
    });
Word.Paragraph#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        paragraphs.load({select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a set of commands to get the OOXML of the first paragraph.
        const ooxml = paragraphs.items[0].getOoxml();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Paragraph OOXML: ' + ooxml.value);
    });
Word.Paragraph#getPreviousOrNullObject:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the text property for all of the paragraphs.
        paragraphs.load('text');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue commands to create a proxy object for the next-to-last paragraph.
        const indexOfLastParagraph = paragraphs.items.length - 1;
        const precedingParagraph = paragraphs.items[indexOfLastParagraph].getPreviousOrNullObject();

        // Queue a command to load the text of the preceding paragraph.
        precedingParagraph.load('text');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        if (precedingParagraph.isNullObject) {
            console.log('There are no paragraphs before the current one.');
        } else {
            console.log('The preceding paragraph is: ' + precedingParagraph.text);
        }
    });
Word.Paragraph#insertBreak:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        paragraphs.load({select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to get the first paragraph.
        const paragraph = paragraphs.items[0];

        // Queue a command to insert a page break after the first paragraph.
        paragraph.insertBreak(Word.BreakType.page, Word.InsertLocation.after);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Inserted a page break after the paragraph.');
    });
Word.Paragraph#insertContentControl:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        paragraphs.load({select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to get the first paragraph.
        const paragraph = paragraphs.items[0];

        // Queue a command to wrap the first paragraph in a rich text content control.
        paragraph.insertContentControl();

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Wrapped the first paragraph in a content control.');
    });
Word.Paragraph#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for the top 2 paragraphs.
        // We never perform an empty load. We always must request a property.
        paragraphs.load({select: 'style', top: 2} );
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to get the first paragraph.
        const paragraph = paragraphs.items[0];

        // Queue a command to insert HTML content at the end of the first paragraph.
        paragraph.insertHtml('<strong>Inserted HTML.</strong>', Word.InsertLocation.end);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Inserted HTML content at the end of the first paragraph.');
    });
Word.Paragraph#insertInlinePictureFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;
    
        // Queue a command to load the style property for all of the paragraphs.
        paragraphs.load('style');
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a command to get the first paragraph.
        const paragraph = paragraphs.items[0];

        const b64encodedImg = "iVBORw0KGgoAAAANSUhEUgAAAB4AAAANCAIAAAAxEEnAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACFSURBVDhPtY1BEoQwDMP6/0+XgIMTBAeYoTqso9Rkx1zG+tNj1H94jgGzeNSjteO5vtQQuG2seO0av8LzGbe3anzRoJ4ybm/VeKEerAEbAUpW4aWQCmrGFWykRzGBCnYy2ha3oAIq2MloW9yCCqhgJ6NtcQsqoIKdjLbFLaiACnYyf2fODbrjZcXfr2F4AAAAAElFTkSuQmCC";

        // Queue a command to insert a base64 encoded image at the beginning of the first paragraph.
        paragraph.insertInlinePictureFromBase64(b64encodedImg, Word.InsertLocation.start);

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Added an image to the first paragraph.');
    });
Word.ParagraphCollection#load:member(1):
  - |-
    // This example shows how to get the paragraphs in the Word document
    // along with their text and font size properties.
    // 
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {

        // Create a proxy object for the paragraphs collection.
        const paragraphs = context.document.body.paragraphs;

        // Queue a command to load the text and font properties.
        // It is best practice to always specify the property set. Otherwise, all properties are
        // returned in on the object.
        paragraphs.load('text, font/size');

        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();

        // Insert code that works with the paragraphs loaded by paragraphs.load().
    });
Word.Range#clear:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to clear the contents of the proxy range object.
        range.clear();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Cleared the selection (range object)');
    });
Word.Range#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to delete the range object.
        range.delete();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Deleted the selection (range object)');
    });
Word.Range#getHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to get the HTML of the current selection.
        const html = range.getHtml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The HTML read from the document was: ' + html.value);
    });
Word.Range#getHyperlinkRanges:member(1):
  - |-
    await Word.run(async (context) => {
        // Get the entire document body.
        const bodyRange = context.document.body.getRange(Word.RangeLocation.whole);

        // Get all the ranges that only consist of hyperlinks.
        const hyperLinks = bodyRange.getHyperlinkRanges();
        hyperLinks.load("hyperlink");
        await context.sync();

        // Log each hyperlink.
        hyperLinks.items.forEach((linkRange) => {
            console.log(linkRange.hyperlink);
        });
    });
Word.Range#getOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to get the OOXML of the current selection.
        const ooxml = range.getOoxml();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The OOXML read from the document was:  ' + ooxml.value);
    });
Word.Range#insertBreak:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert a page break after the selected text.
        range.insertBreak(Word.BreakType.page, Word.InsertLocation.after);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Inserted a page break after the selected text.');
    });
Word.Range#insertFileFromBase64:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert base64 encoded .docx at the beginning of the range.
        // You'll need to implement getBase64() to make this work.
        range.insertFileFromBase64(getBase64(), Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Added base64 encoded text to the beginning of the range.');
    });
Word.Range#insertHtml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert HTML in to the beginning of the range.
        range.insertHtml('<strong>This is text inserted with range.insertHtml()</strong>', Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('HTML added to the beginning of the range.');
    });
Word.Range#insertOoxml:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert OOXML in to the beginning of the range.
        range.insertOoxml("<pkg:package xmlns:pkg='http://schemas.microsoft.com/office/2006/xmlPackage'><pkg:part pkg:name='/_rels/.rels' pkg:contentType='application/vnd.openxmlformats-package.relationships+xml' pkg:padding='512'><pkg:xmlData><Relationships xmlns='http://schemas.openxmlformats.org/package/2006/relationships'><Relationship Id='rId1' Type='http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' Target='word/document.xml'/></Relationships></pkg:xmlData></pkg:part><pkg:part pkg:name='/word/document.xml' pkg:contentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml'><pkg:xmlData><w:document xmlns:w='http://schemas.openxmlformats.org/wordprocessingml/2006/main' ><w:body><w:p><w:pPr><w:spacing w:before='360' w:after='0' w:line='480' w:lineRule='auto'/><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val='70AD47' w:themeColor='accent6'/><w:sz w:val='28'/></w:rPr><w:t>This text has formatting directly applied to achieve its font size, color, line spacing, and paragraph spacing.</w:t></w:r></w:p></w:body></w:document></pkg:xmlData></pkg:part></pkg:package>", Word.InsertLocation.start);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('OOXML added to the beginning of the range.');
    });
    
    // Read "Create better add-ins for Word with Office Open XML" for guidance on working with OOXML.
    // https://learn.microsoft.com/office/dev/add-ins/word/create-better-add-ins-for-word-with-office-open-xml
Word.Range#insertParagraph:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert the paragraph after the range.
        range.insertParagraph('Content of a new paragraph', Word.InsertLocation.after);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Paragraph added to the end of the range.');
    });
Word.Range#insertText:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert the paragraph at the end of the range.
        range.insertText('New text inserted into the range.', Word.InsertLocation.end);
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Text added to the end of the range.');
    });
Word.Range#select:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to get the current selection and then
        // create a proxy range object with the results.
        const range = context.document.getSelection();
    
        // Queue a command to insert HTML in to the beginning of the range.
        range.insertHtml('<strong>This is text inserted with range.insertHtml()</strong>', Word.InsertLocation.start);
    
        // Queue a command to select the HTML that was inserted.
        range.select();
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Selected the range.');
    });
Word.RequestContext:class:
  - |-
    // *.run methods automatically create an OfficeExtension.ClientRequestContext
    // object to work with the Office file.
    await Word.run(async (context: Word.RequestContext) => {
      const document = context.document;
      // Interact with the Word document...
    });
Word.SearchOptions:class:
  - |-
    // Search using a wildcard
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Queue a command to search the document with a wildcard
        // for any string of characters that starts with 'to' and ends with 'n'.
        const searchResults = context.document.body.search('to*n', {matchWildcards: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Found count: ' + searchResults.items.length);

        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'purple';
            searchResults.items[i].font.highlightColor = 'pink';
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    }); 
Word.SearchOptions#load:member(1):
  - |-
    // Ignore punctuation search
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Queue a command to search the document and ignore punctuation.
        const searchResults = context.document.body.search('video you', {ignorePunct: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Found count: ' + searchResults.items.length);

        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'purple';
            searchResults.items[i].font.highlightColor = '#FFFF00'; //Yellow
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    });  
  - |-
    // Search based on a prefix
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Queue a command to search the document based on a prefix.
        const searchResults = context.document.body.search('vid', {matchPrefix: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    
        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'purple';
            searchResults.items[i].font.highlightColor = '#FFFF00'; //Yellow
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    }); 
  - |-
    // Search based on a suffix
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue a command to search the document for any string of characters after 'ly'.
        const searchResults = context.document.body.search('ly', {matchSuffix: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Found count: ' + searchResults.items.length);

        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'orange';
            searchResults.items[i].font.highlightColor = 'black';
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    });  
  - |-
    // Search using a wildcard
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Queue a command to search the document with a wildcard
        // for any string of characters that starts with 'to' and ends with 'n'.
        const searchResults = context.document.body.search('to*n', {matchWildcards: true});
    
        // Queue a command to load the search results and get the font property values.
        searchResults.load('font');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('Found count: ' + searchResults.items.length);

        // Queue a set of commands to change the font for each found item.
        for (let i = 0; i < searchResults.items.length; i++) {
            searchResults.items[i].font.color = 'purple';
            searchResults.items[i].font.highlightColor = 'pink';
            searchResults.items[i].font.bold = true;
        }
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
    }); 
Word.Section#getFooter:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy sectionsCollection object.
        const mySections = context.document.sections;
        
        // Queue a command to load the sections.
        mySections.load('body/style');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            
        // Create a proxy object the primary footer of the first section.
        // Note that the footer is a body object.
        const myFooter = mySections.items[0].getFooter(Word.HeaderFooterType.primary);
        
        // Queue a command to insert text at the end of the footer.
        myFooter.insertText("This is a footer.", Word.InsertLocation.end);
        
        // Queue a command to wrap the header in a content control.
        myFooter.insertContentControl();
                                
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log("Added a footer to the first section.");   
    });  
Word.Section#getHeader:member(2):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
        
        // Create a proxy sectionsCollection object.
        const mySections = context.document.sections;
        
        // Queue a command to load the sections.
        mySections.load('body/style');
        
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        
        // Create a proxy object the primary header of the first section.
        // Note that the header is a body object.
        const myHeader = mySections.items[0].getHeader("Primary");
        
        // Queue a command to insert text at the end of the header.
        myHeader.insertText("This is a header.", Word.InsertLocation.end);
        
        // Queue a command to wrap the header in a content control.
        myHeader.insertContentControl();
                                
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log("Added a header to the first section.");
    });  
Word.Setting#delete:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        const startMonth = settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        const count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);

        // Queue a command to delete the setting.
        startMonth.delete();

        // Queue a command to get the new count of settings.
        count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);
    });
Word.SettingCollection#deleteAll:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        const count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);

        // Queue a command to delete all settings.
        settings.deleteAll();

        // Queue a command to get the new count of settings.
        count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);
    });
Word.SettingCollection#getCount:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to get the count of settings.
        const count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);

        // Queue a command to delete all settings.
        settings.deleteAll();

        // Queue a command to get the new count of settings.
        count = settings.getCount();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(count.value);
    });
Word.SettingCollection#getItem:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
    
        // Queue a command to retrieve a setting.
        const startMonth = settings.getItem('startMonth');
    
        // Queue a command to load the setting.
        startMonth.load();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
        console.log(JSON.stringify(startMonth.value));
    });
Word.SettingCollection#getItemOrNullObject:member(1):
  - |-
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Queue commands add a setting.
        const settings = context.document.settings;
        settings.add('startMonth', { month: 'March', year: 1998 });
        
        // Queue commands to retrieve settings.
        const startMonth = settings.getItemOrNullObject('startMonth');
        const endMonth = settings.getItemOrNullObject('endMonth');
    
        // Queue commands to load settings.
        startMonth.load();
        endMonth.load();
    
        // Synchronize the document state by executing the queued commands, 
        // and return a promise to indicate task completion.
        await context.sync();
            if (startMonth.isNullObject) {
                console.log("No such setting.");
            }
            else {
                console.log(JSON.stringify(startMonth.value));
            }
            if (endMonth.isNullObject) {
                console.log("No such setting.");
            }
            else {
                console.log(JSON.stringify(endMonth.value));
            }
    });
Word.UnderlineType:enum:
  - |-
    // Underline format text
    // Run a batch operation against the Word object model.
    await Word.run(async (context) => {
    
        // Create a range proxy object for the current selection.
        const selection = context.document.getSelection();
    
        // Queue a command to underline the current selection.
        selection.font.underline = Word.UnderlineType.single;
    
        // Synchronize the document state by executing the queued commands,
        // and return a promise to indicate task completion.
        await context.sync();
        console.log('The selection now has an underline style.');
    });

